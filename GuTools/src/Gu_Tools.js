// ==========================================================================
//  å®ç° "å’•å’•ç‰›å·¥å…·" é¡µé¢çš„åŠŸèƒ½ï¼ŒåŒ…æ‹¬ JSON ç”Ÿæˆå™¨ã€å›¾ç‰‡å…¥åº“ã€MD5æ ¡å‡†ã€åºå·ç®¡ç†ã€JSONæ ¡å‡†ã€‚
//       åŒæ—¶åŒ…å«ä¸åå°æœç´¢ Web Worker çš„äº¤äº’é€»è¾‘ã€‚
// ==========================================================================

// --- å…¨å±€å˜é‡ (MD5 & Sequence & JSON Calibration ç›¸å…³) ---
let mismatchDataForFixing = []; // ç”¨äºå­˜å‚¨ MD5 ä¸ä¸€è‡´çš„è¯¦ç»†ä¿¡æ¯ { path, expected, actual }
let filesNotInJsonData = []; // ç”¨äºå­˜å‚¨æ–‡ä»¶å­˜åœ¨ä½† JSON æ— è®°å½•çš„æ–‡ä»¶è·¯å¾„
let sequenceAnalysisResults = []; // ç”¨äºå­˜å‚¨åºå·åˆ†æçš„é—®é¢˜ç»“æœæ–‡æœ¬
let sequenceFixPlan = []; // ç”¨äºå­˜å‚¨åºå·ä¿®å¤è®¡åˆ’ { folderName: "...", filesToRename: [{ current: "...", new: "..." }] }
let jsonMissingEntries = []; // ç”¨äºå­˜å‚¨ JSON ä¸­å­˜åœ¨ä½†æ–‡ä»¶ç¼ºå¤±çš„å®Œæ•´æ¡ç›®
let jsonCalibrationMissingPaths = []; // ä»…å­˜å‚¨ç¼ºå¤±æ–‡ä»¶çš„è·¯å¾„ï¼Œç”¨äºæ˜¾ç¤º

// --------------------------------------------------------------------------
// GuTools æ¨¡å¼åˆ‡æ¢ & UI æ›´æ–°
// --------------------------------------------------------------------------

/**
 * å¡«å……å·¦ä¾§ JSON MD5 è®°å½•åˆ—è¡¨ã€‚
 */
function populateJsonMd5List() {
    if (!DOM.jsonMd5ListContainer || !DOM.jsonTotalEntriesDisplay) {
        console.warn("MD5 æ ¡å‡†: æ— æ³•å¡«å……åˆ—è¡¨ï¼Œç¼ºå°‘ DOM å…ƒç´  (jsonMd5ListContainer æˆ– jsonTotalEntriesDisplay)ã€‚");
        return;
    }

    DOM.jsonMd5ListContainer.innerHTML = ''; // æ¸…ç©ºæ—§åˆ—è¡¨
    const entries = AppState.savedEntries || [];
    DOM.jsonTotalEntriesDisplay.textContent = entries.length.toString(); // æ›´æ–°æ€»æ•°

    if (entries.length === 0) {
        DOM.jsonMd5ListContainer.innerHTML = '<p class="list-placeholder">JSON æ•°æ®ä¸ºç©ºã€‚</p>';
        return;
    }

    const fragment = document.createDocumentFragment();
    entries.sort((a, b) => (a.path || '').localeCompare(b.path || ''));

    entries.forEach(entry => {
        if (entry && entry.path && entry.attributes) {
            const listItem = document.createElement('div');
            listItem.className = 'json-md5-item';
            listItem.dataset.path = entry.path;

            const nameSpan = document.createElement('span');
            nameSpan.className = 'item-name';
            let displayName = entry.attributes.filename || entry.path.split('/').pop();

            const lastDotIndex = displayName.lastIndexOf('.');
            if (lastDotIndex > 0) { 
                displayName = displayName.substring(0, lastDotIndex); 
            }
            nameSpan.textContent = displayName; 
            nameSpan.title = entry.path; 

            const md5Span = document.createElement('span');
            md5Span.className = 'item-md5';
            md5Span.textContent = entry.attributes.md5 || 'N/A';
            md5Span.title = entry.attributes.md5 || 'æ— è®°å½•';

            listItem.appendChild(nameSpan);
            listItem.appendChild(md5Span);
            fragment.appendChild(listItem);
        }
    });
    DOM.jsonMd5ListContainer.appendChild(fragment);
    console.log(`MD5 æ ¡å‡†: å·¦ä¾§ JSON åˆ—è¡¨å·²å¡«å…… ${entries.length} æ¡è®°å½•ã€‚`);
}

/**
 * åˆ‡æ¢ GuTools é¢æ¿çš„è§†å›¾æ¨¡å¼ã€‚
 * @param {'generator' | 'import' | 'md5' | 'sequence' | 'json_calibration'} targetMode - ç›®æ ‡æ¨¡å¼ã€‚
 */
function switchGuToolMode(targetMode) {
    const views = {
        generator: DOM.generatorPaneView,
        import: DOM.importPaneView,
        md5: DOM.md5PaneView,
        sequence: DOM.sequencePaneView,
        json_calibration: DOM.jsonCalibrationPaneView // æ·»åŠ æ–°è§†å›¾
    };

    if (!views[targetMode]) {
        console.error(`Guå·¥å…·: å°è¯•åˆ‡æ¢åˆ°æ— æ•ˆæ¨¡å¼æˆ–è§†å›¾å…ƒç´ ç¼ºå¤±: ${targetMode}`);
        return;
    }
    if (targetMode === AppState.currentGuToolMode && views[targetMode] && !views[targetMode].classList.contains(CLASS_NAMES.HIDDEN)) {
        console.debug(`Guå·¥å…·: æ¨¡å¼å·²ç»æ˜¯ ${targetMode} ä¸”å¯è§ã€‚`);
        return;
    }

    console.log(`Guå·¥å…·: æ­£åœ¨åˆ‡æ¢æ¨¡å¼åˆ°: ${targetMode}`);

    // --- ä¸­æ­¢æ­£åœ¨è¿›è¡Œçš„æ“ä½œ ---
    if (AppState.isCalibrationRunning && targetMode !== 'md5') {
        console.log(`Guå·¥å…·: åˆ‡æ¢ï¼Œä¸­æ­¢ MD5 æ ¡å‡†...`);
        AppState.isCalibrationAborted = true; // è®¾ç½®ä¸­æ­¢æ ‡å¿—ä¼šåœæ­¢å¾ªç¯
    }
    if (AppState.isSequenceAnalysisRunning && targetMode !== 'sequence') {
        console.log(`Guå·¥å…·: åˆ‡æ¢ï¼Œä¸­æ­¢åºå·åˆ†æ... (å¦‚æœéœ€è¦ï¼Œå®ç°ä¸­æ­¢é€»è¾‘)`);
        // AppState.isSequenceAnalysisAborted = true; // å¦‚æœéœ€è¦ä¸­æ­¢åºå·åˆ†æ
    }
    if (AppState.isJsonCalibrationRunning && targetMode !== 'json_calibration') {
        console.log(`Guå·¥å…·: åˆ‡æ¢ï¼Œä¸­æ­¢ JSON æ ¡å‡†... (å¦‚æœéœ€è¦ï¼Œå®ç°ä¸­æ­¢é€»è¾‘)`);
        AppState.isJsonCalibrationRunning = false; // ç®€å•æ ‡è®°åœæ­¢
    }
    // ------------------------------------------

    AppState.currentGuToolMode = targetMode;

    Object.values(views).forEach(view => {
        if (view) view.classList.add(CLASS_NAMES.HIDDEN);
    });

    views[targetMode].classList.remove(CLASS_NAMES.HIDDEN);

    if (DOM.guToolsModeButtonGroups) {
        DOM.guToolsModeButtonGroups.forEach(buttonGroup => {
            const buttons = buttonGroup.querySelectorAll('.mode-button[data-mode]');
            buttons.forEach(button => {
                button.classList.toggle(CLASS_NAMES.ACTIVE, button.dataset.mode === targetMode);
            });
        });
    } else {
        console.warn("Guå·¥å…·: æœªæ‰¾åˆ°æ¨¡å¼æŒ‰é’®ç»„ã€‚");
    }

    // --- ç‰¹å®šæ¨¡å¼åŠ è½½/é‡ç½®é€»è¾‘ ---
    switch (targetMode) {
        case 'generator':
            hideImportMessage();
            // æ¸…ç† MD5/Sequence/JSON Calibration å¯èƒ½ç•™ä¸‹çš„æ¶ˆæ¯æˆ–çŠ¶æ€ï¼Ÿ
            break;
        case 'import':
            hideMessage();
            // ç¡®ä¿ Import åŠŸèƒ½æ‰€éœ€çš„å‡½æ•°éƒ½å­˜åœ¨
            if (typeof loadImportDataIfNeeded === 'function') {
                if (!AppState.guToolsImportDataLoaded) {
                    loadImportDataIfNeeded();
                } else {
                    if (typeof updateImportInputPlaceholders === 'function') updateImportInputPlaceholders();
                    else console.warn("switchGuToolMode (import): updateImportInputPlaceholders æœªå®šä¹‰ã€‚");
                }
            } else { console.error("é”™è¯¯: loadImportDataIfNeeded æœªå®šä¹‰ï¼"); displayImportMessage("é”™è¯¯ï¼šæ— æ³•åŠ è½½å…¥åº“æ•°æ®", CLASS_NAMES.ERROR); }
            break;
        case 'md5':
            hideMessage(); hideImportMessage();
            if (!AppState.isCalibrationRunning) { // åªæœ‰åœ¨æ ¡å‡†æœªè¿è¡Œæ—¶æ‰é‡ç½®
                console.log("Guå·¥å…·: è¿›å…¥ MD5 æ¨¡å¼ (æ ¡å‡†æœªè¿è¡Œ)ï¼Œé‡ç½® UIã€‚");
                populateJsonMd5List();
                if(DOM.mismatchedMD5List) DOM.mismatchedMD5List.value = '';
                if(DOM.filesNotInJsonList) DOM.filesNotInJsonList.value = '';
                if(DOM.mismatchedMD5Count) DOM.mismatchedMD5Count.textContent = '0';
                if(DOM.mismatchedCountDisplay) DOM.mismatchedCountDisplay.textContent = '0';
                if(DOM.filesNotInJsonCount) DOM.filesNotInJsonCount.textContent = '0';
                if(DOM.md5CalibrationProgress) DOM.md5CalibrationProgress.textContent = '';
                if(DOM.md5CalibrationProgressBar) { DOM.md5CalibrationProgressBar.style.display = 'none'; DOM.md5CalibrationProgressBar.value = 0; }
                if(DOM.filesCheckedCount) DOM.filesCheckedCount.textContent = '0';
                if(DOM.totalFilesChecked) DOM.totalFilesChecked.textContent = '--';
                if(DOM.totalMD5Count) DOM.totalMD5Count.textContent = AppState.savedEntries.length.toString();
                if(DOM.fixAllMismatchedMD5) { DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); }
                if(DOM.abortMD5Calibration) DOM.abortMD5Calibration.disabled = true;
            } else { console.log("Guå·¥å…·: åˆ‡å› MD5 (è¿è¡Œä¸­)ã€‚"); populateJsonMd5List(); } // åªæ›´æ–°åˆ—è¡¨
            break;
        case 'sequence':
            hideMessage(); hideImportMessage();
            if (!AppState.isSequenceAnalysisRunning) { // åªæœ‰åœ¨åˆ†ææœªè¿è¡Œæ—¶æ‰é‡ç½®
                console.log("Guå·¥å…·: è¿›å…¥ Sequence æ¨¡å¼ (åˆ†ææœªè¿è¡Œ)ï¼Œé‡ç½® UIã€‚");
                if(DOM.sequenceAnalysisStatus) DOM.sequenceAnalysisStatus.innerHTML = '<p>ç‚¹å‡»æŒ‰é’®å¼€å§‹æ‰«æ...</p>';
                if(DOM.sequenceIssuesList) DOM.sequenceIssuesList.value = '';
                if(DOM.fixSequenceIssues) { DOM.fixSequenceIssues.disabled = true; DOM.fixSequenceIssues.classList.add('disabled'); DOM.fixSequenceIssues.textContent = `ä¸€é”®ä¿®å¤`;}
            } else { console.log("Guå·¥å…·: åˆ‡å› Sequence (è¿è¡Œä¸­)ã€‚"); }
            if (AppState.characterFoldersList.length === 0 && typeof fetchCharacterFolders === 'function') {
                 console.log("Guå·¥å…·: Sequence, åŠ è½½æ–‡ä»¶å¤¹..."); fetchCharacterFolders();
            } else if (AppState.characterFoldersList.length === 0) { console.warn("åºå·ç®¡ç†: fetchCharacterFolders æœªå®šä¹‰ã€‚"); }
            break;
        case 'json_calibration':
            hideMessage(); hideImportMessage();
            if (!AppState.isJsonCalibrationRunning) {
                 console.log("Guå·¥å…·: è¿›å…¥ JSON æ ¡å‡†æ¨¡å¼ï¼Œé‡ç½® UIã€‚");
                 if(DOM.jsonEntriesCheckedCount) DOM.jsonEntriesCheckedCount.textContent = '0';
                 if(DOM.jsonFilesCheckedCount) DOM.jsonFilesCheckedCount.textContent = '--';
                 if(DOM.missingFilesCount) DOM.missingFilesCount.textContent = '0';
                 if(DOM.missingFilesCountDisplay) DOM.missingFilesCountDisplay.textContent = '0';
                 if(DOM.jsonCalibrationProgress) DOM.jsonCalibrationProgress.textContent = '';
                 if(DOM.jsonCalibrationProgressBar) { DOM.jsonCalibrationProgressBar.style.display = 'none'; DOM.jsonCalibrationProgressBar.value = 0; }
                 if(DOM.missingFilesList) DOM.missingFilesList.value = '';
                 if(DOM.removeMissingEntriesBtn) { DOM.removeMissingEntriesBtn.disabled = true; DOM.removeMissingEntriesBtn.classList.add('disabled'); }
                 if(DOM.startJsonCalibration) DOM.startJsonCalibration.disabled = false;
            } else { console.log("Guå·¥å…·: åˆ‡å› JSON æ ¡å‡† (å¯èƒ½è¿è¡Œä¸­)ã€‚"); }
            break;
        default: console.warn(`Guå·¥å…·: æœªçŸ¥æ¨¡å¼: ${targetMode}`);
    }
}

/**
 * è®¾ç½® GuTools å†…éƒ¨æ¨¡å¼åˆ‡æ¢æŒ‰é’®çš„äº‹ä»¶ç›‘å¬å™¨ã€‚
 */
function setupGuToolsModeSwitcher() {
    const modeButtons = document.querySelectorAll('#GuTools .mode-button[data-mode]');
    if (!modeButtons || modeButtons.length === 0) { console.error("Guå·¥å…·: æœªæ‰¾åˆ°æ¨¡å¼åˆ‡æ¢æŒ‰é’®ã€‚"); return; }
    const handleModeButtonClick = (event) => { const targetMode = event.currentTarget.dataset.mode; if (targetMode) switchGuToolMode(targetMode); };
    modeButtons.forEach(button => { button.removeEventListener('click', handleModeButtonClick); button.addEventListener('click', handleModeButtonClick); });
    console.log(`Guå·¥å…·: ä¸º ${modeButtons.length} ä¸ªæ¨¡å¼æŒ‰é’®è®¾ç½®äº†ç›‘å¬å™¨ã€‚`);
}

// --------------------------------------------------------------------------
// JSON ç”Ÿæˆå™¨ (Generator) åŠŸèƒ½ (æ¥è‡ªä½ çš„å›æ»šç‰ˆæœ¬)
// --------------------------------------------------------------------------
function clearGeneratorUI() { console.debug("Generator: æ¸…ç©º UI..."); AppState.isSettingInputProgrammatically = true; if (DOM.searchInput) DOM.searchInput.value = ''; clearFileInfoDisplay(); if (DOM.suggestionList) DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); AppState.showingRelatedImages = false; AppState.isShowingFolderSuggestions = false; AppState.currentSelection = null; AppState.currentGeneratedId = null; AppState.currentCalculatedMd5 = null; hideMessage(); setTimeout(() => { AppState.isSettingInputProgrammatically = false; }, 50); }
function clearFileInfoDisplay() { if (DOM.previewImage) { DOM.previewImage.classList.remove(CLASS_NAMES.FADE_IN); DOM.previewImage.classList.add(CLASS_NAMES.FADE_OUT); setTimeout(() => { if (DOM.previewImage) { DOM.previewImage.src = ""; DOM.previewImage.alt = "é€‰æ‹©å›¾ç‰‡"; DOM.previewImage.classList.add(CLASS_NAMES.HIDDEN); DOM.previewImage.style.display = 'none'; DOM.previewImage.classList.remove(CLASS_NAMES.FADE_OUT); } }, 300); } if (DOM.saveButton) DOM.saveButton.disabled = true; const dR = document.querySelector('input[name="rating"][value="none"]'); const dL = document.querySelector('input[name="layout"][value="normal"]'); if(dR) dR.checked = true; if(dL) dL.checked = true; if (DOM.isEasterEggCheckbox) DOM.isEasterEggCheckbox.checked = false; if (DOM.isAiImageCheckbox) DOM.isAiImageCheckbox.checked = false; if (DOM.md5DisplayInput) { DOM.md5DisplayInput.value = ''; DOM.md5DisplayInput.placeholder = '...'; } if (DOM.idDisplayInput) { DOM.idDisplayInput.value = ''; DOM.idDisplayInput.placeholder = '...'; } updateGameTagsHighlight(''); }
function updateGameTagsHighlight(galleryCode) { if (!DOM.gameTags || Object.values(DOM.gameTags).some(t => !t)) return; Object.values(DOM.gameTags).forEach(t => t.classList.remove(CLASS_NAMES.ACTIVE, 'gs', 'sr', 'zzz', 'waves')); let aK = null; switch (galleryCode) { case 'gs-character': aK = 'gs'; break; case 'sr-character': aK = 'sr'; break; case 'zzz-character': aK = 'zzz'; break; case 'waves-character': aK = 'waves'; break; } if (aK && DOM.gameTags[aK]) { DOM.gameTags[aK].classList.add(CLASS_NAMES.ACTIVE, aK); } }
async function fetchImageMd5(imagePath) { if (!imagePath) { console.warn("fetchImageMd5: pathä¸ºç©ºã€‚"); return null; } const url = `${API_ENDPOINTS.IMAGE_MD5}?path=${encodeURIComponent(imagePath)}`; try { const result = await fetchJsonData(url); if (result?.success === true && typeof result.md5 === 'string') { return result.md5; } else { throw new Error(result?.error || 'MD5è®¡ç®—/è¿”å›å¤±è´¥'); } } catch (error) { console.error(`è·å– ${imagePath} MD5 å‡ºé”™:`, error); return null; } }
function updateSaveButtonState() { if (!DOM.saveButton) return; let sE = false; if (AppState.currentSelection?.urlPath) { const iAS = AppState.savedImagePaths.has(AppState.currentSelection.urlPath); const iIR = !!AppState.currentGeneratedId && AppState.currentGeneratedId !== 'ç”Ÿæˆä¸­...'; const iMR = !!AppState.currentCalculatedMd5 && AppState.currentCalculatedMd5 !== 'è®¡ç®—ä¸­...' && AppState.currentCalculatedMd5 !== 'è®¡ç®—å¤±è´¥'; const iIL = DOM.previewImage && !DOM.previewImage.classList.contains(CLASS_NAMES.HIDDEN) && DOM.previewImage.src !== '' && !DOM.previewImage.alt.includes('å¤±è´¥') && !DOM.previewImage.alt.includes('åŠ è½½ä¸­'); sE = !iAS && iIR && iMR && iIL; } DOM.saveButton.disabled = !sE; }
async function displaySelectedImage(imgInfo) { if (!imgInfo?.urlPath) { console.error("Generator: æ— æ•ˆ imgInfo:", imgInfo); displayMessage("é”™è¯¯ï¼šå›¾ç‰‡ä¿¡æ¯æ— æ•ˆ", CLASS_NAMES.ERROR, DELAYS.MESSAGE_CLEAR); clearGeneratorUI(); return; } console.log("Generator: æ˜¾ç¤ºå›¾ç‰‡:", imgInfo.fileName); AppState.currentSelection = { ...imgInfo }; hideMessage(); if (DOM.suggestionList) DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); AppState.showingRelatedImages = false; AppState.isSettingInputProgrammatically = true; if (DOM.searchInput) DOM.searchInput.value = `${imgInfo.name || '?'} (${imgInfo.fileName})`; setTimeout(() => { AppState.isSettingInputProgrammatically = false; }, 50); updateGameTagsHighlight(imgInfo.gallery); const dR = document.querySelector('input[name="rating"][value="none"]'); const dL = document.querySelector('input[name="layout"][value="normal"]'); if(dR) dR.checked = true; if(dL) dL.checked = true; if (DOM.isEasterEggCheckbox) DOM.isEasterEggCheckbox.checked = false; if (DOM.isAiImageCheckbox) DOM.isAiImageCheckbox.checked = false; if (DOM.saveButton) DOM.saveButton.disabled = true; if (DOM.idDisplayInput) { DOM.idDisplayInput.value = ''; DOM.idDisplayInput.placeholder = '...'; } if (DOM.md5DisplayInput) { DOM.md5DisplayInput.value = ''; DOM.md5DisplayInput.placeholder = '...'; } AppState.currentGeneratedId = null; AppState.currentCalculatedMd5 = null; const existingEntry = AppState.savedEntries.find(e => e.path === imgInfo.urlPath); if (existingEntry?.attributes) { console.log("Generator: å·²å­˜åœ¨:", existingEntry.gid); displayMessage(`æç¤ºï¼š"${imgInfo.fileName}" å·²åœ¨ JSON ä¸­ã€‚`, CLASS_NAMES.INFO); const a = existingEntry.attributes; const g = existingEntry.gid; if (DOM.idDisplayInput) { DOM.idDisplayInput.value = g || 'N/A'; DOM.idDisplayInput.placeholder = 'GID'; } if (DOM.md5DisplayInput) { DOM.md5DisplayInput.value = a.md5 || 'N/A'; DOM.md5DisplayInput.placeholder = 'MD5'; } AppState.currentGeneratedId = g || null; AppState.currentCalculatedMd5 = a.md5 || null; let rV = 'none'; if (a.isPx18) rV = 'px18'; else if (a.isRx18) rV = 'rx18'; const rR = document.querySelector(`input[name="rating"][value="${rV}"]`); if (rR) rR.checked = true; const lV = a.layout || 'normal'; const lR = document.querySelector(`input[name="layout"][value="${lV}"]`); if (lR) lR.checked = true; if (DOM.isEasterEggCheckbox) DOM.isEasterEggCheckbox.checked = !!a.isEasterEgg; if (DOM.isAiImageCheckbox) DOM.isAiImageCheckbox.checked = !!a.isAiImage; if (DOM.saveButton) DOM.saveButton.disabled = true; } else { console.log("Generator: æ–°å›¾ç‰‡..."); if (DOM.idDisplayInput) DOM.idDisplayInput.placeholder = 'ç”Ÿæˆä¸­...'; if (DOM.md5DisplayInput) DOM.md5DisplayInput.placeholder = 'è®¡ç®—ä¸­...'; AppState.currentGeneratedId = generateNumericId(); if (DOM.idDisplayInput) { DOM.idDisplayInput.value = AppState.currentGeneratedId; DOM.idDisplayInput.placeholder = 'GID'; } fetchImageMd5(imgInfo.urlPath).then(m => { if (m) { AppState.currentCalculatedMd5 = m; if (DOM.md5DisplayInput) { DOM.md5DisplayInput.value = m; DOM.md5DisplayInput.placeholder = 'MD5'; } } else { AppState.currentCalculatedMd5 = 'è®¡ç®—å¤±è´¥'; if (DOM.md5DisplayInput) { DOM.md5DisplayInput.value = 'å¤±è´¥'; DOM.md5DisplayInput.placeholder = 'é”™è¯¯'; } } updateSaveButtonState(); }).catch(e => { console.error("Generator: fetchMd5 é”™è¯¯:", e); AppState.currentCalculatedMd5 = 'è®¡ç®—å¤±è´¥'; if (DOM.md5DisplayInput) { DOM.md5DisplayInput.value = 'å¤±è´¥'; DOM.md5DisplayInput.placeholder = 'é”™è¯¯'; } updateSaveButtonState(); }); } const imgP = imgInfo.urlPath.startsWith('/') ? imgInfo.urlPath : `/${imgInfo.urlPath}`; if (DOM.previewImage) { DOM.previewImage.src = ""; DOM.previewImage.alt = "åŠ è½½ä¸­..."; DOM.previewImage.classList.add(CLASS_NAMES.HIDDEN, CLASS_NAMES.FADE_OUT); DOM.previewImage.style.display = 'none'; DOM.previewImage.onerror = () => { console.error("Generator: é¢„è§ˆå¤±è´¥:", imgP); displayMessage(`é”™è¯¯ï¼šåŠ è½½é¢„è§ˆ (${imgInfo.fileName})`, CLASS_NAMES.ERROR); DOM.previewImage.classList.add(CLASS_NAMES.HIDDEN); DOM.previewImage.style.display = 'none'; DOM.previewImage.alt = "å¤±è´¥"; if (DOM.saveButton) DOM.saveButton.disabled = true; }; DOM.previewImage.onload = () => { console.log("Generator: é¢„è§ˆæˆåŠŸ:", imgP); DOM.previewImage.alt = imgInfo.name || 'Selected'; DOM.previewImage.classList.remove(CLASS_NAMES.HIDDEN, CLASS_NAMES.FADE_OUT); DOM.previewImage.style.display = 'block'; DOM.previewImage.classList.add(CLASS_NAMES.FADE_IN); updateSaveButtonState(); setTimeout(() => DOM.previewImage?.classList.remove(CLASS_NAMES.FADE_IN), 300); }; DOM.previewImage.src = imgP; } }
async function saveEntry() { if (DOM.saveButton) DOM.saveButton.disabled = true; if (AppState.writingTimerId) clearInterval(AppState.writingTimerId); AppState.writingTimerId = null; AppState.writingStartTime = null; if (AppState.successTimerId) clearInterval(AppState.successTimerId); AppState.successTimerId = null; AppState.successStartTime = null; if (!AppState.currentSelection || !DOM.md5DisplayInput || !DOM.idDisplayInput) { displayMessage('é”™è¯¯ï¼šæœªé€‰å›¾æˆ–ä¿¡æ¯ç¼ºå¤±', CLASS_NAMES.ERROR, DELAYS.MESSAGE_CLEAR); return; } const cFN = AppState.currentSelection.fileName || 'æœªçŸ¥'; const rI = document.querySelector('input[name="rating"]:checked'); const lI = document.querySelector('input[name="layout"]:checked'); const iEE = DOM.isEasterEggCheckbox?.checked ?? false; const iAI = DOM.isAiImageCheckbox?.checked ?? false; const md5V = DOM.md5DisplayInput.value; const gidV = DOM.idDisplayInput.value; const relP = AppState.currentSelection.urlPath; if (AppState.savedImagePaths.has(relP)) { displayMessage(`é”™è¯¯ï¼š"${cFN}" å·²å­˜åœ¨`, CLASS_NAMES.ERROR); findAndDisplayNextUnsavedImage(AppState.currentSelection); return; } if (!gidV || gidV === 'N/A' || gidV === 'ç”Ÿæˆä¸­...') { displayMessage("é”™è¯¯ï¼šæ— æ•ˆ GID", CLASS_NAMES.ERROR, DELAYS.MESSAGE_CLEAR); return; } if (!md5V || md5V === 'è®¡ç®—å¤±è´¥' || md5V === 'è®¡ç®—ä¸­...') { displayMessage("é”™è¯¯ï¼šæ— æ•ˆ MD5", CLASS_NAMES.ERROR, DELAYS.MESSAGE_CLEAR); return; } const nE = { gid: gidV, characterName: AppState.currentSelection.name || 'Unknown', path: relP, attributes: { filename: cFN, parentFolder: AppState.currentSelection.folderName, isPx18: rI?.value === 'px18', isRx18: rI?.value === 'rx18', layout: lI?.value || 'normal', isEasterEgg: iEE, isAiImage: iAI, isBan: false, md5: md5V, Downloaded_From: 'none' }, timestamp: new Date().toISOString(), sourceGallery: AppState.currentSelection.gallery }; console.log("Generator: å‡†å¤‡ä¿å­˜:", nE); const uD = [...AppState.savedEntries, nE]; const bWM = `å†™å…¥ä¸­ï¼š${cFN}`; displayMessage(bWM, CLASS_NAMES.INFO, null); AppState.writingStartTime = Date.now(); AppState.writingTimerId = setInterval(() => { if (!AppState.writingStartTime || !DOM.messageArea?.classList.contains(CLASS_NAMES.INFO)) { clearInterval(AppState.writingTimerId); AppState.writingTimerId = null; AppState.writingStartTime = null; return; } const eS = ((Date.now() - AppState.writingStartTime) / 1000).toFixed(1); if (DOM.messageArea) DOM.messageArea.textContent = `${bWM} (${eS}s)`; }, 100); let success = false; const sOST = Date.now(); try { if (typeof updateUserData !== 'function') throw new Error("updateUserData æœªå®šä¹‰ï¼"); success = await updateUserData(uD, `æˆåŠŸæ·»åŠ  "${cFN}"`, 'messageArea', false); } catch (error) { console.error("Generator: ä¿å­˜å‡ºé”™:", error); displayMessage(`ä¿å­˜å‡ºé”™: ${error.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); success = false; } finally { if (AppState.writingTimerId) { clearInterval(AppState.writingTimerId); AppState.writingTimerId = null; AppState.writingStartTime = null; } if (success) { const sD = ((Date.now() - sOST) / 1000).toFixed(1); displayMessage(`æˆåŠŸæ·»åŠ  "${cFN}" (${sD}s)`, CLASS_NAMES.SUCCESS, DELAYS.MESSAGE_CLEAR); } else { console.log("Generator: ä¿å­˜å¤±è´¥æˆ–é”™è¯¯å·²å¤„ç†ã€‚"); } clearTimeout(AppState.messageClearTimer); AppState.messageClearTimer = null; setTimeout(() => { console.debug("Generator: æŸ¥æ‰¾ä¸‹ä¸€ä¸ª..."); hideMessage(); findAndDisplayNextUnsavedImage(AppState.currentSelection); }, success ? DELAYS.NEXT_IMAGE_DISPLAY : 500); } }
function findAndDisplayNextUnsavedImage(lastSavedImageInfo) { if (!lastSavedImageInfo?.folderName || !lastSavedImageInfo?.urlPath) { console.warn("Generator: findNextæ— æ•ˆå‚æ•°ã€‚"); clearGeneratorUI(); return; } const cF = lastSavedImageInfo.folderName; console.log(`Generator: åœ¨ "${cF}" æŸ¥æ‰¾ä¸‹ä¸€ä¸ª...`); const iIF = (AppState.allGalleryImages || []).filter(i => i?.folderName === cF).sort((a, b) => (a.fileName || '').localeCompare(b.fileName || '', undefined, { numeric: true, sensitivity: 'base' })); if (iIF.length === 0) { console.log(`Generator: "${cF}" ä¸ºç©ºã€‚`); clearGeneratorUI(); return; } const cI = iIF.findIndex(i => i?.urlPath === lastSavedImageInfo.urlPath); let nUI = null; if (cI !== -1) { for (let i = cI + 1; i < iIF.length; i++) { const pN = iIF[i]; if (pN?.urlPath && !AppState.savedImagePaths.has(pN.urlPath)) { nUI = pN; console.log(`Generator: æ‰¾åˆ°ä¸‹ä¸€ä¸ª: ${nUI.fileName}`); break; } } } else { console.warn(`Generator: æœªæ‰¾åˆ°åˆšä¿å­˜çš„ ${lastSavedImageInfo.urlPath}ã€‚ä»å¤´æŸ¥æ‰¾...`); for (let i = 0; i < iIF.length; i++) { const pN = iIF[i]; if (pN?.urlPath && !AppState.savedImagePaths.has(pN.urlPath)) { nUI = pN; console.log(`Generator: ä»å¤´æ‰¾åˆ°: ${nUI.fileName}`); break; } } } if (nUI) { displaySelectedImage(nUI); } else { console.log(`Generator: "${cF}" å·²æ— æœªä¿å­˜ã€‚`); displayToast(`"${cF}" å¤„ç†å®Œæ¯•ï¼`, CLASS_NAMES.SUCCESS, DELAYS.MESSAGE_CLEAR); clearGeneratorUI(); } }
function handleGeneratorSearchInput() { if (AppState.isSettingInputProgrammatically) return; const q = DOM.searchInput.value.trim(); const cST = AppState.currentSelection ? `${AppState.currentSelection.name || '?'} (${AppState.currentSelection.fileName})` : ''; if (AppState.isShowingFolderSuggestions) { if (DOM.suggestionList) DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); AppState.isShowingFolderSuggestions = false; } if (AppState.currentSelection && q !== cST) { console.log("Generator: è¾“å…¥ä¸åŒï¼Œæ¸…ç©ºã€‚"); clearGeneratorUI(); AppState.currentSelection = null; } AppState.showingRelatedImages = false; clearTimeout(AppState.searchDelayTimer); if (q === '') { if (DOM.suggestionList) DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); return; } AppState.searchDelayTimer = setTimeout(() => { if (DOM.searchInput.value.trim() === q) { console.log(`Generator: æœç´¢: "${q}"`); processSearch(q); } else { console.debug("Generator: è¾“å…¥æ”¹å˜ï¼Œå–æ¶ˆã€‚"); } }, DELAYS.INPUT_DEBOUNCE); }
function handleGeneratorSearchFocus() { const cV = DOM.searchInput.value.trim(); const cST = AppState.currentSelection ? `${AppState.currentSelection.name || '?'} (${AppState.currentSelection.fileName})` : ''; if (cV === '') { const f = findTopUnsavedFolders(); showFolderSuggestions(f); AppState.showingRelatedImages = false; } else if (AppState.currentSelection && cV === cST && !AppState.showingRelatedImages && AppState.backgroundWorker) { console.log("Generator: èšç„¦åŒ¹é…ï¼Œè¯·æ±‚ç›¸å…³..."); AppState.backgroundWorker.postMessage({ type: 'findSiblings', payload: { currentImageInfo: AppState.currentSelection } }); AppState.showingRelatedImages = true; AppState.isShowingFolderSuggestions = false; } else if (!AppState.currentSelection || cV !== cST) { console.log("Generator: èšç„¦ä¸ç¬¦æˆ–æ— é€‰æ‹©ï¼Œæœç´¢..."); processSearch(cV); AppState.showingRelatedImages = false; AppState.isShowingFolderSuggestions = false; } }
function showSuggestions(results, isFolder = false) { if (!DOM.suggestionList) { console.error("Generator: suggestions æœªæ‰¾åˆ°ï¼"); return; } DOM.suggestionList.innerHTML = ''; if (!Array.isArray(results) || results.length === 0) { DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); AppState.isShowingFolderSuggestions = false; console.debug("Generator: æ— å»ºè®®ï¼Œéšè—ã€‚"); return; } console.debug(`Generator: æ˜¾ç¤º ${results.length} æ¡ ${isFolder ? 'æ–‡ä»¶å¤¹' : 'å›¾ç‰‡'} å»ºè®®ã€‚`); AppState.isShowingFolderSuggestions = isFolder; const f = document.createDocumentFragment(); if (isFolder) { results.forEach(fN => { const i = document.createElement('div'); i.className = 'suggestion-item folder-suggestion'; i.innerHTML = `ğŸ“‚ <span class="suggestion-text">${fN}</span>`; i.style.cursor = 'pointer'; i.onclick = () => { if (DOM.searchInput) DOM.searchInput.value = fN; DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); AppState.isShowingFolderSuggestions = false; if (DOM.searchInput) DOM.searchInput.focus(); }; f.appendChild(i); }); } else { const uI = results.filter(iI => iI?.urlPath && !AppState.savedImagePaths.has(iI.urlPath)); uI.sort((a, b) => (a.fileName || '').localeCompare(b.fileName || '', undefined, { numeric: true, sensitivity: 'base' })); if (uI.length === 0) { DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); console.debug("Generator: æ‰€æœ‰å»ºè®®å·²ä¿å­˜ï¼Œéšè—ã€‚"); return; } console.debug(`Generator: æ˜¾ç¤º ${uI.length} æœªä¿å­˜å»ºè®®ã€‚`); uI.forEach(iI => { const i = document.createElement('div'); i.className = 'suggestion-item image-suggestion'; const img = document.createElement('img'); const iP = iI.urlPath.startsWith('/') ? iI.urlPath : `/${iI.urlPath}`; img.alt = iI.name || 'å»ºè®®'; img.style.cssText = 'width:40px;height:40px;object-fit:cover;margin-right:8px;'; img.onerror = function() { this.style.display='none'; }; if (lazyLoadObserver) { img.dataset.src = iP; img.src = ''; lazyLoadObserver.observe(img); } else { console.warn("LazyLoadObserver ä¸å¯ç”¨:", iP); img.src = iP; img.loading = 'lazy'; } const s = document.createElement('span'); s.className = 'suggestion-text'; s.textContent = `${iI.name || '?'} (${iI.fileName})`; s.title = `${iI.folderName}/${iI.fileName}`; i.appendChild(img); i.appendChild(s); i.onclick = () => displaySelectedImage(iI); f.appendChild(i); }); } DOM.suggestionList.appendChild(f); DOM.suggestionList.classList.remove(CLASS_NAMES.HIDDEN); console.debug("Generator: å»ºè®®åˆ—è¡¨å·²æ˜¾ç¤ºã€‚"); }
function findTopUnsavedFolders(limit = 5) { const uFC = {}; const aF = new Set(); if (!AppState.allGalleryImages?.length) return []; for (const img of AppState.allGalleryImages) { if (!img?.folderName || !img.urlPath) continue; aF.add(img.folderName); if (!AppState.savedImagePaths.has(img.urlPath)) uFC[img.folderName] = (uFC[img.folderName] || 0) + 1; } const sF = Object.entries(uFC).sort(([, cA], [, cB]) => cB - cA).map(([fN]) => fN); return sF.slice(0, limit); }
function showFolderSuggestions(folderNames) { showSuggestions(folderNames, true); }

// --------------------------------------------------------------------------
// å›¾ç‰‡å…¥åº“ (Import) åŠŸèƒ½ (æ¥è‡ªä½ çš„å›æ»šç‰ˆæœ¬)
// --------------------------------------------------------------------------
async function loadImportDataIfNeeded() { if (AppState.guToolsImportDataLoaded) { console.log("Guå·¥å…·: Import æ•°æ®å·²åŠ è½½ã€‚"); updateImportInputPlaceholders(); return; } console.log("Guå·¥å…·: é¦–æ¬¡è¿›å…¥ Importï¼ŒåŠ è½½æ•°æ®..."); if(DOM.tempImageSearchInput) DOM.tempImageSearchInput.placeholder = 'åŠ è½½ä¸­...'; if(DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.placeholder = 'åŠ è½½ä¸­...'; if (typeof disableImportFormSections === "function") disableImportFormSections(); else console.warn("loadImportDataIfNeeded: disableImportFormSections æœªå®šä¹‰!"); try { if (typeof fetchTempImages !== "function" || typeof fetchCharacterFolders !== "function") throw new Error("fetchTempImages æˆ– fetchCharacterFolders æœªå®šä¹‰!"); await Promise.all([ fetchTempImages(), fetchCharacterFolders() ]); AppState.guToolsImportDataLoaded = true; console.log("Guå·¥å…·: Import æ•°æ®åŠ è½½å®Œæ¯•ã€‚"); if (typeof updateImportInputPlaceholders === "function") updateImportInputPlaceholders(); else console.warn("loadImportDataIfNeeded: updateImportInputPlaceholders æœªå®šä¹‰!"); if (AppState.selectedTempImageInfo && typeof enableImportFormSections === "function") enableImportFormSections(); else if(AppState.selectedTempImageInfo) console.warn("loadImportDataIfNeeded: enableImportFormSections æœªå®šä¹‰!"); } catch (error) { console.error("Guå·¥å…·: åŠ è½½ Import æ•°æ®å¤±è´¥:", error); displayToast("Import æ•°æ®åŠ è½½å¤±è´¥", CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); if(DOM.tempImageSearchInput) DOM.tempImageSearchInput.placeholder = 'åŠ è½½å¤±è´¥'; if(DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.placeholder = 'åŠ è½½å¤±è´¥'; } }
async function fetchTempImages() { if (!DOM.tempImageSearchInput) return; DOM.tempImageSearchInput.disabled = true; DOM.tempImageSearchInput.readOnly = false; DOM.tempImageSearchInput.style.cursor = 'default'; DOM.tempImageSearchInput.placeholder = 'åŠ è½½å¾…å…¥åº“...'; try { const data = await fetchJsonData(API_ENDPOINTS.TEMP_IMAGES); AppState.tempImagesList = Array.isArray(data) ? data : []; console.log(`Import: åŠ è½½ ${AppState.tempImagesList.length} å¾…å…¥åº“ã€‚`); updateImportInputPlaceholders(); if (AppState.tempImagesList.length === 0) displayImportMessage("æç¤ºï¼šimgtemp ä¸ºç©º", CLASS_NAMES.INFO); else if (DOM.importMessageArea?.textContent.includes("ä¸ºç©º")) hideImportMessage(); } catch (e) { console.error("Import: åŠ è½½å¾…å…¥åº“å¤±è´¥:", e); displayToast('åŠ è½½å¾…å…¥åº“å¤±è´¥', CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); DOM.tempImageSearchInput.placeholder = 'åŠ è½½å¤±è´¥'; DOM.tempImageSearchInput.disabled = true; AppState.tempImagesList = []; } }
async function fetchCharacterFolders() { if (!DOM.targetFolderSearchInput) return; try { const data = await fetchJsonData(API_ENDPOINTS.CHARACTER_FOLDERS); AppState.characterFoldersList = Array.isArray(data) ? data : []; console.log(`Import: åŠ è½½ ${AppState.characterFoldersList.length} ç›®æ ‡æ–‡ä»¶å¤¹ã€‚`); updateImportInputPlaceholders(); } catch (e) { console.error("Import: åŠ è½½æ–‡ä»¶å¤¹å¤±è´¥:", e); displayToast('åŠ è½½æ–‡ä»¶å¤¹å¤±è´¥', CLASS_NAMES.WARNING, DELAYS.TOAST_ERROR_DURATION); DOM.targetFolderSearchInput.placeholder = 'åŠ è½½å¤±è´¥ï¼Œå¯æ‰‹åŠ¨'; AppState.characterFoldersList = []; } }
function updateImportInputPlaceholders() { if (DOM.tempImageSearchInput) { const has = AppState.tempImagesList?.length > 0; DOM.tempImageSearchInput.disabled = !has; DOM.tempImageSearchInput.readOnly = has; DOM.tempImageSearchInput.style.cursor = has ? 'pointer' : 'default'; DOM.tempImageSearchInput.placeholder = has ? `ç‚¹å‡»é€‰æ‹© ${AppState.tempImagesList.length} å¼ å¾…å…¥åº“` : 'imgtemp ç›®å½•ä¸ºç©º'; } if (DOM.targetFolderSearchInput) { DOM.targetFolderSearchInput.placeholder = AppState.characterFoldersList.length > 0 ? `æœç´¢ ${AppState.characterFoldersList.length} ä¸ªæˆ–è¾“å…¥æ–°åç§°...` : 'è¾“å…¥æ–°æ–‡ä»¶å¤¹åç§°...'; DOM.targetFolderSearchInput.disabled = !AppState.selectedTempImageInfo; } }
function showTempImageSuggestions(results) { if (!DOM.tempImageSuggestions) { console.error("Import: tempImageSuggestions æœªæ‰¾åˆ°ï¼"); return; } if (!Array.isArray(results)) { console.error("Import: showTempImageSuggestions æ— æ•ˆ results:", results); DOM.tempImageSuggestions.classList.add(CLASS_NAMES.HIDDEN); return; } console.log(`Import: æ˜¾ç¤º ${results.length} å¾…å…¥åº“å»ºè®®ã€‚`); DOM.tempImageSuggestions.innerHTML = ''; if (results.length === 0) { DOM.tempImageSuggestions.classList.add(CLASS_NAMES.HIDDEN); return; } const fragment = document.createDocumentFragment(); results.slice(0, 20).forEach(imgInfo => { const item = document.createElement('div'); item.className = 'suggestion-item import-suggestion'; item.textContent = imgInfo.filename; item.title = imgInfo.path; item.onclick = () => selectTempImage(imgInfo); fragment.appendChild(item); }); DOM.tempImageSuggestions.appendChild(fragment); DOM.tempImageSuggestions.classList.remove(CLASS_NAMES.HIDDEN); console.log("Import: å¾…å…¥åº“å»ºè®®å·²æ˜¾ç¤ºã€‚"); }
function showTargetFolderSuggestions(results) { if (!DOM.targetFolderSuggestions || !DOM.targetFolderSearchInput) return; DOM.targetFolderSuggestions.innerHTML = ''; if (!results || results.length === 0) { DOM.targetFolderSuggestions.classList.add(CLASS_NAMES.HIDDEN); return; } const fragment = document.createDocumentFragment(); results.slice(0, 10).forEach(folderName => { const item = document.createElement('div'); item.className = 'suggestion-item import-suggestion'; item.textContent = folderName; item.onclick = () => selectTargetFolder(folderName); fragment.appendChild(item); }); DOM.targetFolderSuggestions.appendChild(fragment); DOM.targetFolderSuggestions.classList.remove(CLASS_NAMES.HIDDEN); }
function selectTempImage(imgInfo) { if (!imgInfo?.path || !imgInfo.filename) { console.error("Import: selectTempImage æ— æ•ˆ imgInfo:", imgInfo); return; } console.log("Import: é€‰æ‹©å¾…å…¥åº“:", imgInfo.filename); AppState.selectedTempImageInfo = imgInfo; if (DOM.tempImageSearchInput) DOM.tempImageSearchInput.value = imgInfo.filename; if (DOM.tempImagePreview) { const imageUrl = imgInfo.path.startsWith('/') ? imgInfo.path : `/${imgInfo.path}`; DOM.tempImagePreview.src = ""; DOM.tempImagePreview.alt = "åŠ è½½..."; DOM.tempImagePreview.classList.remove(CLASS_NAMES.HIDDEN); DOM.tempImagePreview.onerror = () => { console.error("Import: é¢„è§ˆå¤±è´¥:", imageUrl); displayToast(`é¢„è§ˆ "${imgInfo.filename}" å¤±è´¥`, CLASS_NAMES.ERROR); DOM.tempImagePreview.classList.add(CLASS_NAMES.HIDDEN); DOM.tempImagePreview.src = ""; DOM.tempImagePreview.alt = "å¤±è´¥"; AppState.selectedTempImageInfo = null; disableImportFormSections(); }; DOM.tempImagePreview.onload = () => { DOM.tempImagePreview.alt = imgInfo.filename; }; DOM.tempImagePreview.src = imageUrl; } if (DOM.tempImageSuggestions) DOM.tempImageSuggestions.classList.add(CLASS_NAMES.HIDDEN); enableImportFormSections(); if (DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.value = ''; if (DOM.finalFilenameInput) DOM.finalFilenameInput.value = ''; AppState.selectedTargetFolder = null; if (DOM.editFilenameButton) DOM.editFilenameButton.classList.add(CLASS_NAMES.HIDDEN); if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = true; }
async function selectTargetFolder(folderName) { folderName = folderName.trim(); if (!folderName) { console.warn("Import: ç©ºæ–‡ä»¶å¤¹ã€‚"); return; } console.log("Import: é€‰æ‹©ç›®æ ‡:", folderName); AppState.selectedTargetFolder = folderName; if (DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.value = folderName; if (DOM.targetFolderSuggestions) DOM.targetFolderSuggestions.classList.add(CLASS_NAMES.HIDDEN); if (DOM.finalFilenameInput) { DOM.finalFilenameInput.value = 'è·å–ç¼–å·...'; DOM.finalFilenameInput.readOnly = true; DOM.finalFilenameInput.classList.remove(CLASS_NAMES.EDITABLE); } if (DOM.editFilenameButton) DOM.editFilenameButton.classList.add(CLASS_NAMES.HIDDEN); if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = true; if (!AppState.selectedTempImageInfo?.filename) { displayToast('é”™è¯¯ï¼šå…ˆé€‰å›¾', CLASS_NAMES.ERROR); if(DOM.finalFilenameInput) DOM.finalFilenameInput.value = 'é”™è¯¯'; return; } try { const url = `${API_ENDPOINTS.LAST_FILE_NUMBER}?folder=${encodeURIComponent(folderName)}`; const data = await fetchJsonData(url); if (data && typeof data.lastNumber === 'number') { const nextNumber = data.lastNumber + 1; AppState.suggestedFilenameNum = nextNumber; AppState.suggestedFilenameBase = folderName + 'Gu'; const match = AppState.selectedTempImageInfo.filename.match(/\.[^.]+$/); AppState.suggestedFilenameExt = match ? match[0] : '.webp'; const finalFilename = `${AppState.suggestedFilenameBase}${nextNumber}${AppState.suggestedFilenameExt}`; if (DOM.finalFilenameInput) DOM.finalFilenameInput.value = finalFilename; if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = false; if (DOM.editFilenameButton) DOM.editFilenameButton.classList.remove(CLASS_NAMES.HIDDEN); console.log(`Import: å»ºè®®æ–‡ä»¶å: ${finalFilename}`); } else { throw new Error(data?.error || 'æ— æ•ˆç¼–å·æ•°æ®'); } } catch (error) { console.error(`Import: è·å–ç¼–å·å¤±è´¥ (${folderName}):`, error); displayToast(`è·å–ç¼–å·å¤±è´¥: ${error.message}`, CLASS_NAMES.ERROR); if (DOM.finalFilenameInput) DOM.finalFilenameInput.value = 'è·å–å¤±è´¥'; if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = true; if (DOM.editFilenameButton) DOM.editFilenameButton.classList.add(CLASS_NAMES.HIDDEN); } }
function enableImportFormSections() { if (DOM.importAttributesPanel) DOM.importAttributesPanel.classList.remove(CLASS_NAMES.HIDDEN, CLASS_NAMES.INITIALLY_HIDDEN); if (DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.disabled = false; const namingSection = DOM.importPaneView?.querySelector('.naming-section'); if (namingSection) namingSection.classList.add(CLASS_NAMES.ACTIVE); console.debug("Import: è¡¨å•åç»­å¯ç”¨ã€‚"); }
function disableImportFormSections() { if (DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.disabled = true; const namingSection = DOM.importPaneView?.querySelector('.naming-section'); if (namingSection) namingSection.classList.remove(CLASS_NAMES.ACTIVE); if (DOM.finalFilenameInput) { DOM.finalFilenameInput.value = ''; DOM.finalFilenameInput.readOnly = true; DOM.finalFilenameInput.classList.remove(CLASS_NAMES.EDITABLE); } if (DOM.editFilenameButton) DOM.editFilenameButton.classList.add(CLASS_NAMES.HIDDEN); if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = true; console.debug("Import: è¡¨å•åç»­ç¦ç”¨ã€‚"); }
async function handleAddToGallery() { if (!AppState.selectedTempImageInfo || !AppState.selectedTargetFolder || !DOM.finalFilenameInput || !DOM.addToGalleryButton || !DOM.importMessageArea) { console.warn("Import: æ·»åŠ æ¡ä»¶æœªæ»¡è¶³ã€‚"); return; } hideImportMessage(); const finalName = DOM.finalFilenameInput.value.trim(); const tempPath = AppState.selectedTempImageInfo.path; const targetFolder = AppState.selectedTargetFolder; if (!finalName) { displayImportMessage("é”™è¯¯ï¼šæ–‡ä»¶åä¸èƒ½ä¸ºç©º", CLASS_NAMES.ERROR); return; } if (/[\\/:"*?<>|]/.test(finalName)) { displayImportMessage("é”™è¯¯ï¼šæ–‡ä»¶åå«éæ³•å­—ç¬¦", CLASS_NAMES.ERROR); return; } const ratingInput = document.querySelector('input[name="importRating"]:checked'); const layoutInput = document.querySelector('input[name="importLayout"]:checked'); const isEasterEgg = DOM.importIsEasterEggCheckbox?.checked ?? false; const isAiImage = DOM.importIsAiImageCheckbox?.checked ?? false; if (!ratingInput || !layoutInput) { displayImportMessage("é”™è¯¯ï¼šæ— æ³•è¯»å–å±æ€§", CLASS_NAMES.ERROR); return; } const rating = ratingInput.value || 'none'; const layout = layoutInput.value || 'normal'; DOM.addToGalleryButton.disabled = true; displayImportMessage("æ·»åŠ ä¸­...", CLASS_NAMES.INFO); const importData = { tempImagePath: tempPath, targetFolder: targetFolder, targetFilename: finalName, attributes: { isPx18: rating === 'px18', isRx18: rating === 'rx18', layout: layout, isEasterEgg: isEasterEgg, isAiImage: isAiImage, isBan: false, Downloaded_From: 'local_import' } }; console.log("Import: å‘é€å…¥åº“è¯·æ±‚:", importData); try { const result = await fetchJsonData(API_ENDPOINTS.IMPORT_IMAGE, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(importData) }); if (result?.success === true && result.newEntry?.path) { console.log("Import: æ·»åŠ æˆåŠŸ:", result.newEntry); displayImportMessage(`æˆåŠŸæ·»åŠ  "${finalName}"ï¼`, CLASS_NAMES.SUCCESS); AppState.savedEntries.push(result.newEntry); AppState.savedImagePaths.add(result.newEntry.path); if (typeof updateEntryCount === "function") updateEntryCount(); const dLPActive = DOM.dataListPane?.classList.contains(CLASS_NAMES.ACTIVE); if (dLPActive && typeof applyFiltersAndRenderDataList === "function") { console.log("Import: åˆ·æ–° DataList..."); applyFiltersAndRenderDataList(); } await fetchTempImages(); resetImportForm(); } else { throw new Error(result?.error || "æ·»åŠ å¤±è´¥ï¼ŒæœåŠ¡å™¨æœªè¿”å›æˆåŠŸ"); } } catch (error) { console.error("Import: æ·»åŠ å¤±è´¥:", error); displayImportMessage(`æ·»åŠ å¤±è´¥: ${error.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); DOM.addToGalleryButton.disabled = false; } }
function resetImportForm() { console.log("Import: é‡ç½®è¡¨å•..."); if (DOM.tempImageSearchInput) DOM.tempImageSearchInput.value = ''; if (DOM.targetFolderSearchInput) DOM.targetFolderSearchInput.value = ''; if (DOM.finalFilenameInput) { DOM.finalFilenameInput.value = ''; DOM.finalFilenameInput.readOnly = true; DOM.finalFilenameInput.classList.remove(CLASS_NAMES.EDITABLE); } if (DOM.tempImagePreview) { DOM.tempImagePreview.onerror = null; DOM.tempImagePreview.src = ''; DOM.tempImagePreview.alt = 'å¾…å…¥åº“å›¾ç‰‡é¢„è§ˆ'; DOM.tempImagePreview.classList.add(CLASS_NAMES.HIDDEN); } AppState.selectedTempImageInfo = null; AppState.selectedTargetFolder = null; AppState.suggestedFilenameBase = ''; AppState.suggestedFilenameNum = 0; AppState.suggestedFilenameExt = ''; const dR = document.querySelector('input[name="importRating"][value="none"]'); const dL = document.querySelector('input[name="importLayout"][value="normal"]'); if (dR) dR.checked = true; if (dL) dL.checked = true; if (DOM.importIsEasterEggCheckbox) DOM.importIsEasterEggCheckbox.checked = false; if (DOM.importIsAiImageCheckbox) DOM.importIsAiImageCheckbox.checked = false; if (typeof disableImportFormSections === "function") disableImportFormSections(); else console.warn("resetImportForm: disableImportFormSections æœªå®šä¹‰!"); if (DOM.editFilenameButton) DOM.editFilenameButton.classList.add(CLASS_NAMES.HIDDEN); if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = true; if (typeof updateImportInputPlaceholders === "function") updateImportInputPlaceholders(); else console.warn("resetImportForm: updateImportInputPlaceholders æœªå®šä¹‰!"); hideImportMessage(); }
function handleTargetFolderInput() { clearTimeout(AppState.targetFolderSearchDebounceTimer); const q = DOM.targetFolderSearchInput.value.toLowerCase().trim(); if (DOM.finalFilenameInput) DOM.finalFilenameInput.value = ''; if (DOM.addToGalleryButton) DOM.addToGalleryButton.disabled = true; if (DOM.editFilenameButton) DOM.editFilenameButton.classList.add(CLASS_NAMES.HIDDEN); AppState.selectedTargetFolder = null; AppState.targetFolderSearchDebounceTimer = setTimeout(() => { if (q && AppState.characterFoldersList.length > 0) { const r = AppState.characterFoldersList.filter(f => f.toLowerCase().includes(q)); showTargetFolderSuggestions(r); } else if (DOM.targetFolderSuggestions) { DOM.targetFolderSuggestions.classList.add(CLASS_NAMES.HIDDEN); } }, DELAYS.IMPORT_SEARCH_DEBOUNCE); }
function handleTargetFolderBlur() { setTimeout(() => { if (DOM.targetFolderSuggestions && !DOM.targetFolderSuggestions.classList.contains(CLASS_NAMES.HIDDEN)) return; const v = DOM.targetFolderSearchInput.value.trim(); if (v && v !== AppState.selectedTargetFolder) { console.log("Import: ç›®æ ‡å¤±ç„¦ï¼Œè‡ªåŠ¨é€‰æ‹©:", v); selectTargetFolder(v); } else if (!v && DOM.targetFolderSuggestions) { DOM.targetFolderSuggestions.classList.add(CLASS_NAMES.HIDDEN); } }, 150); }
function handleTargetFolderKeyDown(event) { if (event.key === 'Enter') { event.preventDefault(); const v = DOM.targetFolderSearchInput.value.trim(); if (v && v !== AppState.selectedTargetFolder) { selectTargetFolder(v); DOM.targetFolderSearchInput.blur(); } } else if (event.key === 'Escape') { if (DOM.targetFolderSuggestions) DOM.targetFolderSuggestions.classList.add(CLASS_NAMES.HIDDEN); } }

// --------------------------------------------------------------------------
// MD5 æ ¡å‡† (MD5 Calibration) åŠŸèƒ½
// --------------------------------------------------------------------------
async function handleStartMD5Calibration() { console.log("[DEBUG] handleStartMD5Calibration è§¦å‘"); const reqMap = { startMD5Calibration: DOM.startMD5Calibration, abortMD5Calibration: DOM.abortMD5Calibration, md5CalibrationStatus: DOM.md5CalibrationStatus, totalFilesChecked: DOM.totalFilesChecked, filesCheckedCount: DOM.filesCheckedCount, totalMD5Count: DOM.totalMD5Count, mismatchedMD5Count: DOM.mismatchedMD5Count, md5CalibrationProgress: DOM.md5CalibrationProgress, md5CalibrationProgressBar: DOM.md5CalibrationProgressBar, jsonMd5ListContainer: DOM.jsonMd5ListContainer, mismatchedMD5List: DOM.mismatchedMD5List, fixAllMismatchedMD5: DOM.fixAllMismatchedMD5, filesNotInJsonCount: DOM.filesNotInJsonCount, filesNotInJsonList: DOM.filesNotInJsonList, mismatchedCountDisplay: DOM.mismatchedCountDisplay, jsonTotalEntriesDisplay: DOM.jsonTotalEntriesDisplay }; const missing = Object.entries(reqMap).filter(([k, v]) => !v).map(([k]) => k); if (missing.length > 0) { console.error(`[DEBUG] MD5: ç¼ºå°‘ DOM: ${missing.join(', ')}`); displayToast("æ— æ³•æ ¡å‡†ï¼šç•Œé¢ç¼ºå¤±", CLASS_NAMES.ERROR); return; } console.log("[DEBUG] MD5: DOM æ£€æŸ¥é€šè¿‡ã€‚"); AppState.isCalibrationRunning = true; AppState.isCalibrationAborted = false; mismatchDataForFixing = []; filesNotInJsonData = []; DOM.startMD5Calibration.disabled = true; DOM.abortMD5Calibration.disabled = false; DOM.abortMD5Calibration.classList.remove('hidden'); DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); DOM.totalFilesChecked.textContent = 'åŠ è½½...'; DOM.filesCheckedCount.textContent = '0'; DOM.totalMD5Count.textContent = Array.isArray(AppState.savedEntries) ? AppState.savedEntries.length.toString() : '0'; DOM.mismatchedMD5Count.textContent = '0'; DOM.mismatchedCountDisplay.textContent = '0'; DOM.mismatchedMD5List.value = ''; DOM.filesNotInJsonCount.textContent = '0'; DOM.filesNotInJsonList.value = ''; DOM.md5CalibrationProgress.textContent = 'è·å–åˆ—è¡¨...'; DOM.md5CalibrationProgressBar.style.display = 'block'; DOM.md5CalibrationProgressBar.value = 0; DOM.jsonMd5ListContainer.querySelectorAll('.json-md5-item.mismatched').forEach(i => i.classList.remove('mismatched')); displayToast("å¼€å§‹æ ¡å‡†...", CLASS_NAMES.INFO, 2000); try { let allPaths = []; console.log("[DEBUG] MD5: è·å–åˆ—è¡¨..."); displayToast("è·å–åˆ—è¡¨...", CLASS_NAMES.INFO, 3000); try { const data = await fetchJsonData(API_ENDPOINTS.LOCAL_IMAGES); if (Array.isArray(data)) { allPaths = data.map(img => img.urlPath).filter(Boolean); console.log(`[DEBUG] MD5: API è·å– ${allPaths.length} è·¯å¾„ã€‚`); } else { console.warn("[DEBUG] MD5: API éæ•°ç»„ï¼Œå°è¯• AppState..."); if (Array.isArray(AppState.allGalleryImages)) { allPaths = AppState.allGalleryImages.map(img => img.urlPath).filter(Boolean); console.log(`[DEBUG] MD5: AppState è·å– ${allPaths.length} è·¯å¾„ã€‚`); } else { throw new Error("æ— æ³•è·å–åˆ—è¡¨"); } } console.log("[DEBUG] MD5: è·¯å¾„(å‰10):", allPaths.slice(0, 10)); if (allPaths.length === 0) throw new Error("åˆ—è¡¨ä¸ºç©º"); } catch (err) { console.error("[DEBUG] MD5: è·å–åˆ—è¡¨å¤±è´¥:", err); displayToast(`è·å–åˆ—è¡¨å¤±è´¥: ${err.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); AppState.isCalibrationRunning = false; DOM.startMD5Calibration.disabled = false; DOM.abortMD5Calibration.disabled = true; DOM.md5CalibrationProgress.textContent = 'é”™è¯¯'; return; } const total = allPaths.length; DOM.totalFilesChecked.textContent = total.toString(); DOM.md5CalibrationProgressBar.max = total; const jsonEntries = AppState.savedEntries || []; const map = new Map(); const jsonSet = new Set(); jsonEntries.forEach(e => { if (e?.path) { jsonSet.add(e.path); if (e.attributes?.md5) map.set(e.path, e.attributes.md5); } }); let mismatch = 0, checked = 0, notInJson = 0; const details = []; DOM.md5CalibrationProgress.textContent = `æ£€æŸ¥ 0 / ${total}...`; console.log("[DEBUG] MD5: è¿›å…¥å¾ªç¯..."); for (const fp of allPaths) { if (AppState.isCalibrationAborted) { console.log("MD5: ä¸­æ­¢ã€‚"); DOM.md5CalibrationProgress.textContent = `ä¸­æ­¢ (${checked}/${total})`; displayToast("æ ¡å‡†ä¸­æ­¢", CLASS_NAMES.WARNING); if (mismatchDataForFixing.length > 0) { DOM.fixAllMismatchedMD5.disabled = false; DOM.fixAllMismatchedMD5.classList.remove('disabled'); } else { DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); } break; } checked++; DOM.filesCheckedCount.textContent = checked.toString(); DOM.md5CalibrationProgress.textContent = `æ£€æŸ¥ ${checked}/${total}: ${fp.split('/').pop()}`; DOM.md5CalibrationProgressBar.value = checked; const expected = map.get(fp); const li = DOM.jsonMd5ListContainer.querySelector(`.json-md5-item[data-path="${CSS.escape(fp)}"]`); if (!jsonSet.has(fp)) { notInJson++; filesNotInJsonData.push(fp); DOM.filesNotInJsonCount.textContent = notInJson.toString(); continue; } if (!expected) { continue; } try { const actual = await fetchImageMd5(fp); if (actual && actual !== expected) { mismatch++; details.push(`æ–‡ä»¶: ${fp}\n JSON: ${expected}\n å®é™…: ${actual}\n`); mismatchDataForFixing.push({ path: fp, expected: expected, actual: actual }); DOM.mismatchedMD5Count.textContent = mismatch.toString(); DOM.mismatchedCountDisplay.textContent = mismatch.toString(); if (li) li.classList.add('mismatched'); } else if (!actual) { mismatch++; details.push(`æ–‡ä»¶: ${fp}\n JSON: ${expected}\n å®é™…: è®¡ç®—å¤±è´¥!\n`); DOM.mismatchedMD5Count.textContent = mismatch.toString(); DOM.mismatchedCountDisplay.textContent = mismatch.toString(); if (li) li.classList.add('mismatched'); } else { if (li) li.classList.remove('mismatched'); } } catch (e) { console.error(`[DEBUG] MD5: å¤„ç† ${fp} å‡ºé”™:`, e); mismatch++; details.push(`æ–‡ä»¶: ${fp}\n å¤„ç†å‡ºé”™: ${e.message}\n`); DOM.mismatchedMD5Count.textContent = mismatch.toString(); DOM.mismatchedCountDisplay.textContent = mismatch.toString(); if (li) li.classList.add('mismatched'); } await new Promise(r => setTimeout(r, 1)); } console.log("[DEBUG] MD5: å¾ªç¯ç»“æŸã€‚"); DOM.mismatchedMD5List.value = details.join('\n'); DOM.filesNotInJsonList.value = filesNotInJsonData.join('\n'); DOM.filesNotInJsonCount.textContent = notInJson.toString(); if (!AppState.isCalibrationAborted) { DOM.md5CalibrationProgress.textContent = `å®Œæˆ ${total} æ–‡ä»¶æ£€æŸ¥ã€‚`; if (mismatch > 0) { displayToast(`æ ¡å‡†å®Œæˆï¼Œ${mismatch} ä¸ä¸€è‡´ã€‚`, CLASS_NAMES.WARNING, DELAYS.TOAST_ERROR_DURATION); DOM.fixAllMismatchedMD5.disabled = false; DOM.fixAllMismatchedMD5.classList.remove('disabled'); } else { displayToast("æ ¡å‡†å®Œæˆï¼Œä¸€è‡´ï¼", CLASS_NAMES.SUCCESS); DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); } } } catch (e) { console.error("[DEBUG] MD5 å¤±è´¥ (å¤–éƒ¨):", e); displayToast(`MD5 å¤±è´¥: ${e.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); DOM.md5CalibrationProgress.textContent = 'å‡ºé”™!'; if (mismatchDataForFixing.length > 0) { DOM.fixAllMismatchedMD5.disabled = false; DOM.fixAllMismatchedMD5.classList.remove('disabled'); } else { DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); } AppState.isCalibrationRunning = false; } finally { console.log("[DEBUG] MD5: finallyã€‚"); AppState.isCalibrationRunning = false; DOM.startMD5Calibration.disabled = false; DOM.abortMD5Calibration.disabled = true; if (mismatchDataForFixing.length > 0) { if (DOM.fixAllMismatchedMD5.disabled) { console.log("[DEBUG] MD5: finally æ£€æŸ¥ï¼Œå¯ç”¨ä¿®å¤ã€‚"); DOM.fixAllMismatchedMD5.disabled = false; DOM.fixAllMismatchedMD5.classList.remove('disabled'); } } else { if (!DOM.fixAllMismatchedMD5.disabled) { console.log("[DEBUG] MD5: finally æ£€æŸ¥ï¼Œç¦ç”¨ä¿®å¤ã€‚"); DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); } } } }
function handleAbortMD5Calibration() { AppState.isCalibrationAborted = true; displayToast("è¯·æ±‚ä¸­æ­¢...", CLASS_NAMES.WARNING); if (DOM.abortMD5Calibration) DOM.abortMD5Calibration.disabled = true; }
async function handleFixAllMismatches() { if (!DOM.fixAllMismatchedMD5 || DOM.fixAllMismatchedMD5.disabled) return; if (mismatchDataForFixing.length === 0) { displayToast("æ— ä¿®å¤é¡¹ã€‚", CLASS_NAMES.INFO); return; } const confirmed = confirm(`æ›´æ–° ${mismatchDataForFixing.length} æ¡ MD5ï¼Ÿ\næ­¤æ“ä½œä¿®æ”¹ ImageData.jsonï¼\n\nç¡®å®šï¼Ÿ`); if (!confirmed) { displayToast("ä¿®å¤å–æ¶ˆã€‚", CLASS_NAMES.INFO); return; } DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); DOM.startMD5Calibration.disabled = true; displayToast("ä¿®å¤ä¸­...", CLASS_NAMES.INFO); let uC = 0, fC = 0; const uE = JSON.parse(JSON.stringify(AppState.savedEntries)); mismatchDataForFixing.forEach(m => { const idx = uE.findIndex(e => e.path === m.path); if (idx > -1) { if (!uE[idx].attributes) uE[idx].attributes = {}; uE[idx].attributes.md5 = m.actual; uE[idx].timestamp = new Date().toISOString(); uC++; console.log(`MD5 ä¿®å¤: å‡†å¤‡ ${m.path}`); } else { fC++; console.warn(`MD5 ä¿®å¤: æœªæ‰¾åˆ° ${m.path}ã€‚`); } }); if (uC === 0) { displayToast("æœªæ‰¾åˆ°å¯æ›´æ–°æ¡ç›®ã€‚", CLASS_NAMES.WARNING); DOM.startMD5Calibration.disabled = false; return; } try { if (typeof updateUserData !== 'function') throw new Error("updateUserData æœªå®šä¹‰ï¼"); const success = await updateUserData(uE, `æˆåŠŸæ›´æ–° ${uC} æ¡ MD5`, 'toast', false); if (success) { displayToast(`æˆåŠŸä¿®å¤ ${uC} ä¸ª MD5ï¼`, CLASS_NAMES.SUCCESS, DELAYS.MESSAGE_CLEAR); DOM.mismatchedMD5List.value = ''; DOM.mismatchedMD5Count.textContent = '0'; DOM.mismatchedCountDisplay.textContent = '0'; mismatchDataForFixing = []; DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); DOM.jsonMd5ListContainer.querySelectorAll('.json-md5-item.mismatched').forEach(i => i.classList.remove('mismatched')); populateJsonMd5List(); displayToast("å»ºè®®é‡æ ¡å‡†ç¡®è®¤ã€‚", CLASS_NAMES.INFO, 4000); } else { console.error("MD5 ä¿®å¤: updateUserData å¤±è´¥ã€‚"); DOM.fixAllMismatchedMD5.disabled = true; DOM.fixAllMismatchedMD5.classList.add('disabled'); } } catch (error) { console.error("MD5 ä¿®å¤: è°ƒç”¨å‡ºé”™:", error); displayToast(`ä¿å­˜æ›´æ–°å‡ºé”™: ${error.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); DOM.fixAllMismatchedMD5.disabled = false; DOM.fixAllMismatchedMD5.classList.remove('disabled'); } finally { DOM.startMD5Calibration.disabled = false; } }

// --------------------------------------------------------------------------
// åºå·ç®¡ç† (Sequence Management) åŠŸèƒ½
// --------------------------------------------------------------------------
async function getFilesForSequenceAnalysis(folderName) { console.log(`[DEBUG] Sequence: è¯·æ±‚ "${folderName}" å†…å®¹...`); /* â˜…â˜…â˜… å®ç°è·å–æ–‡ä»¶åˆ—è¡¨çš„é€»è¾‘ â˜…â˜…â˜… */ try { const url = `${API_ENDPOINTS.FOLDER_CONTENTS}?folder=${encodeURIComponent(folderName)}`; console.log(`[DEBUG] Sequence: Fetching ${url}`); const data = await fetchJsonData(url); if (Array.isArray(data)) { console.log(`[DEBUG] Sequence: è·å– ${folderName} ${data.length} æ–‡ä»¶ã€‚`); return data; } else { console.warn(`[DEBUG] Sequence: ${folderName} API æ ¼å¼é”™è¯¯:`, data); return []; } } catch (error) { console.error(`[DEBUG] Sequence: è·å– ${folderName} å¤±è´¥:`, error); displayToast(`è·å– ${folderName} å¤±è´¥`, CLASS_NAMES.ERROR); throw new Error(`æ— æ³•è·å– ${folderName} åˆ—è¡¨`); } }
async function handleAnalyzeSequences() { if (!DOM.analyzeSequences || !DOM.sequenceAnalysisStatus || !DOM.sequenceIssuesList || !DOM.fixSequenceIssues) { console.error("åºå·ç®¡ç†: ç¼ºå°‘ DOMã€‚"); displayToast("æ— æ³•åˆ†æï¼šç•Œé¢ç¼ºå¤±", CLASS_NAMES.ERROR); return; } if (AppState.isSequenceAnalysisRunning) { displayToast("åˆ†æä¸­...", CLASS_NAMES.INFO); return; } AppState.isSequenceAnalysisRunning = true; sequenceFixPlan = []; DOM.analyzeSequences.disabled = true; DOM.fixSequenceIssues.disabled = true; DOM.fixSequenceIssues.classList.add('disabled'); DOM.sequenceAnalysisStatus.innerHTML = '<p>è·å–åˆ—è¡¨...</p>'; DOM.sequenceIssuesList.value = ''; AppState.sequenceAnalysisResults = []; displayToast("å¼€å§‹åˆ†æ...", CLASS_NAMES.INFO, 2000); try { let cF = AppState.characterFoldersList || []; if (cF.length === 0 && typeof fetchCharacterFolders === 'function') { console.log("[DEBUG] Sequence: åˆ—è¡¨ä¸ºç©ºï¼Œé‡è·å–..."); await fetchCharacterFolders(); cF = AppState.characterFoldersList; if (cF.length === 0) throw new Error("æœªèƒ½è·å–åˆ—è¡¨ã€‚"); } else if (cF.length === 0) { throw new Error("åˆ—è¡¨ä¸ºç©ºä¸”æ— æ³•è·å–ã€‚"); } const tF = cF.length; DOM.sequenceAnalysisStatus.innerHTML = `<p>è·å– ${tF} æ–‡ä»¶å¤¹ï¼Œæ£€æŸ¥ä¸­...</p>`; let iFC = 0; const sID = []; const sR = /Gu(\d+)\.(webp|jpg|jpeg|png|gif)$/i; for (let i = 0; i < cF.length; i++) { const fN = cF[i]; DOM.sequenceAnalysisStatus.innerHTML = `<p>æ£€æŸ¥ (${i + 1}/${tF}): ${fN}</p>`; try { const fIF = await getFilesForSequenceAnalysis(fN); const fS = []; const fM = new Map(); for (const fn of fIF) { const m = fn.match(sR); if (m) { const sN = parseInt(m[1], 10); fS.push({ num: sN, filename: fn }); if (!fM.has(sN)) fM.set(sN, []); fM.get(sN).push(fn); } } if (fS.length > 0) { fS.sort((a, b) => a.num - b.num); let cFI = []; let aGFT = [`--- æ–‡ä»¶åˆ—è¡¨ (${fS.length}) ---`]; fS.forEach(f => aGFT.push(`  ${f.filename}`)); const counts = {}; fS.forEach(s => { counts[s.num] = (counts[s.num] || 0) + 1; }); let needsFixing = false; for (const sNS in counts) { if (counts[sNS] > 1) { const sN = parseInt(sNS); cFI.push(`  - é—®é¢˜: é‡å¤åºå· ${sN} (æ–‡ä»¶: ${fM.get(sN).join(', ')})`); needsFixing = true; } } if (fS[0].num !== 1) { cFI.push(`  - é—®é¢˜: ä¸ä» 1 å¼€å§‹ (æœ€å° ${fS[0].num} - ${fS[0].filename})`); needsFixing = true; } for (let j = 0; j < fS.length - 1; j++) { const cS = fS[j].num; const nS = fS[j + 1].num; if (counts[cS] === 1 && nS !== cS + 1) { cFI.push(`  - é—®é¢˜: ä¸è¿ç»­ï¼Œ${cS} (${fS[j].filename}) åæ˜¯ ${nS} (${fS[j+1].filename})`); needsFixing = true; } } if (cFI.length > 0) { iFC++; sID.push(`æ–‡ä»¶å¤¹: ${fN}`); sID.push(...cFI); sID.push(...aGFT); sID.push(''); if (needsFixing) { const filesToRenamePlan = []; let newSeqNum = 1; const sortedByFilename = [...fS].sort((a, b) => a.filename.localeCompare(b.filename, undefined, { numeric: true, sensitivity: 'base' })); sortedByFilename.forEach(fI => { const extMatch = fI.filename.match(/\.[^.]+$/); const ext = extMatch ? extMatch[0] : '.webp'; const newFn = `${fN}Gu${newSeqNum}${ext}`; if (newFn !== fI.filename) filesToRenamePlan.push({ currentFilename: fI.filename, newFilename: newFn }); newSeqNum++; }); if (filesToRenamePlan.length > 0) { sequenceFixPlan.push({ folderName: fN, filesToRename: filesToRenamePlan }); console.log(`[DEBUG] Sequence: ä¸º "${fN}" ç”Ÿæˆä¿®å¤è®¡åˆ’ (${filesToRenamePlan.length}é¡¹)ã€‚`); } } } } else { console.debug(`[DEBUG] Sequence: "${fN}" æ—  GuX æ–‡ä»¶ã€‚`); } } catch (fE) { sID.push(`æ–‡ä»¶å¤¹: ${fN}`); sID.push(`  - æ£€æŸ¥å‡ºé”™: ${fE.message}`); sID.push(''); iFC++; console.error(`[DEBUG] Sequence: æ£€æŸ¥ ${fN} å‡ºé”™:`, fE); } await new Promise(r => setTimeout(r, 5)); } DOM.sequenceIssuesList.value = sID.join('\n'); DOM.sequenceAnalysisStatus.innerHTML = `<p>å®Œæˆ ${tF} æ–‡ä»¶å¤¹åˆ†æã€‚</p>`; if (iFC > 0 && sequenceFixPlan.length > 0) { displayToast(`åˆ†æå®Œæˆï¼Œ${iFC} æ–‡ä»¶å¤¹æœ‰é—®é¢˜ã€‚`, CLASS_NAMES.WARNING); DOM.fixSequenceIssues.disabled = false; DOM.fixSequenceIssues.classList.remove('disabled'); DOM.fixSequenceIssues.textContent = `ä¸€é”®ä¿®å¤ (${sequenceFixPlan.length}ä¸ªæ–‡ä»¶å¤¹)`; } else if (iFC > 0 && sequenceFixPlan.length === 0) { displayToast(`åˆ†æå®Œæˆï¼Œ${iFC} æ–‡ä»¶å¤¹æœ‰é—®é¢˜ï¼Œä½†æ— æ³•ç”Ÿæˆä¿®å¤è®¡åˆ’ã€‚`, CLASS_NAMES.WARNING); DOM.fixSequenceIssues.textContent = `ä¸€é”®ä¿®å¤`; } else { displayToast("åˆ†æå®Œæˆï¼Œæœªå‘ç°åºå·é—®é¢˜ï¼", CLASS_NAMES.SUCCESS); DOM.fixSequenceIssues.textContent = `ä¸€é”®ä¿®å¤`; } AppState.sequenceAnalysisResults = sID; } catch (e) { console.error("åºå·åˆ†æå¤±è´¥:", e); displayToast(`åˆ†æå¤±è´¥: ${e.message}`, CLASS_NAMES.ERROR); DOM.sequenceAnalysisStatus.innerHTML = '<p>åˆ†æå‡ºé”™!</p>'; } finally { DOM.analyzeSequences.disabled = false; AppState.isSequenceAnalysisRunning = false; } }
async function handleFixSequenceIssues() { if (!DOM.fixSequenceIssues || DOM.fixSequenceIssues.disabled) return; if (sequenceFixPlan.length === 0) { displayToast("æ— ä¿®å¤è®¡åˆ’ã€‚", CLASS_NAMES.INFO); return; } const confirmed = confirm(`è­¦å‘Šï¼šå³å°†å¯¹ ${sequenceFixPlan.length} æ–‡ä»¶å¤¹è¿›è¡Œåºå·ä¿®å¤ã€‚\né«˜é£é™©ä¸”ä¸å¯é€†ï¼è¯·å…ˆå¤‡ä»½ï¼\n\nç¡®å®šï¼Ÿ`); if (!confirmed) { displayToast("ä¿®å¤å–æ¶ˆã€‚", CLASS_NAMES.INFO); return; } DOM.fixSequenceIssues.disabled = true; DOM.fixSequenceIssues.classList.add('disabled'); DOM.analyzeSequences.disabled = true; displayToast("å‘é€ä¿®å¤è¯·æ±‚...", CLASS_NAMES.INFO); DOM.sequenceAnalysisStatus.innerHTML = `<p>ä¿®å¤ ${sequenceFixPlan.length} æ–‡ä»¶å¤¹ä¸­...</p>`; try { const response = await fetchJsonData(API_ENDPOINTS.RENAME_SEQUENCE_FILES, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ fixPlan: sequenceFixPlan }) }); if (response?.success) { displayToast(`ä¿®å¤æˆåŠŸï¼å¤„ç† ${response.processedFolders || '?'} æ–‡ä»¶å¤¹ï¼Œé‡å‘½å ${response.renamedFiles || '?'} æ–‡ä»¶ã€‚`, CLASS_NAMES.SUCCESS, DELAYS.MESSAGE_CLEAR); DOM.sequenceIssuesList.value = ''; sequenceFixPlan = []; AppState.sequenceAnalysisResults = []; DOM.fixSequenceIssues.textContent = `ä¸€é”®ä¿®å¤`; displayToast("å»ºè®®é‡æ‰«æç¡®è®¤ã€‚", CLASS_NAMES.INFO, 4000); } else { throw new Error(response?.error || "åç«¯ä¿®å¤å¤±è´¥ã€‚"); } } catch (error) { console.error("åºå·ä¿®å¤å¤±è´¥:", error); displayToast(`ä¿®å¤å¤±è´¥: ${error.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); DOM.fixSequenceIssues.disabled = false; DOM.fixSequenceIssues.classList.remove('disabled'); } finally { DOM.analyzeSequences.disabled = false; } }

// --------------------------------------------------------------------------
// JSON æ ¡å‡† (JSON Calibration) åŠŸèƒ½ (æ–°å¢)
// --------------------------------------------------------------------------
async function handleJsonCalibration() {
    console.log("[DEBUG] handleJsonCalibration è§¦å‘");
    const reqMap = { startJsonCalibration: DOM.startJsonCalibration, jsonCalibrationStatus: DOM.jsonCalibrationStatus, jsonEntriesCheckedCount: DOM.jsonEntriesCheckedCount, jsonFilesCheckedCount: DOM.jsonFilesCheckedCount, missingFilesCount: DOM.missingFilesCount, jsonCalibrationProgress: DOM.jsonCalibrationProgress, jsonCalibrationProgressBar: DOM.jsonCalibrationProgressBar, missingFilesList: DOM.missingFilesList, missingFilesCountDisplay: DOM.missingFilesCountDisplay, removeMissingEntriesBtn: DOM.removeMissingEntriesBtn };
    const missing = Object.entries(reqMap).filter(([k, v]) => !v).map(([k]) => k);
    if (missing.length > 0) { console.error(`[DEBUG] JSON æ ¡å‡†: ç¼ºå°‘ DOM: ${missing.join(', ')}`); displayToast("æ— æ³•æ ¡å‡†ï¼šç•Œé¢ç¼ºå¤±", CLASS_NAMES.ERROR); return; }
    console.log("[DEBUG] JSON æ ¡å‡†: DOM æ£€æŸ¥é€šè¿‡ã€‚");

    AppState.isJsonCalibrationRunning = true; jsonMissingEntries = []; jsonCalibrationMissingPaths = []; // æ¸…ç©ºç»“æœ
    DOM.startJsonCalibration.disabled = true; DOM.removeMissingEntriesBtn.disabled = true; DOM.removeMissingEntriesBtn.classList.add('disabled');
    DOM.jsonEntriesCheckedCount.textContent = '0'; DOM.jsonFilesCheckedCount.textContent = 'åŠ è½½...'; DOM.missingFilesCount.textContent = '0'; DOM.missingFilesCountDisplay.textContent = '0';
    DOM.missingFilesList.value = ''; DOM.jsonCalibrationProgress.textContent = 'è·å–åˆ—è¡¨...'; DOM.jsonCalibrationProgressBar.style.display = 'block'; DOM.jsonCalibrationProgressBar.value = 0;
    displayToast("å¼€å§‹ JSON æ ¡å‡†...", CLASS_NAMES.INFO, 2000);

    try {
        let actualFilePaths = new Set(); console.log("[DEBUG] JSON æ ¡å‡†: è·å–åˆ—è¡¨..."); displayToast("è·å–åˆ—è¡¨...", CLASS_NAMES.INFO, 3000);
        try {
            const data = await fetchJsonData(API_ENDPOINTS.LOCAL_IMAGES);
            if (Array.isArray(data)) { data.forEach(img => { if(img?.urlPath) actualFilePaths.add(img.urlPath); }); console.log(`[DEBUG] JSON æ ¡å‡†: è·å– ${actualFilePaths.size} å®é™…è·¯å¾„ã€‚`); }
            else { throw new Error("API æœªè¿”å›åˆ—è¡¨"); }
            if (actualFilePaths.size === 0) console.warn("[DEBUG] JSON æ ¡å‡†: å®é™…æ–‡ä»¶åˆ—è¡¨ä¸ºç©ºï¼");
        } catch (err) { console.error("[DEBUG] JSON æ ¡å‡†: è·å–åˆ—è¡¨å¤±è´¥:", err); displayToast(`è·å–åˆ—è¡¨å¤±è´¥: ${err.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); AppState.isJsonCalibrationRunning = false; DOM.startJsonCalibration.disabled = false; DOM.jsonCalibrationProgress.textContent = 'é”™è¯¯'; return; }
        DOM.jsonFilesCheckedCount.textContent = actualFilePaths.size.toString();

        const jsonEntries = AppState.savedEntries || []; const totalJson = jsonEntries.length; DOM.jsonCalibrationProgressBar.max = totalJson;
        let checkedJson = 0, missingCount = 0; const missingDetails = [];
        DOM.jsonCalibrationProgress.textContent = `æ£€æŸ¥ 0 / ${totalJson} JSON è®°å½•...`; console.log("[DEBUG] JSON æ ¡å‡†: è¿›å…¥å¾ªç¯...");

        for (const entry of jsonEntries) {
            // å¯é€‰ï¼šæ·»åŠ ä¸­æ­¢æ£€æŸ¥
            checkedJson++; DOM.jsonEntriesCheckedCount.textContent = checkedJson.toString(); DOM.jsonCalibrationProgress.textContent = `æ£€æŸ¥ JSON ${checkedJson}/${totalJson}: ${entry.path || 'æ— è·¯å¾„'}`; DOM.jsonCalibrationProgressBar.value = checkedJson;
            if (!entry?.path) { console.warn("[DEBUG] JSON æ ¡å‡†: è·³è¿‡æ— è·¯å¾„è®°å½•:", entry); continue; }
            if (!actualFilePaths.has(entry.path)) {
                missingCount++; const fn = entry.attributes?.filename || entry.path.split('/').pop(); const ch = entry.characterName || 'æœªçŸ¥';
                missingDetails.push(`è·¯å¾„: ${entry.path}\n æ–‡ä»¶å: ${fn}\n è§’è‰²: ${ch}\n GID: ${entry.gid || 'N/A'}\n`);
                jsonMissingEntries.push(entry); jsonCalibrationMissingPaths.push(entry.path); // å­˜å‚¨è·¯å¾„ç”¨äºç§»é™¤
                DOM.missingFilesCount.textContent = missingCount.toString(); DOM.missingFilesCountDisplay.textContent = missingCount.toString();
            }
            if (checkedJson % 100 === 0) await new Promise(r => setTimeout(r, 1));
        }
        console.log("[DEBUG] JSON æ ¡å‡†: å¾ªç¯ç»“æŸã€‚");

        DOM.missingFilesList.value = missingDetails.join('\n'); DOM.jsonCalibrationProgress.textContent = `å®Œæˆ ${totalJson} JSON è®°å½•æ£€æŸ¥ã€‚`;
        if (missingCount > 0) { displayToast(`JSON æ ¡å‡†å®Œæˆï¼Œ${missingCount} æ¡è®°å½•æ–‡ä»¶ç¼ºå¤±ã€‚`, CLASS_NAMES.WARNING, DELAYS.TOAST_ERROR_DURATION); DOM.removeMissingEntriesBtn.disabled = false; DOM.removeMissingEntriesBtn.classList.remove('disabled'); }
        else { displayToast("JSON æ ¡å‡†å®Œæˆï¼Œæ–‡ä»¶å®Œæ•´ï¼", CLASS_NAMES.SUCCESS); }
    } catch (e) { console.error("[DEBUG] JSON æ ¡å‡†å¤±è´¥:", e); displayToast(`JSON æ ¡å‡†å¤±è´¥: ${e.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); DOM.jsonCalibrationProgress.textContent = 'å‡ºé”™!'; if (jsonMissingEntries.length > 0) { DOM.removeMissingEntriesBtn.disabled = false; DOM.removeMissingEntriesBtn.classList.remove('disabled'); } }
    finally { console.log("[DEBUG] JSON æ ¡å‡†: finallyã€‚"); AppState.isJsonCalibrationRunning = false; DOM.startJsonCalibration.disabled = false; }
}

async function handleRemoveMissingEntries() {
    if (!DOM.removeMissingEntriesBtn || DOM.removeMissingEntriesBtn.disabled) return;
    if (jsonMissingEntries.length === 0) { displayToast("æ— ç¼ºå¤±è®°å½•ã€‚", CLASS_NAMES.INFO); return; }
    const confirmed = confirm(`è­¦å‘Šï¼šå°†ä» ImageData.json æ°¸ä¹…åˆ é™¤ ${jsonMissingEntries.length} æ¡è®°å½•ï¼\næ­¤æ“ä½œä¸å¯é€†ï¼\n\nç¡®å®šåˆ é™¤ï¼Ÿ`);
    if (!confirmed) { displayToast("ç§»é™¤å–æ¶ˆã€‚", CLASS_NAMES.INFO); return; }
    DOM.removeMissingEntriesBtn.disabled = true; DOM.removeMissingEntriesBtn.classList.add('disabled'); DOM.startJsonCalibration.disabled = true;
    displayToast("ç§»é™¤è®°å½•ä¸­ (å¾…å®ç°)...", CLASS_NAMES.INFO);
    console.error("JSON æ ¡å‡† - ç§»é™¤ç¼ºå¤±æ¡ç›®åŠŸèƒ½å°šæœªå®ç°ï¼"); displayToast("é”™è¯¯ï¼šç§»é™¤ JSON è®°å½•æœªå®ç°ï¼", CLASS_NAMES.ERROR);

    try {
        console.log(`[DEBUG] å‡†å¤‡ç§»é™¤ ${jsonCalibrationMissingPaths.length} æ¡è®°å½•...`);
        const pathsToRemoveSet = new Set(jsonCalibrationMissingPaths);
        // ä» AppState.savedEntries è¿‡æ»¤æ‰éœ€è¦ç§»é™¤çš„æ¡ç›®
        const updatedEntries = AppState.savedEntries.filter(entry => !pathsToRemoveSet.has(entry.path));
        console.log(`[DEBUG] è¿‡æ»¤åå‰©ä½™ ${updatedEntries.length} æ¡è®°å½•ã€‚`);

        // ç¡®ä¿ updateUserData å‡½æ•°å­˜åœ¨
        if (typeof updateUserData !== 'function') throw new Error("updateUserData å‡½æ•°æœªå®šä¹‰ï¼");

        // è°ƒç”¨ updateUserData ä¿å­˜æ›´æ–°åçš„æ•°æ®
        const success = await updateUserData(updatedEntries, `æˆåŠŸç§»é™¤ ${jsonCalibrationMissingPaths.length} æ¡ç¼ºå¤±æ–‡ä»¶è®°å½•`, 'toast', false);

        if (success) {
            displayToast(`æˆåŠŸç§»é™¤ ${jsonCalibrationMissingPaths.length} æ¡è®°å½•ï¼`, CLASS_NAMES.SUCCESS, DELAYS.MESSAGE_CLEAR);
            // æ›´æ–° UI
            DOM.missingFilesList.value = '';
            DOM.missingFilesCount.textContent = '0';
            DOM.missingFilesCountDisplay.textContent = '0';
            jsonMissingEntries = []; // æ¸…ç©ºç¼“å­˜
            jsonCalibrationMissingPaths = [];
            DOM.removeMissingEntriesBtn.disabled = true; // ç¦ç”¨æŒ‰é’®
            DOM.removeMissingEntriesBtn.classList.add('disabled');
            // å¯èƒ½éœ€è¦æ›´æ–°å…¶ä»–åœ°æ–¹çš„è®¡æ•°ï¼Œä¾‹å¦‚ Data List
            if (typeof updateEntryCount === "function") updateEntryCount();
             const dataListPaneActive = DOM.dataListPane?.classList.contains(CLASS_NAMES.ACTIVE);
            if (dataListPaneActive && typeof applyFiltersAndRenderDataList === "function") { applyFiltersAndRenderDataList(); }

        } else {
             console.error("JSON æ ¡å‡†: updateUserData è¿”å›å¤±è´¥ã€‚");
             // Toast åº”è¯¥ç”± updateUserData æ˜¾ç¤º
             DOM.removeMissingEntriesBtn.disabled = false; // å…è®¸é‡è¯•
             DOM.removeMissingEntriesBtn.classList.remove('disabled');
        }
    } catch (error) {
        console.error("JSON æ ¡å‡†: ç§»é™¤è®°å½•æ—¶å‡ºé”™:", error);
        displayToast(`ç§»é™¤è®°å½•å‡ºé”™: ${error.message}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION);
        DOM.removeMissingEntriesBtn.disabled = false; // å…è®¸é‡è¯•
        DOM.removeMissingEntriesBtn.classList.remove('disabled');
    } finally {
        DOM.startJsonCalibration.disabled = false; // æœ€ç»ˆå¯ç”¨å¼€å§‹æŒ‰é’®
    }
    // DOM.startJsonCalibration.disabled = false; // æ“ä½œå®Œæˆåå¯ç”¨å¼€å§‹æŒ‰é’®
}


// --------------------------------------------------------------------------
// Web Worker äº¤äº’ 
// --------------------------------------------------------------------------
function initializeSearchWorker() { if (typeof Worker === 'undefined') { console.warn("Worker: ä¸æ”¯æŒã€‚"); return; } if (!AppState.allGalleryImages?.length) { console.warn("Worker: å›¾åº“æ•°æ®æœªåŠ è½½ã€‚"); return; } if (AppState.backgroundWorker) { console.log("Worker: ç»ˆæ­¢æ—§å®ä¾‹..."); AppState.backgroundWorker.terminate(); AppState.backgroundWorker = null; } try { console.log("Worker: åˆ›å»º..."); AppState.backgroundWorker = new Worker('searchworker.js'); AppState.backgroundWorker.onmessage = handleWorkerMessage; AppState.backgroundWorker.onerror = handleWorkerError; console.log("Worker: å‘é€æ•°æ®..."); AppState.backgroundWorker.postMessage({ type: 'loadData', payload: { availableImages: AppState.allGalleryImages || [], existingPaths: Array.from(AppState.savedImagePaths) } }); if (DOM.searchInput) { DOM.searchInput.disabled = false; DOM.searchInput.placeholder = DOM.searchInput.placeholder.replace("åŠ è½½ä¸­...", `æœç´¢ ${AppState.allGalleryImages.length} å¼ ...`); console.log("Worker: åˆå§‹åŒ–æˆåŠŸã€‚"); } } catch (error) { console.error("Worker: åˆ›å»ºå¤±è´¥:", error); displayToast("åå°æœç´¢åˆå§‹åŒ–å¤±è´¥", CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); AppState.backgroundWorker = null; if (DOM.searchInput) { DOM.searchInput.disabled = true; DOM.searchInput.placeholder = "æœç´¢æ•…éšœ"; } } }
function handleWorkerMessage(event) { if (!event.data?.type) { console.warn("Worker: æ— æ•ˆæ¶ˆæ¯:", event.data); return; } const { type, payload } = event.data; console.debug('[ä¸»] Worker æ¶ˆæ¯:', type, payload ? '(æœ‰ payload)' : ''); switch (type) { case 'searchResults': if (payload?.query === AppState.lastQuerySentToWorker) { console.log(`[ä¸»] æ”¶åˆ°æŸ¥è¯¢ "${payload.query}" ç»“æœ (${payload.results?.length || 0} æ¡)`); showSuggestions(payload.results || [], false); } else { console.debug(`[ä¸»] å¿½ç•¥è¿‡æ—¶ç»“æœ (æŸ¥è¯¢: ${payload?.query}, æœŸæœ›: ${AppState.lastQuerySentToWorker})`); } break; case 'siblingResults': if (payload && Array.isArray(payload.results)) { console.log(`[ä¸»] æ”¶åˆ°ç›¸å…³å›¾ç‰‡ (${payload.results.length} æ¡)`); showSuggestions(payload.results || [], false); } else { console.warn("[ä¸»] ç›¸å…³ç»“æœæ ¼å¼æ— æ•ˆ:", payload); } break; case 'dataLoaded': console.log("Worker: ç¡®è®¤æ•°æ®åŠ è½½ã€‚"); break; case 'error': console.error("Worker: æŠ¥å‘Šé”™è¯¯:", payload?.message, payload?.error); displayToast(`åå°æœç´¢å‡ºé”™: ${payload?.message || 'æœªçŸ¥'}`, CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); if (DOM.searchInput) { DOM.searchInput.disabled = true; DOM.searchInput.placeholder = "æœç´¢æ•…éšœ"; } break; default: console.warn("[ä¸»] æœªçŸ¥ Worker æ¶ˆæ¯:", type, payload); } }
function handleWorkerError(error) { console.error('[ä¸»] Worker ä¸¥é‡é”™è¯¯:', error.message, error.filename, error.lineno, error); displayToast('åå°æœç´¢ä¸¥é‡é”™è¯¯ï¼Œå·²ç¦ç”¨', CLASS_NAMES.ERROR, DELAYS.TOAST_ERROR_DURATION); if (DOM.searchInput) { DOM.searchInput.disabled = true; DOM.searchInput.placeholder = "æœç´¢å·²ç¦ç”¨"; } if (AppState.backgroundWorker) { AppState.backgroundWorker.terminate(); AppState.backgroundWorker = null; } }
function processSearch(query) { AppState.lastQuerySentToWorker = query; if (AppState.backgroundWorker) { console.debug(`Worker: å‘é€æœç´¢: "${query}"`); AppState.backgroundWorker.postMessage({ type: 'search', payload: { query: query } }); } else { console.warn("Worker: ä¸å¯ç”¨ã€‚"); displayToast('åå°æœç´¢ä¸å¯ç”¨', CLASS_NAMES.WARNING); showSuggestions([]); } }
function handleGlobalClick(event) { const target = event.target; if (DOM.suggestionList && !DOM.suggestionList.classList.contains(CLASS_NAMES.HIDDEN)) { const isClickInside = DOM.searchInput === target || DOM.suggestionList.contains(target); if (!isClickInside) { console.debug("å…¨å±€ç‚¹å‡»: Generator å¤–éƒ¨ï¼Œéšè—ã€‚"); DOM.suggestionList.classList.add(CLASS_NAMES.HIDDEN); AppState.showingRelatedImages = false; AppState.isShowingFolderSuggestions = false; } } if (DOM.tempImageSuggestions && !DOM.tempImageSuggestions.classList.contains(CLASS_NAMES.HIDDEN)) { const isClickInside = DOM.tempImageSearchInput === target || DOM.tempImageSuggestions.contains(target); if (!isClickInside) { console.debug("å…¨å±€ç‚¹å‡»: Import å›¾ç‰‡å¤–éƒ¨ï¼Œéšè—ã€‚"); DOM.tempImageSuggestions.classList.add(CLASS_NAMES.HIDDEN); } } if (DOM.targetFolderSuggestions && !DOM.targetFolderSuggestions.classList.contains(CLASS_NAMES.HIDDEN)) { const isClickInside = DOM.targetFolderSearchInput === target || DOM.targetFolderSuggestions.contains(target); if (!isClickInside) { console.debug("å…¨å±€ç‚¹å‡»: Import æ–‡ä»¶å¤¹å¤–éƒ¨ï¼Œéšè—ã€‚"); DOM.targetFolderSuggestions.classList.add(CLASS_NAMES.HIDDEN); } } }
function setupGlobalEventListeners() { document.addEventListener('click', handleGlobalClick); console.log("å…¨å±€äº‹ä»¶: å…¨å±€ç‚¹å‡»ç›‘å¬å™¨è®¾ç½®ã€‚"); }

// --------------------------------------------------------------------------
// äº‹ä»¶ç›‘å¬å™¨è®¾ç½® (åˆå¹¶æ‰€æœ‰ GuTools å†…éƒ¨ç›‘å¬å™¨)
// --------------------------------------------------------------------------
/**
 * è®¾ç½® GuTools é¢æ¿æ‰€æœ‰å†…éƒ¨åŠŸèƒ½çš„äº‹ä»¶ç›‘å¬å™¨ã€‚
 */
function setupGuToolsEventListeners() {
    console.log("[DEBUG] setupGuToolsEventListeners å¼€å§‹æ‰§è¡Œ...");
    // --- Generator ---
    if (DOM.searchInput) { DOM.searchInput.removeEventListener('focus', handleGeneratorSearchFocus); DOM.searchInput.removeEventListener('input', handleGeneratorSearchInput); DOM.searchInput.removeEventListener('click', handleGeneratorSearchFocus); DOM.searchInput.addEventListener('focus', handleGeneratorSearchFocus); DOM.searchInput.addEventListener('input', handleGeneratorSearchInput); DOM.searchInput.addEventListener('click', handleGeneratorSearchFocus); } else { console.error("Generator: searchInput æœªæ‰¾åˆ°ã€‚"); }
    if (DOM.saveButton) { DOM.saveButton.removeEventListener('click', saveEntry); DOM.saveButton.addEventListener('click', saveEntry); } else { console.error("Generator: saveButton æœªæ‰¾åˆ°ã€‚"); }
    const attributeControls = [ ...(DOM.ratingRadios || []), ...(DOM.layoutRadios || []), DOM.isEasterEggCheckbox, DOM.isAiImageCheckbox ]; attributeControls.forEach(c => { if (c) { c.removeEventListener('change', updateSaveButtonState); c.addEventListener('change', updateSaveButtonState); } });
    console.log("Generator: ç›‘å¬å™¨ OKã€‚");

    // --- Import ---
    if (DOM.tempImageSearchInput) { const showTempList = () => { if (AppState.currentGuToolMode !== 'import' || DOM.tempImageSearchInput.disabled || DOM.tempImageSearchInput.readOnly === false) return; if (AppState.tempImagesList?.length > 0) { showTempImageSuggestions(AppState.tempImagesList); } else if (DOM.tempImageSuggestions) { DOM.tempImageSuggestions.classList.add(CLASS_NAMES.HIDDEN); } }; DOM.tempImageSearchInput.removeEventListener('focus', showTempList); DOM.tempImageSearchInput.removeEventListener('click', showTempList); DOM.tempImageSearchInput.addEventListener('focus', showTempList); DOM.tempImageSearchInput.addEventListener('click', showTempList); } else { console.error("Import: tempImageSearchInput æœªæ‰¾åˆ°ã€‚"); }
    if (DOM.targetFolderSearchInput) { DOM.targetFolderSearchInput.removeEventListener('input', handleTargetFolderInput); DOM.targetFolderSearchInput.removeEventListener('blur', handleTargetFolderBlur); DOM.targetFolderSearchInput.removeEventListener('keydown', handleTargetFolderKeyDown); DOM.targetFolderSearchInput.addEventListener('input', handleTargetFolderInput); DOM.targetFolderSearchInput.addEventListener('blur', handleTargetFolderBlur); DOM.targetFolderSearchInput.addEventListener('keydown', handleTargetFolderKeyDown); } else { console.error("Import: targetFolderSearchInput æœªæ‰¾åˆ°ã€‚"); }
    if (DOM.editFilenameButton && DOM.finalFilenameInput) { const hEC = () => { DOM.finalFilenameInput.readOnly = false; DOM.finalFilenameInput.classList.add(CLASS_NAMES.EDITABLE); DOM.finalFilenameInput.focus(); DOM.finalFilenameInput.setSelectionRange(DOM.finalFilenameInput.value.length, DOM.finalFilenameInput.value.length); }; const hFB = () => { if (DOM.finalFilenameInput.classList.contains(CLASS_NAMES.EDITABLE)) { DOM.finalFilenameInput.readOnly = true; DOM.finalFilenameInput.classList.remove(CLASS_NAMES.EDITABLE); } }; const hFK = (e) => { if (DOM.finalFilenameInput.classList.contains(CLASS_NAMES.EDITABLE)) { if (e.key === 'Enter') { e.preventDefault(); DOM.finalFilenameInput.readOnly = true; DOM.finalFilenameInput.classList.remove(CLASS_NAMES.EDITABLE); DOM.finalFilenameInput.blur(); } else if (e.key === 'Escape') { const sF = `${AppState.suggestedFilenameBase}${AppState.suggestedFilenameNum}${AppState.suggestedFilenameExt}`; DOM.finalFilenameInput.value = sF; DOM.finalFilenameInput.readOnly = true; DOM.finalFilenameInput.classList.remove(CLASS_NAMES.EDITABLE); DOM.finalFilenameInput.blur(); } } }; DOM.editFilenameButton.removeEventListener('click', hEC); DOM.finalFilenameInput.removeEventListener('blur', hFB); DOM.finalFilenameInput.removeEventListener('keydown', hFK); DOM.editFilenameButton.addEventListener('click', hEC); DOM.finalFilenameInput.addEventListener('blur', hFB); DOM.finalFilenameInput.addEventListener('keydown', hFK); } else { console.error("Import: finalFilenameInput æˆ– editFilenameButton æœªæ‰¾åˆ°ã€‚"); }
    if (DOM.addToGalleryButton) { DOM.addToGalleryButton.removeEventListener('click', handleAddToGallery); DOM.addToGalleryButton.addEventListener('click', handleAddToGallery); } else { console.error("Import: addToGalleryButton æœªæ‰¾åˆ°ã€‚"); }
    console.log("Import: ç›‘å¬å™¨ OKã€‚");

    // --- MD5 æ ¡å‡† ---
    if (DOM.startMD5Calibration) { DOM.startMD5Calibration.removeEventListener('click', handleStartMD5Calibration); DOM.startMD5Calibration.addEventListener('click', handleStartMD5Calibration); } else { console.error("MD5 æ ¡å‡†: startMD5Calibration æœªæ‰¾åˆ°ï¼"); }
    if (DOM.abortMD5Calibration) { DOM.abortMD5Calibration.removeEventListener('click', handleAbortMD5Calibration); DOM.abortMD5Calibration.addEventListener('click', handleAbortMD5Calibration); } else { console.error("MD5 æ ¡å‡†: abortMD5Calibration æœªæ‰¾åˆ°ã€‚"); }
    if (DOM.fixAllMismatchedMD5) { DOM.fixAllMismatchedMD5.removeEventListener('click', handleFixAllMismatches); DOM.fixAllMismatchedMD5.addEventListener('click', handleFixAllMismatches); } else { console.error("MD5 æ ¡å‡†: fixAllMismatchedMD5 æœªæ‰¾åˆ°ã€‚"); }
    console.log("MD5 æ ¡å‡†: ç›‘å¬å™¨ OKã€‚");

    // --- åºå·ç®¡ç† ---
    if (DOM.analyzeSequences) { DOM.analyzeSequences.removeEventListener('click', handleAnalyzeSequences); DOM.analyzeSequences.addEventListener('click', handleAnalyzeSequences); } else { console.error("åºå·ç®¡ç†: analyzeSequences æœªæ‰¾åˆ°ã€‚"); }
    if (DOM.fixSequenceIssues) { DOM.fixSequenceIssues.removeEventListener('click', handleFixSequenceIssues); DOM.fixSequenceIssues.addEventListener('click', handleFixSequenceIssues); } else { console.error("åºå·ç®¡ç†: fixSequenceIssues æœªæ‰¾åˆ°ã€‚"); }
    console.log("åºå·ç®¡ç†: ç›‘å¬å™¨ OKã€‚");

    // --- JSON æ ¡å‡† (æ–°å¢) ---
    if (DOM.startJsonCalibration) { DOM.startJsonCalibration.removeEventListener('click', handleJsonCalibration); DOM.startJsonCalibration.addEventListener('click', handleJsonCalibration); } else { console.error("JSON æ ¡å‡†: startJsonCalibration æœªæ‰¾åˆ°ï¼"); }
    if (DOM.removeMissingEntriesBtn) { DOM.removeMissingEntriesBtn.removeEventListener('click', handleRemoveMissingEntries); DOM.removeMissingEntriesBtn.addEventListener('click', handleRemoveMissingEntries); } else { console.error("JSON æ ¡å‡†: removeMissingEntriesBtn æœªæ‰¾åˆ°ï¼"); }
    console.log("JSON æ ¡å‡†: ç›‘å¬å™¨ OKã€‚");

    console.log("GuTools æ‰€æœ‰å†…éƒ¨äº‹ä»¶ç›‘å¬å™¨è®¾ç½®å®Œæˆã€‚");
}

// ä¾èµ–å‡½æ•°éœ€åœ¨å…¶ä»–æ–‡ä»¶å®šä¹‰æˆ–åœ¨æ­¤æ–‡ä»¶å†…å®ç°ã€‚