import fs from "node:fs";
import fsPromises from "node:fs/promises";
import path from "node:path";
import { spawn } from "node:child_process";
import { fileURLToPath, URL } from "node:url";
import os from "node:os";
import yaml from "yaml";
import crypto from 'node:crypto';
import template from "art-template";
import common from "../../lib/common/common.js";
import puppeteer from "../../lib/puppeteer/puppeteer.js";

/**
 * @description ÂíïÂíïÁâõÂõæÂ∫ìÁÆ°ÁêÜÂô®
 * @version 4.9.0
 * @based v4.8.4 & v4.8.8 & v4.8.9
 * @description_details
 *    - ÊîØÊåÅÂ§ö‰ªìÂ∫ìÂ≠òÂÇ®‰∏éÁÆ°ÁêÜ„ÄÇ
 *    - Êèê‰æõ Ai Âõæ„ÄÅÂΩ©ËõãÂõæ„ÄÅÊ®™Â±èÂõæÁöÑÂÖ®Â±ÄÂºÄÂÖ≥„ÄÇ
 *    - ‰øÆÂ§ç‰∫ÜÂ§ö‰∏™ÂëΩ‰ª§ÊâßË°åÊµÅÁ®ã‰∏éÊà™ÂõæÊ∏≤ÊüìÈóÆÈ¢ò„ÄÇ
 *    - ‰ºòÂåñ‰∫ÜÈÖçÁΩÆÂä†ËΩΩ‰∏é‰øùÂ≠òÈÄªËæëÔºåÂ¢ûÂº∫‰∫ÜÂπ∂ÂèëÂ§ÑÁêÜËÉΩÂäõ„ÄÇ
 *    - Áªü‰∏Ä‰∫ÜËÆæÁΩÆÁ±ªÂëΩ‰ª§ÁöÑ‰∫§‰∫íÊñπÂºè„ÄÇ
 *    - ‰ºòÂåñ‰∫ÜÂõæÁâá‰∏ãËΩΩÈÄªËæëÔºåÊèêÈ´ò‰∫Ü‰∏ãËΩΩÈÄüÂ∫¶‰∏éÁ®≥ÂÆöÊÄß„ÄÇ
 *    - ‰øÆÂ§ç‰∫ÜÈÉ®ÂàÜÂëΩ‰ª§ÊâßË°åÈÄªËæëÈóÆÈ¢ò„ÄÇ
 *    - Â¢ûÂä†ÁâπÊÆäÂõæÁâáÁöÑÂ§ÑÁêÜ„ÄÇ
 */

// --- ÂÖ®Â±ÄÂ∏∏Èáè‰∏éÈÖçÁΩÆ ---
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const YunzaiPath = path.resolve(__dirname, "..", "..");

/**
 * @description ÂáÄÂåñÁ≠âÁ∫ßÂ∏∏ÈáèÂÆö‰πâ
 */
const Purify_Level = {
  NONE: 0,
  RX18_ONLY: 1,
  PX18_PLUS: 2,
  getDescription: (level) =>
    ({ 0: "‰∏çËøáÊª§", 1: "ËøáÊª§R18", 2: "ËøáÊª§R18ÂèäP18" }[level] ?? "Êú™Áü•"),
};

/** @description Raw URL ÊµãÈÄüÂü∫ÂáÜ */
const RAW_URL_Repo1 =
  "https://raw.githubusercontent.com/GuGuNiu/Miao-Plugin-MBT/main";

/**
 * @description ÈªòËÆ§ÈÖçÁΩÆÈ°π
 */
const Default_Config = {
  Main_Github_URL: "https://github.com/GuGuNiu/Miao-Plugin-MBT/",
  Ass_Github_URL: "https://github.com/GuGuNiu/Miao-Plugin-MBT-2/",
  Sexy_Github_URL: "https://github.com/GuGuNiu/Miao-Plugin-MBT-3/",

  SepositoryBranch: "main",
  proxies: [
    {
      name: "Moeyy",
      priority: 0,
      testUrlPrefix: `https://github.moeyy.xyz/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://github.moeyy.xyz/",
    },
    {
      name: "Ghfast",
      priority: 10,
      testUrlPrefix: `https://ghfast.top/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://ghfast.top/",
    },
    {
      name: "Ghp",
      priority: 20,
      testUrlPrefix: `https://ghp.ci/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://ghp.ci/",
    },
    {
      name: "Ghgo",
      priority: 20,
      testUrlPrefix: `https://ghgo.xyz/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://ghgo.xyz/",
    },
    {
      name: "Yumenaka",
      priority: 30,
      testUrlPrefix: `https://git.yumenaka.net/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://git.yumenaka.net/",
    },
    {
      name: "GhConSh",
      priority: 35,
      testUrlPrefix: `https://gh.con.sh/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://gh.con.sh/",
    },
    {
      name: "GhpsCc",
      priority: 45,
      testUrlPrefix: `https://ghps.cc/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://ghps.cc/",
    },
    {
      name: "GhproxyCom",
      priority: 50,
      testUrlPrefix: `https://ghproxy.com/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://ghproxy.com/",
    },
    {
      name: "GhproxyNet",
      priority: 50,
      testUrlPrefix: `https://ghproxy.net/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://ghproxy.net/",
    },
    {
      name: "GhddlcTop",
      priority: 55,
      testUrlPrefix: `https://gh.ddlc.top/${RAW_URL_Repo1}`,
      cloneUrlPrefix: "https://gh.ddlc.top/",
    },
    {
      name: "GitClone",
      priority: 70,
      testUrlPrefix: null,
      cloneUrlPrefix: "https://gitclone.com/",
    },
    {
      name: "Mirror",
      priority: 80,
      testUrlPrefix: `https://raw.gitmirror.com/GuGuNiu/Miao-Plugin-MBT/main`,
      cloneUrlPrefix: "https://hub.gitmirror.com/",
    },
    {
      name: "GitHub",
      priority: 300,
      testUrlPrefix: RAW_URL_Repo1,
      cloneUrlPrefix: "https://github.com/",
    },
  ],
  proxyTestFile: "/README.md",
  proxyTestTimeout: 5000,
  gitCloneTimeout: 600000,
  gitPullTimeout: 120000,
  gitCloneDepth: 1,
  cronUpdate: "0 5 */3 * *",
  defaultTuKuOp: true,
  defaultPfl: Purify_Level.NONE,
  logPrefix: "„ÄéÂíïÂíïÁâõüêÇ„Äè",
  gitLogFormat: "%cd [%h] %s",
  gitLogDateFormat: "format:%m-%d %H:%M",
  renderScale: 300,
};

/**
 * @description Node.js Êñá‰ª∂Á≥ªÁªüÈîôËØØ‰ª£Á†ÅÂ∏∏Èáè
 */
const ERROR_CODES = {
  NotFound: "ENOENT",
  Access: "EACCES",
  Busy: "EBUSY",
  Perm: "EPERM",
  NotEmpty: "ENOTEMPTY",
  ConnReset: "ECONNRESET",
  Timeout: "ETIMEDOUT",
  Exist: "EEXIST",
};

// ========================================================================= //
// ========================= ÂÖ¨ÂÖ±Â∑•ÂÖ∑ÂáΩÊï∞Âå∫Âüü =============================== //
// ========================================================================= //
/**
 * @description ÂÆâÂÖ®Âú∞ÈÄíÂΩíÂà†Èô§Êñá‰ª∂ÊàñÁõÆÂΩïÔºåÂ∏¶ÈáçËØïÈÄªËæë„ÄÇ
 */
async function safeDelete(targetPath, maxAttempts = 3, delay = 1000) {
  let attempts = 0;
  const logger = global.logger || console;
  while (attempts < maxAttempts) {
    try {
      await fsPromises.rm(targetPath, { recursive: true, force: true });
      return true;
    } catch (err) {
      if (err.code === ERROR_CODES.NotFound) return true;
      if (
        [ERROR_CODES.Busy, ERROR_CODES.Perm, ERROR_CODES.NotEmpty].includes(
          err.code
        )
      ) {
        attempts++;
        if (attempts >= maxAttempts) {
          logger.error(
            `${Default_Config.logPrefix} [ÂÆâÂÖ®Âà†Èô§] ${targetPath} ÊúÄÁªàÂ§±Ë¥• (${attempts}Ê¨°): ${err.code}`
          );
          throw err;
        }
        logger.warn(
          `${
            Default_Config.logPrefix
          } [ÂÆâÂÖ®Âà†Èô§] ${targetPath} Â§±Ë¥• (${attempts}/${maxAttempts}): ${
            err.code
          }, ${delay / 1000}s ÂêéÈáçËØï...`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
      } else {
        logger.error(
          `${Default_Config.logPrefix} [ÂÆâÂÖ®Âà†Èô§] ${targetPath} ÈÅáÂà∞Êú™Â§ÑÁêÜÂºÇÂ∏∏:`,
          err
        );
        throw err;
      }
    }
  }
  return false;
}

/**
 * @description ÈÄöÁî®ÁöÑÈÄíÂΩíÂ§çÂà∂Êñá‰ª∂Â§πÂáΩÊï∞ÔºåÊåâÊâ©Â±ïÂêçËøáÊª§„ÄÇ
 */
async function copyFolderRecursive(
  source,
  target,
  options = {},
  logger = global.logger || console
) {
  const { ignoreSet = new Set(), filterExtension = null } = options;
  const normalizedFilterExt = filterExtension
    ? filterExtension.toLowerCase()
    : null;

  try {
    await fsPromises.access(source);
  } catch (err) {
    if (err.code === ERROR_CODES.NotFound) return;
    logger.error(
      `${Default_Config.logPrefix} [ÈÄíÂΩíÂ§çÂà∂] Ê∫êËÆøÈóÆÂ§±Ë¥• ${source}:`,
      err
    );
    throw err;
  }

  try {
    await fsPromises.mkdir(target, { recursive: true });
    const entries = await fsPromises.readdir(source, { withFileTypes: true });
    await Promise.all(
      entries.map(async (entry) => {
        if (ignoreSet.has(entry.name) || entry.name === ".git") return;

        const currentSource = path.join(source, entry.name);
        const currentTarget = path.join(target, entry.name);

        try {
          if (entry.isDirectory()) {
            await copyFolderRecursive(
              currentSource,
              currentTarget,
              options,
              logger
            );
          } else if (entry.isFile()) {
            const shouldCopy =
              !normalizedFilterExt ||
              entry.name.toLowerCase().endsWith(normalizedFilterExt);
            if (shouldCopy) {
              try {
                await fsPromises.copyFile(
                  currentSource,
                  currentTarget,
                  fs.constants.COPYFILE_FICLONE
                );
              } catch (cloneError) {
                if (
                  cloneError.code === "ENOSYS" ||
                  cloneError.code === "EXDEV"
                ) {
                  await fsPromises.copyFile(currentSource, currentTarget);
                } else {
                  throw cloneError;
                }
              }
            }
          }
        } catch (itemError) {
          if (
            ![ERROR_CODES.NotFound, ERROR_CODES.Access].includes(itemError.code)
          ) {
            logger.warn(
              `${Default_Config.logPrefix} [ÈÄíÂΩíÂ§çÂà∂] Â§ÑÁêÜ ${entry.name} Âá∫Èîô:`,
              itemError.code
            );
          }
        }
      })
    );
  } catch (error) {
    if (
      ![ERROR_CODES.Exist, ERROR_CODES.Access, ERROR_CODES.Perm].includes(
        error.code
      )
    ) {
      logger.error(
        `${Default_Config.logPrefix} [ÈÄíÂΩíÂ§çÂà∂] Êìç‰ΩúÂ§±Ë¥• ${source} -> ${target}:`,
        error
      );
    } else if (error.code !== ERROR_CODES.Exist) {
      logger.warn(
        `${Default_Config.logPrefix} [ÈÄíÂΩíÂ§çÂà∂] Êìç‰ΩúË≠¶Âëä ${source} -> ${target}:`,
        error.code
      );
    }
  }
}

/**
 * @description ÊâßË°åÂ§ñÈÉ®ÂëΩ‰ª§ÔºåÂ§ÑÁêÜÊµÅÔºåÊîØÊåÅË∂ÖÊó∂Âíå‰ø°Âè∑ÁªàÊ≠¢„ÄÇ
 */
function ExecuteCommand(
  command,
  args,
  options = {},
  timeout = 0,
  onStdErr,
  onStdOut
) {
  return new Promise((resolve, reject) => {
    const logger = global.logger || console;
    const isClone = command === "git" && args.includes("clone");
    if (isClone && !args.includes("--verbose")) {
      const cloneIndex = args.indexOf("clone");
      args.splice(cloneIndex + 1, 0, "--verbose");
    }
    const cmdStr = `${command} ${args.join(" ")}`;
    const cwd = options.cwd || process.cwd();
    logger.debug(
      `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] > ${cmdStr} (CWD: ${cwd})`
    );

    const gitDebugEnv = {
      GIT_CURL_VERBOSE: "1",
      GIT_TRACE: "1",
      GIT_PROGRESS_DELAY: "0",
    };
    options.env = { ...process.env, ...(options.env || {}), ...gitDebugEnv };

    let proc;
    try {
      proc = spawn(command, args, { stdio: "pipe", ...options, shell: false });
    } catch (spawnError) {
      logger.error(
        `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] ÂêØÂä®Â§±Ë¥• [${cmdStr}]:`,
        spawnError
      );
      return reject(spawnError);
    }

    let stdout = "";
    let stderr = "";
    let timer = null;
    let killed = false;
    let exited = false;
    let promiseSettled = false;
    let lastStderrChunk = "";

    const settlePromise = (resolver, value) => {
      if (promiseSettled) return;
      promiseSettled = true;
      clearTimeout(timer);
      resolver(value);
    };

    const killProc = (signal = "SIGTERM") => {
      if (proc && proc.pid && !killed && !exited && !proc.killed) {
        logger.warn(
          `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] ÂèëÈÄÅ ${signal} Âà∞ ${proc.pid} (${cmdStr})`
        );
        try {
          if (process.platform !== "win32") {
            process.kill(-proc.pid, signal);
          } else {
            process.kill(proc.pid, signal);
          }
          if (signal === "SIGKILL") killed = true;
        } catch (killError) {
          if (killError.code !== "ESRCH") {
            logger.error(
              `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] kill ${proc.pid} (ÊàñËøõÁ®ãÁªÑ) Â§±Ë¥•:`,
              killError
            );
          } else {
            logger.warn(
              `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] kill ${proc.pid} Êó∂ËøõÁ®ãÂ∑≤‰∏çÂ≠òÂú® (ESRCH)`
            );
          }
          killed = true;
        }
      }
    };

    if (timeout > 0) {
      timer = setTimeout(() => {
        if (exited || promiseSettled) return;
        killed = true;
        logger.warn(
          `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] ÂëΩ‰ª§ [${cmdStr}] Ë∂ÖÊó∂ (${timeout}ms)ÔºåÁªàÊ≠¢...`
        );
        killProc("SIGTERM");
        setTimeout(() => {
          if (!exited && !promiseSettled) {
            logger.warn(
              `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] SIGTERM ÂêéËøõÁ®ãÊú™ÈÄÄÂá∫ÔºåÂèëÈÄÅ SIGKILL...`
            );
            killProc("SIGKILL");
          }
        }, 3000);

        const err = new Error(
          `Command timed out after ${timeout}ms: ${cmdStr}`
        );
        err.code = ERROR_CODES.Timeout;
        err.stdout = stdout;
        err.stderr =
          stderr + `\n[Last Stderr Chunk Before Timeout]:\n${lastStderrChunk}`;
        settlePromise(reject, err);
      }, timeout);
    }

    const handleOutput = (streamName, data, callback) => {
      if (exited || killed || promiseSettled) return;
      const output = data.toString();
      if (streamName === "stdout") {
        stdout += output;
      } else {
        stderr += output;
        lastStderrChunk = output;
      }

      if (callback) {
        try {
          callback(output);
        } catch (e) {
          logger.warn(`${Default_Config.logPrefix} ${streamName} ÂõûË∞ÉÂá∫Èîô:`, e);
        }
      }
    };

    proc.stdout?.on("data", (data) => handleOutput("stdout", data, onStdOut));
    proc.stderr?.on("data", (data) => handleOutput("stderr", data, onStdErr));

    proc.on("error", (err) => {
      if (promiseSettled) return;
      exited = true;
      logger.error(
        `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] ËøõÁ®ãÈîôËØØ [${cmdStr}]:`,
        err
      );
      clearTimeout(timer);
      settlePromise(reject, err);
    });

    proc.on("close", (code, signal) => {
      if (exited || promiseSettled) return;
      exited = true;
      logger.info(
        `${Default_Config.logPrefix} [ÊâßË°åÂëΩ‰ª§] ËøõÁ®ãÂÖ≥Èó≠ [${cmdStr}] Code: ${code}, Signal: ${signal}`
      );
      clearTimeout(timer);

      if (code === 0) {
        settlePromise(resolve, { code: 0, signal, stdout, stderr });
      } else {
        const err = new Error(`Command failed with code ${code}: ${cmdStr}`);
        err.code = code ?? "UNKNOWN";
        err.signal = signal;
        err.stdout = stdout;
        err.stderr = stderr;
        settlePromise(reject, err);
      }
    });
  });
}

/**
 * @description ËÆ°ÁÆóÊñá‰ª∂Â§πÂ§ßÂ∞è
 */
async function FolderSize(folderPath) {
  let totalSize = 0;
  const logger = global.logger || console;
  const queue = [folderPath];
  const visitedDirs = new Set();

  while (queue.length > 0) {
    const currentPath = queue.shift();
    if (visitedDirs.has(currentPath)) continue;
    visitedDirs.add(currentPath);

    try {
      const entries = await fsPromises.readdir(currentPath, {
        withFileTypes: true,
      });
      for (const entry of entries) {
        const entryPath = path.join(currentPath, entry.name);
        try {
          if (entry.isDirectory()) {
            queue.push(entryPath);
          } else if (entry.isFile()) {
            const stats = await fsPromises.stat(entryPath);
            totalSize += stats.size;
          }
        } catch (statError) {
          if (
            ![ERROR_CODES.NotFound, ERROR_CODES.Access].includes(statError.code)
          ) {
          }
        }
      }
    } catch (readDirError) {
      if (
        ![ERROR_CODES.NotFound, ERROR_CODES.Access].includes(readDirError.code)
      ) {
      }
    }
  }
  return totalSize;
}

/**
 * @description Ê†ºÂºèÂåñÂ≠óËäÇÂ§ßÂ∞è
 */
function FormatBytes(bytes, decimals = 1) {
  if (!Number.isFinite(bytes) || bytes < 0) return "? B";
  if (bytes === 0) return "0 B";
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ["B", "KB", "MB", "GB", "TB"];
  let i = Math.floor(Math.log(bytes) / Math.log(k));
  if (i >= sizes.length) i = sizes.length - 1;
  const formattedValue =
    i === 0 ? bytes : parseFloat((bytes / Math.pow(k, i)).toFixed(dm));
  return `${formattedValue} ${sizes[i]}`;
}

/**
 * @description ÂéüÁîüÂºÇÊ≠•‰∫íÊñ•ÈîÅÔºåÁ°Æ‰øùËµÑÊ∫êËÆøÈóÆÁöÑÂéüÂ≠êÊÄß„ÄÇüîí
 */
class SimpleAsyncMutex {
  _locked = false;
  _waitQueue = [];

  acquire() {
    return new Promise((resolve) => {
      if (!this._locked) {
        this._locked = true;
        resolve();
      } else {
        this._waitQueue.push(resolve);
      }
    });
  }

  release() {
    if (this._waitQueue.length > 0) {
      const nextResolve = this._waitQueue.shift();
      nextResolve();
    } else {
      this._locked = false;
    }
  }
}

// ================================================================= //
// ======================= ÂÖ¨ÂÖ±ÂáΩÊï∞Âå∫ÂüüÁªìÊùü ========================== //
// ================================================================= //

export class MiaoPluginMBT extends plugin {
  // --- ÈùôÊÄÅÂ±ûÊÄß ---
  static initializationPromise = null;
  static isGloballyInitialized = false;
  static MBTConfig = {};
  static _imgDataCache = Object.freeze([]);
  static _userBanSet = new Set();
  static _activeBanSet = new Set();
  static _aliasData = null;
  static _backgroundImages = [];
  static oldFileDeletionScheduled = false;
  static isInitializing = false;

  // --- ÂÆû‰æãÂåñÈîÅ ---
  static configMutex = new SimpleAsyncMutex();
  static banMutex = new SimpleAsyncMutex(); // ÁßªÈô§ banMutex
  static gitMutex = new SimpleAsyncMutex();

  /**
   * @description Â≠òÂÇ®ÊâÄÊúâÈáçË¶ÅÁöÑË∑ØÂæÑÂ∏∏Èáè
   **/
  static paths = {
    YunzaiPath: YunzaiPath,
    LocalTuKuPath: path.join(YunzaiPath, "resources", "Miao-Plugin-MBT"),
    gitFolderPath: path.join(
      YunzaiPath,
      "resources",
      "Miao-Plugin-MBT",
      ".git"
    ),
    LocalTuKuPath2: path.join(YunzaiPath, "resources", "Miao-Plugin-MBT-2"),
    gitFolderPath2: path.join(
      YunzaiPath,
      "resources",
      "Miao-Plugin-MBT-2",
      ".git"
    ),
    LocalTuKuPath3: path.join(YunzaiPath, "resources", "Miao-Plugin-MBT-3"),
    gitFolderPath3: path.join(
      YunzaiPath,
      "resources",
      "Miao-Plugin-MBT-3",
      ".git"
    ),
    commonResPath: path.join(YunzaiPath, "resources", "GuGuNiu-Gallery"),
    configFilePath: path.join(
      YunzaiPath,
      "resources",
      "GuGuNiu-Gallery",
      "GalleryConfig.yaml"
    ),
    imageDataPath: path.join(
      YunzaiPath,
      "resources",
      "GuGuNiu-Gallery",
      "imagedata.json"
    ),
    banListPath: path.join(
      YunzaiPath,
      "resources",
      "GuGuNiu-Gallery",
      "banlist.json"
    ),
    helpImagePath: path.join(
      YunzaiPath,
      "resources",
      "GuGuNiu-Gallery",
      "help.webp"
    ),
    tempPath: path.join(YunzaiPath, "temp", "html", "guguniu"),
    tempHtmlPath: path.join(YunzaiPath, "temp", "html", "guguniu"),
    tempImgPath: path.join(YunzaiPath, "temp", "html", "guguniu", "img"),
    backgroundImgPath: path.join(
      YunzaiPath,
      "resources",
      "GuGuNiu-Gallery",
      "html",
      "img"
    ),
    target: {
      miaoChar: path.join(
        YunzaiPath,
        "plugins",
        "miao-plugin",
        "resources",
        "profile",
        "normal-character"
      ),
      zzzChar: path.join(
        YunzaiPath,
        "plugins",
        "ZZZ-Plugin",
        "resources",
        "images",
        "panel"
      ),
      wavesChar: path.join(
        YunzaiPath,
        "plugins",
        "waves-plugin",
        "resources",
        "rolePic"
      ),
      exampleJs: path.join(YunzaiPath, "plugins", "example"),
      miaoGsAliasDir: path.join(
        YunzaiPath,
        "plugins",
        "miao-plugin",
        "resources",
        "meta-gs",
        "character"
      ),
      miaoSrAliasDir: path.join(
        YunzaiPath,
        "plugins",
        "miao-plugin",
        "resources",
        "meta-sr",
        "character"
      ),
      zzzAliasDir: path.join(YunzaiPath, "plugins", "ZZZ-Plugin", "defset"),
      wavesAliasDir: path.join(
        YunzaiPath,
        "plugins",
        "waves-plugin",
        "resources",
        "Alias"
      ),
    },
    sourceFolders: {
      gs: "gs-character",
      sr: "sr-character",
      zzz: "zzz-character",
      waves: "waves-character",
      gallery: "GuGuNiu-Gallery",
    },
    filesToSyncToCommonRes: [
      { sourceSubPath: "GuGuNiu-Gallery/help.webp", destFileName: "help.webp" },
      {
        sourceSubPath: "GuGuNiu-Gallery/imagedata.json",
        destFileName: "imagedata.json",
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/GalleryConfig.yaml",
        destFileName: "GalleryConfig.yaml",
        copyIfExists: false,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/status.html",
        destFileName: "html/status.html",
        copyIfExists: true,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/banlist.html",
        destFileName: "html/banlist.html",
        copyIfExists: true,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/speedtest.html",
        destFileName: "html/speedtest.html",
        copyIfExists: true,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/settings_panel.html",
        destFileName: "html/settings_panel.html",
        copyIfExists: true,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/visualize.html",
        destFileName: "html/visualize.html",
        copyIfExists: true,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/download_report.html",
        destFileName: "html/download_report.html",
        copyIfExists: true,
      },
      {
        sourceSubPath: "GuGuNiu-Gallery/html/img",
        destFileName: "html/img",
        copyIfExists: true,
        isDir: true,
      },
    ],
    filesToSyncSpecific: [
      {
        sourceSubPath: "ÂíïÂíïÁâõÂõæÂ∫ìÁÆ°ÁêÜÂô®.js",
        destDir: path.join(YunzaiPath, "plugins", "example"),
        destFileName: "ÂíïÂíïÁâõÂõæÂ∫ìÁÆ°ÁêÜÂô®.js",
      },
    ],
  };

  // --- ÂÆû‰æãÂ±ûÊÄß ---
  config = Default_Config;
  logPrefix = Default_Config.logPrefix;
  logger = global.logger || console;
  isPluginInited = false;
  task = null;

  /**
   * @description Êèí‰ª∂ÂÆû‰æãÁöÑÊûÑÈÄ†Âô®ÔºåÂàùÂßãÂåñÂü∫Êú¨‰ø°ÊÅØÂíåÂÆöÊó∂‰ªªÂä°„ÄÇ
   */
  constructor() {
    super({
      name: "„ÄéÂíïÂíïÁâõüêÇ„ÄèÂõæÂ∫ìÁÆ°ÁêÜÂô® v4.9.0", // ‰øùÊåÅÊúÄÊñ∞ÁâàÊú¨Âè∑
      dsc: "„ÄéÂíïÂíïÁâõüêÇ„ÄèÂõæÂ∫ìÁÆ°ÁêÜÂô®",
      event: "message",
      priority: 500,
      rule: GUGUNIU_RULES,
    });
    this.task = {
      name: `${this.logPrefix} ÂÆöÊó∂Êõ¥Êñ∞`,
      cron: Default_Config.cronUpdate,
      fnc: () => this.RunUpdateTask(),
      log: false,
    };
    this._initializeInstance();
  }

  // --- ÂÆû‰æãÊñπÊ≥ï ---
  /**
   * @description ÂÆû‰æãÂàùÂßãÂåñÈÄªËæëÔºåÁ°Æ‰øùÂÖ®Â±ÄÂàùÂßãÂåñÂÆåÊàêÂêéÂÜçÊ†áËÆ∞ÂÆû‰æãÂàùÂßãÂåñÊàêÂäü„ÄÇ
   */
  async _initializeInstance() {
    if (
      !MiaoPluginMBT.initializationPromise &&
      !MiaoPluginMBT.isGloballyInitialized
    ) {
      MiaoPluginMBT.InitializePlugin(this.logger);
    }
    try {
      await MiaoPluginMBT.initializationPromise;
      this.isPluginInited = MiaoPluginMBT.isGloballyInitialized;
      if (
        this.isPluginInited &&
        this.task &&
        MiaoPluginMBT.MBTConfig.cronUpdate &&
        this.task.cron !== MiaoPluginMBT.MBTConfig.cronUpdate
      ) {
        this.logger.info(
          `${this.logPrefix} Êõ¥Êñ∞ Cron Ë°®ËææÂºè: ${this.task.cron} -> ${MiaoPluginMBT.MBTConfig.cronUpdate}`
        );
        this.task.cron = MiaoPluginMBT.MBTConfig.cronUpdate;
      }
    } catch (initError) {
      this.logger.error(
        `${this.logPrefix} ÂÆû‰æãÁ≠âÂæÖÂÖ®Â±ÄÂàùÂßãÂåñÂ§±Ë¥•: ${initError.message}`
      );
      this.isPluginInited = false;
    }
  }

  /**
   * @description ÊâãÂä®Ëß¶ÂèëÊõ¥Êñ∞‰ªªÂä°ÔºåÂπ∂Ê£ÄÊü•ÈÄöÁü•‰∏ª‰∫∫ÈÄªËæë„ÄÇ
   */
  async ManualRunUpdateTask(e) {
    if (!(await this.CheckInit(e))) return true;
    if (!e.isMaster) return e.reply("Êä±Ê≠âÔºåÂè™Êúâ‰∏ª‰∫∫ÊâçËÉΩÊâãÂä®ÊâßË°åÊ≠§‰ªªÂä°„ÄÇ");

    this.logger.info(
      `${this.logPrefix} Áî®Êà∑ ${e.user_id} ÊâãÂä®Ëß¶ÂèëÊõ¥Êñ∞‰ªªÂä° (#ÊâßË°åÂíïÂíïÁâõÊõ¥Êñ∞) ‰ª•ÊµãËØïÈÄöÁü•ÈÄªËæë...`
    );
    await e.reply(
      `${this.logPrefix} Ê≠£Âú®Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞ÊµÅÁ®ãÔºåËØ∑Á®çÂÄô... (Â∞ÜÊ£ÄÊü•ÊòØÂê¶Ëß¶ÂèëÈÄöÁü•‰∏ª‰∫∫)`,
      true
    );
    let overallHasChanges = false;
    let taskError = null;

    try {
      overallHasChanges = await this.UpdateTuKu(null, true);
      this.logger.info(
        `${this.logPrefix} Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞‰ªªÂä°ÁöÑÊ†∏ÂøÉÈÄªËæëÂ∑≤ÂÆåÊàê„ÄÇÊ£ÄÊµãÂà∞Êõ¥Êñ∞: ${overallHasChanges}`
      );
    } catch (error) {
      taskError = error;
      this.logger.error(`${this.logPrefix} Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞‰ªªÂä°Êó∂ÂèëÁîüÈîôËØØ:`, error);
      await this.ReportError(e, "Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞‰ªªÂä°", error);
    }
    if (taskError) {
      await e.reply(
        `${this.logPrefix} Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞ÊâßË°åÊó∂ÈÅáÂà∞ÈîôËØØÔºåÊó†Ê≥ïÂà§Êñ≠ÈÄöÁü•Áä∂ÊÄÅ„ÄÇ`,
        true
      );
    } else {
      if (overallHasChanges) {
        await e.reply(
          `${this.logPrefix} Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞Ê£ÄÊµãÂà∞ÂèòÊõ¥ÔºåÂ∑≤Â∞ùËØïÂêë‰∏ª‰∫∫ÂèëÈÄÅÈÄöÁü•„ÄÇ (ËØ∑‰∏ª‰∫∫Ê£ÄÊü•ÁßÅËÅä)`,
          true
        );
      } else {
        await e.reply(
          `${this.logPrefix} Ê®°ÊãüÂÆöÊó∂Êõ¥Êñ∞Êú™Ê£ÄÊµãÂà∞ÂèòÊõ¥ÔºåÂõ†Ê≠§Êú™ÂèëÈÄÅÈÄöÁü•„ÄÇ`,
          true
        );
      }
    }
    return true;
  }

  /**
   * @description Ê£ÄÊü•Êèí‰ª∂ÊòØÂê¶Â∑≤ÊàêÂäüÂàùÂßãÂåñÔºåÂπ∂Âú®Êú™ÂàùÂßãÂåñÊó∂ÈòªÊ≠¢ÂëΩ‰ª§ÊâßË°å„ÄÇ
   */
  async CheckInit(e) {
    if (
      !MiaoPluginMBT.initializationPromise &&
      !MiaoPluginMBT.isGloballyInitialized
    ) {
      this.logger.info(`${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] È¶ñÊ¨°Ëß¶ÂèëÔºåÂºÄÂßãÂàùÂßãÂåñ...`);
      await this._initializeInstance();
    } else if (
      MiaoPluginMBT.initializationPromise &&
      !MiaoPluginMBT.isGloballyInitialized
    ) {
      this.logger.info(`${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] ÂàùÂßãÂåñËøõË°å‰∏≠ÔºåÁ≠âÂæÖ...`);
      try {
        await MiaoPluginMBT.initializationPromise;
        this.isPluginInited = MiaoPluginMBT.isGloballyInitialized;
      } catch (error) {
        this.logger.error(
          `${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] Á≠âÂæÖÂàùÂßãÂåñÊó∂ÊçïËé∑Âà∞ÈîôËØØ:`,
          error.message || error
        );
        this.isPluginInited = false;
      }
    } else {
      this.isPluginInited = MiaoPluginMBT.isGloballyInitialized;
    }

    if (!this.isPluginInited) {
      await e.reply(
        `${this.logPrefix} Êèí‰ª∂ÂàùÂßãÂåñÂ§±Ë¥•Êàñ‰ªçÂú®ËøõË°å‰∏≠ÔºåËØ∑Á®çÂêéÂÜçËØï„ÄÇ`,
        true
      );
      return false;
    }

    let coreDataValid = true;
    if (
      !MiaoPluginMBT.MBTConfig ||
      Object.keys(MiaoPluginMBT.MBTConfig).length === 0
    ) {
      this.logger.error(`${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] CRITICAL: ÈÖçÁΩÆ‰∏¢Â§±ÔºÅ`);
      coreDataValid = false;
    }
    if (!Array.isArray(MiaoPluginMBT._imgDataCache)) {
      this.logger.error(
        `${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] CRITICAL: ÂÖÉÊï∞ÊçÆÁºìÂ≠òÊó†ÊïàÔºÅ`
      );
      coreDataValid = false;
    }
    if (!(MiaoPluginMBT._userBanSet instanceof Set)) {
      this.logger.error(
        `${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] CRITICAL: Áî®Êà∑Â∞ÅÁ¶ÅÂàóË°®Êó†ÊïàÔºÅ`
      );
      coreDataValid = false;
    }
    if (!(MiaoPluginMBT._activeBanSet instanceof Set)) {
      this.logger.error(
        `${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] CRITICAL: ÁîüÊïàÂ∞ÅÁ¶ÅÂàóË°®Êó†ÊïàÔºÅ`
      );
      coreDataValid = false;
    }
    if (!MiaoPluginMBT._aliasData) {
      this.logger.error(
        `${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] CRITICAL: Âà´ÂêçÊï∞ÊçÆ‰∏¢Â§±ÔºÅ`
      );
      coreDataValid = false;
    }

    if (!coreDataValid) {
      await e.reply(
        `${this.logPrefix} ÂÜÖÈÉ®Áä∂ÊÄÅÈîôËØØÔºåÊ†∏ÂøÉÊï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•ÔºåËØ∑ÈáçÂêØ Bot„ÄÇ`,
        true
      );
      return false;
    }

    if (MiaoPluginMBT._imgDataCache.length === 0) {
      this.logger.warn(
        `${this.logPrefix} [Ê†∏ÂøÉÊ£ÄÊü•] Ê≥®ÊÑèÔºöÂõæÁâáÂÖÉÊï∞ÊçÆ‰∏∫Á©∫ÔºåÈÉ®ÂàÜÂäüËÉΩÂèØËÉΩÂèóÈôê„ÄÇ`
      );
    }

    return true;
  }

  /**
   * @description ÂÆû‰æãÊñπÊ≥ïÔºåË∞ÉÁî®ÈùôÊÄÅÁöÑ ReportError„ÄÇ
   */
  async ReportError(e, operationName, error, context = "") {
    await MiaoPluginMBT.ReportError(
      e,
      operationName,
      error,
      context,
      this.logger
    );
  }

  /**
   * @description Â§ÑÁêÜ #‰∏ãËΩΩÂíïÂíïÁâõ ÂëΩ‰ª§ÔºåÊ†∏ÂøÉ‰∏≤Ë°åÔºåÈôÑÂ±ûÂπ∂Ë°å‰∏ãËΩΩÔºåÊä•ÂëäÂê´ÂàùÂßãÊó•Âøó„ÄÇ
   */
  async DownloadTuKu(e) {
    if (!(await this.CheckInit(e))) return true;

    const logPrefix = this.logPrefix;
    const logger = this.logger;
    const startTime = Date.now();
    let overallSuccess = false;
    let coreRepoResult = { repo: 1, success: false, nodeName: 'Êú™ÊâßË°å', error: null };
    const subsidiaryResults = [];
    let gitLog1 = '', gitLog2 = '', gitLog3 = ''; // Áî®‰∫éÂ≠òÂÇ®ÂàùÂßãÊó•Âøó

    const DOWNLOAD_REPORT_HTML_TEMPLATE = `
    <!DOCTYPE html>
    <html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ÂíïÂíïÁâõ‰∏ãËΩΩÊä•Âëä</title>
        <style>
            body { font-family: 'Microsoft YaHei', 'PingFang SC', sans-serif; margin: 0; padding: 20px; background: linear-gradient(to bottom, #e8f5e9, #ffffff); color: #333; font-size: 14px; line-height: 1.6; width: 480px; box-sizing: border-box; }
            .container { padding: 20px; background-color: rgba(255, 255, 255, 0.85); border-radius: 10px; border: 1px solid rgba(76, 175, 80, 0.7); box-shadow: 0 4px 15px rgba(76, 175, 80, 0.2); }
            h1 { text-align: center; color: #2e7d32; margin: 0 0 15px 0; font-size: 22px; border-bottom: 1px solid #c8e6c9; padding-bottom: 10px; }
            .repo-section { margin-bottom: 15px; padding: 15px; border-radius: 6px; background-color: rgba(232, 245, 233, 0.6); border-left: 5px solid #4CAF50; }
            .repo-section.subsidiary { border-left-color: #fb8c00; background-color: rgba(255, 243, 224, 0.6); }
            .repo-title { font-weight: bold; font-size: 16px; color: #388e3c; margin-bottom: 8px; }
            .repo-section.subsidiary .repo-title { color: #e65100; }
            .status-line { display: flex; justify-content: space-between; align-items: center; padding: 5px 0;}
            .repo-section.subsidiary .status-line { border-bottom-color: #ffcc80; }
            .status-line:last-child { border-bottom: none; }
            .status-label { color: #555; }
            .status-value { font-weight: bold; }
            .status-ok { color: #2e7d32; }
            .status-fail { color: #c62828; }
            .status-local { color: #0277bd; }
            .status-na { color: #757575; }
            .error-msg { font-size: 11px; white-space: pre-wrap; word-break: break-all; color: #c62828; margin-top: 3px; padding-left: 10px;}
            .log-section { margin-top: 10px; padding-top: 10px; border-top: 1px solid #c8e6c9; }
            .log-title { font-weight: bold; color: #555; margin-bottom: 5px; font-size: 13px; }
            .log-content { font-family: 'Courier New', Courier, monospace; font-size: 11px; white-space: pre-wrap; word-break: break-all; background-color: rgba(0,0,0,0.03); padding: 8px; border-radius: 4px; max-height: 100px; overflow-y: auto; }
            .footer { text-align: center; margin-top: 20px; font-size: 11px; color: #757575; }
        </style>
    </head>
    <body style="{{scaleStyleValue}}">
        <div class="container">
            <h1>ÂíïÂíïÁâõ‰∏ãËΩΩÊä•Âëä</h1>
            {{ if coreRepoResult }}
            <div class="repo-section core">
                <div class="repo-title">Ê†∏ÂøÉ‰ªìÂ∫ì (‰∏ÄÂè∑)</div>
                <div class="status-line"> <span class="status-label">Áä∂ÊÄÅ:</span> <span class="status-value {{ coreRepoResult.success ? 'status-ok' : 'status-fail' }}">{{ coreRepoResult.success ? '‰∏ãËΩΩÊàêÂäü' : '‰∏ãËΩΩÂ§±Ë¥•' }} {{ coreRepoResult.success ? '‚úÖ' : '‚ùå' }}</span> </div>
                <div class="status-line"> <span class="status-label">ËäÇÁÇπ:</span> <span class="status-value {{ coreRepoResult.nodeName === 'Êú¨Âú∞' ? 'status-local' : (coreRepoResult.success ? 'status-ok' : 'status-fail') }}">{{ coreRepoResult.nodeName }}</span> </div>
                {{ if coreRepoResult.error }}
                <div class="status-line"> <span class="status-label">ÈîôËØØ:</span> </div> <div class="error-msg">{{ coreRepoResult.error.message || 'Êú™Áü•ÈîôËØØ' }}</div>
                {{ /if }}
                {{ if gitLog1 }}
                <div class="log-section"> <div class="log-title">ÊúÄÊñ∞:</div> <pre class="log-content">{{ gitLog1 }}</pre> </div>
                {{ /if }}
            </div>
            {{ /if }}
            {{ if subsidiaryResults && subsidiaryResults.length > 0 }}
            <div class="repo-section subsidiary">
                <div class="repo-title">ÈôÑÂ±û‰ªìÂ∫ì</div>
                {{ each subsidiaryResults subRes }}
                <div class="status-line"> <span class="status-label">{{ subRes.repo === 2 ? '‰∫åÂè∑‰ªìÂ∫ì' : (subRes.repo === 3 ? '‰∏âÂè∑‰ªìÂ∫ì' : subRes.repo + 'Âè∑‰ªìÂ∫ì') }}:</span> <span class="status-value {{ subRes.nodeName === 'Êú¨Âú∞' ? 'status-local' : (subRes.nodeName === 'Êú™ÈÖçÁΩÆ' ? 'status-na' : (subRes.success ? 'status-ok' : 'status-fail')) }}">{{ subRes.nodeName === 'Êú¨Âú∞' ? 'Â∑≤Â≠òÂú®' : (subRes.nodeName === 'Êú™ÈÖçÁΩÆ' ? 'Êú™ÈÖçÁΩÆ' : (subRes.success ? '‰∏ãËΩΩÊàêÂäü (' + subRes.nodeName + ')' : '‰∏ãËΩΩÂ§±Ë¥• (' + subRes.nodeName + ')')) }} {{ subRes.success ? '‚úÖ' : (subRes.nodeName === 'Êú™ÈÖçÁΩÆ' || subRes.nodeName === 'Êú¨Âú∞' ? '' : '‚ùå') }}</span> </div>
                {{ if subRes.error }}
                 <div class="status-line"> <span class="status-label" style="padding-left: 15px;">ÈîôËØØ:</span> </div> <div class="error-msg">{{ subRes.error.message || 'Êú™Áü•ÈîôËØØ' }}</div>
                {{ /if }}
                {{ if subRes.gitLog }}
                <div class="log-section" style="margin-top: 5px; padding-top: 5px;"> <div class="log-title" style="font-size: 12px;">ÊúÄÊñ∞:</div> <pre class="log-content" style="max-height: 60px;">{{ subRes.gitLog }}</pre> </div>
                {{ /if }}
                {{ /each }}
            </div>
            {{ /if }}
            <div class="footer">ÊÄªËÄóÊó∂: {{ duration }}s | Miao-Plugin-MBT v{{ pluginVersion }} | By ÂíïÂíïÁâõ</div>
        </div>
    </body>
    </html>
    `;

    try {
       const Repo1Exists = await MiaoPluginMBT.IsTuKuDownloaded(1);
       const Repo2UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Ass_Github_URL;
       let Repo2Exists = Repo2UrlConfigured ? await MiaoPluginMBT.IsTuKuDownloaded(2) : false;
       const Repo3UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Sexy_Github_URL;
       let Repo3Exists = Repo3UrlConfigured ? await MiaoPluginMBT.IsTuKuDownloaded(3) : false;
       let allDownloaded = Repo1Exists;
       if (Repo2UrlConfigured && !Repo2Exists) allDownloaded = false;
       if (Repo3UrlConfigured && !Repo3Exists) allDownloaded = false;
       if (allDownloaded) { return e.reply(`${logPrefix} ÊâÄÊúâÂ∑≤ÈÖçÁΩÆÁöÑÂõæÂ∫ì‰ªìÂ∫ìÈÉΩÂ∑≤Áªè‰∏ãËΩΩÂ•Ω‰∫ÜÔºå‰∏çÁî®ÈáçÂ§ç‰∏ãËΩΩÂï¶.`); }
       if (!Repo1Exists && (Repo2Exists || Repo3Exists)) { await e.reply(`${logPrefix} Áä∂ÊÄÅÂºÇÂ∏∏ÔºÅÊ†∏ÂøÉ‰ªìÂ∫ìÊú™‰∏ãËΩΩÔºå‰ΩÜÈôÑÂ±û‰ªìÂ∫ìÂ∑≤Â≠òÂú®„ÄÇÂª∫ËÆÆÂÖà #ÈáçÁΩÆÂíïÂíïÁâõ`); return true; }
       if (!Repo1Exists) {
         logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÂºÄÂßã‰∏ãËΩΩÊ†∏ÂøÉ‰ªìÂ∫ì (‰∏ÄÂè∑)...`);
         try {
           coreRepoResult = await MiaoPluginMBT.DownloadRepoWithFallback(1, Default_Config.Main_Github_URL, MiaoPluginMBT.MBTConfig.SepositoryBranch || Default_Config.SepositoryBranch, MiaoPluginMBT.paths.LocalTuKuPath, e, logger);
           if (!coreRepoResult.success) {
              logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Ê†∏ÂøÉ‰ªìÂ∫ì‰∏ãËΩΩÂ§±Ë¥•„ÄÇ`);
              const failMsg = `„ÄéÂíïÂíïÁâõ„ÄèÊ†∏ÂøÉ‰ªìÂ∫ì‰∏ãËΩΩÂ§±Ë¥• (${coreRepoResult.nodeName})„ÄÇËØ∑Ê£ÄÊü•Êó•ÂøóÊàñÁΩëÁªúÂêéÈáçËØï„ÄÇ`;
              if (coreRepoResult.error) { await this.ReportError(e, '‰∏ãËΩΩÊ†∏ÂøÉ‰ªìÂ∫ì', coreRepoResult.error); }
              else { await e.reply(failMsg).catch(() => {}); }
              return true;
           }
           logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Ê†∏ÂøÉ‰ªìÂ∫ì‰∏ãËΩΩÊàêÂäü (${coreRepoResult.nodeName})„ÄÇ`);
           // Ê†∏ÂøÉ‰∏ãËΩΩÊàêÂäüÂêéÔºåËé∑ÂèñÂÖ∂ÂàùÂßãÊó•Âøó
           gitLog1 = await MiaoPluginMBT.GetTuKuLog(1, MiaoPluginMBT.paths.LocalTuKuPath, logger);
         } catch (err) {
           logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Ê†∏ÂøÉ‰ªìÂ∫ì‰∏ãËΩΩËøáÁ®ã‰∏≠ÂèëÁîüÊÑèÂ§ñÈîôËØØ:`, err);
           coreRepoResult = { repo: 1, success: false, nodeName: 'ÊâßË°åÂºÇÂ∏∏', error: err };
           await this.ReportError(e, '‰∏ãËΩΩÊ†∏ÂøÉ‰ªìÂ∫ì', coreRepoResult.error);
           return true;
         }
       } else {
         logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Ê†∏ÂøÉ‰ªìÂ∫ìÂ∑≤Â≠òÂú®ÔºåË∑≥Ëøá‰∏ãËΩΩ„ÄÇ`);
         coreRepoResult = { repo: 1, success: true, nodeName: 'Êú¨Âú∞', error: null };
         // Ê†∏ÂøÉÂ∑≤Â≠òÂú®Ôºå‰πüËé∑ÂèñÂÖ∂ÂΩìÂâçÊó•Âøó
         gitLog1 = await MiaoPluginMBT.GetTuKuLog(1, MiaoPluginMBT.paths.LocalTuKuPath, logger);
       }
       overallSuccess = coreRepoResult.success;
       const subsidiaryPromises = [];
       if (Repo2UrlConfigured && !Repo2Exists) { logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Ê∑ªÂä†ÈôÑÂ±û‰ªìÂ∫ì (‰∫åÂè∑) ‰∏ãËΩΩ‰ªªÂä°„ÄÇ`); subsidiaryPromises.push(MiaoPluginMBT.DownloadRepoWithFallback(2, MiaoPluginMBT.MBTConfig.Ass_Github_URL, MiaoPluginMBT.MBTConfig.SepositoryBranch || Default_Config.SepositoryBranch, MiaoPluginMBT.paths.LocalTuKuPath2, null, logger).then(result => ({ repo: 2, ...result })).catch(err => { logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (‰∫åÂè∑) ‰∏ãËΩΩ Promise ÊçïËé∑Âà∞ÈîôËØØ:`, err); return { repo: 2, success: false, nodeName: 'ÊâßË°åÂºÇÂ∏∏', error: err }; })); }
       else if (Repo2UrlConfigured && Repo2Exists) { logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (‰∫åÂè∑) Â∑≤Â≠òÂú®„ÄÇ`); subsidiaryResults.push({ repo: 2, success: true, nodeName: 'Êú¨Âú∞', error: null, gitLog: await MiaoPluginMBT.GetTuKuLog(1, MiaoPluginMBT.paths.LocalTuKuPath2, logger) }); } // Â∑≤Â≠òÂú®‰πüËé∑ÂèñÊó•Âøó
       else { logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (‰∫åÂè∑) Êú™ÈÖçÁΩÆ„ÄÇ`); }
       if (Repo3UrlConfigured && !Repo3Exists) { logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Ê∑ªÂä†ÈôÑÂ±û‰ªìÂ∫ì (‰∏âÂè∑) ‰∏ãËΩΩ‰ªªÂä°„ÄÇ`); subsidiaryPromises.push(MiaoPluginMBT.DownloadRepoWithFallback(3, MiaoPluginMBT.MBTConfig.Sexy_Github_URL, MiaoPluginMBT.MBTConfig.SepositoryBranch || Default_Config.SepositoryBranch, MiaoPluginMBT.paths.LocalTuKuPath3, null, logger).then(result => ({ repo: 3, ...result })).catch(err => { logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (‰∏âÂè∑) ‰∏ãËΩΩ Promise ÊçïËé∑Âà∞ÈîôËØØ:`, err); return { repo: 3, success: false, nodeName: 'ÊâßË°åÂºÇÂ∏∏', error: err }; })); }
       else if (Repo3UrlConfigured && Repo3Exists) { logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (‰∏âÂè∑) Â∑≤Â≠òÂú®„ÄÇ`); subsidiaryResults.push({ repo: 3, success: true, nodeName: 'Êú¨Âú∞', error: null, gitLog: await MiaoPluginMBT.GetTuKuLog(1, MiaoPluginMBT.paths.LocalTuKuPath3, logger) }); } // Â∑≤Â≠òÂú®‰πüËé∑ÂèñÊó•Âøó
       else { logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (‰∏âÂè∑) Êú™ÈÖçÁΩÆ„ÄÇ`); }
       if (subsidiaryPromises.length > 0) { await e.reply('„ÄéÂíïÂíïÁâõ„ÄèÈôÑÂ±û‰ªìÂ∫ìËÅöÂêà‰∏ãËΩΩ‰∏≠,ËØ∑Á≠âÂæÖ...').catch(()=>{}); logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Á≠âÂæÖ ${subsidiaryPromises.length} ‰∏™ÈôÑÂ±û‰ªìÂ∫ì‰∏ãËΩΩÂÆåÊàê...`); const settledResults = await Promise.allSettled(subsidiaryPromises); logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÊâÄÊúâÈôÑÂ±û‰ªìÂ∫ì Promise Â∑≤ÂÆåÊàê (settled)„ÄÇ`);
           for (const result of settledResults) { // ‰ΩøÁî® for...of ‰øùËØÅÈ°∫Â∫èËé∑ÂèñÊó•Âøó
               if (result.status === 'fulfilled') {
                   const resValue = result.value;
                   if(resValue.success && resValue.nodeName !== 'Êú¨Âú∞' && resValue.nodeName !== 'Êú™ÈÖçÁΩÆ'){ // Êñ∞‰∏ãËΩΩÊàêÂäüÁöÑ
                       logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (${resValue.repo}Âè∑) ‰∏ãËΩΩÊàêÂäü (${resValue.nodeName})„ÄÇ`);
                       let repoPath = null;
                       if (resValue.repo === 2) repoPath = MiaoPluginMBT.paths.LocalTuKuPath2;
                       if (resValue.repo === 3) repoPath = MiaoPluginMBT.paths.LocalTuKuPath3;
                       if (repoPath) resValue.gitLog = await MiaoPluginMBT.GetTuKuLog(1, repoPath, logger); // Ëé∑ÂèñÊó•ÂøóÂπ∂Ê∑ªÂä†Âà∞ÁªìÊûú
                   } else if (!resValue.success) {
                       logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÈôÑÂ±û‰ªìÂ∫ì (${resValue.repo}Âè∑) ‰∏ãËΩΩÂ§±Ë¥• (${resValue.nodeName})„ÄÇ`);
                       logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] Â§±Ë¥•ËØ¶ÊÉÖ:`, resValue.error);
                   }
                   subsidiaryResults.push(resValue); // Â∞ÜÂ§ÑÁêÜÂêéÁöÑÁªìÊûúÂä†ÂÖ•
               } else { logger.error(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ‰∏Ä‰∏™ÈôÑÂ±û‰ªìÂ∫ì Promise rejected:`, result.reason); }
           }
       }

      //  ÁîüÊàêÂπ∂ÂèëÈÄÅÂõæÂΩ¢ÂåñÊä•Âëä
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      subsidiaryResults.sort((a, b) => a.repo - b.repo);
      const reportData = {
          coreRepoResult: coreRepoResult,
          subsidiaryResults: subsidiaryResults,
          duration: duration,
          scaleStyleValue: MiaoPluginMBT.getScaleStyleValue(),
          pluginVersion: MiaoPluginMBT.GetVersionStatic(), 
          gitLog1: gitLog1, 
      };

      let tempReportHtmlPath = '';
      let tempReportImgPath = '';
      let reportSent = false; // Ê†áËÆ∞Êä•ÂëäÊòØÂê¶Â∑≤ÂèëÈÄÅ 

      try {
          logger.info(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÂºÄÂßãÂáÜÂ§áÂõæÁâáÊä•Âëä...`);
          if (typeof DOWNLOAD_REPORT_HTML_TEMPLATE !== 'string' || DOWNLOAD_REPORT_HTML_TEMPLATE.length === 0) {
              throw new Error('DOWNLOAD_REPORT_HTML_TEMPLATE Â∏∏ÈáèÊó†Êïà!');
          }

          await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, { recursive: true });
          tempReportHtmlPath = path.join(MiaoPluginMBT.paths.tempHtmlPath, `download-report-tpl-${Date.now()}.html`);
          await fsPromises.writeFile(tempReportHtmlPath, DOWNLOAD_REPORT_HTML_TEMPLATE, 'utf8');

          await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, { recursive: true });
          tempReportImgPath = path.join(MiaoPluginMBT.paths.tempImgPath, `download-report-${Date.now()}.png`);

          logger.info(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÂºÄÂßãÁîüÊàêÂõæÁâáÊä•Âëä (tplFile + ...data ÊñπÂºè)...`);
          const reportImg = await puppeteer.screenshot('guguniu-download-report', {
              tplFile: tempReportHtmlPath,
              savePath: tempReportImgPath,
              imgType: 'png',
              pageGotoParams: { waitUntil: 'networkidle0' },
              ...reportData, // Áõ¥Êé•Â±ïÂºÄÊï∞ÊçÆ
              screenshotOptions: { fullPage: false },
              pageBoundingRect: { selector: '.container', padding: 0 },
              width: 520,
          });

          if (reportImg) {
              await e.reply(reportImg);
              logger.info(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÂõæÁâáÊä•ÂëäÂ∑≤ÂèëÈÄÅ„ÄÇ`);
              reportSent = true; // Ê†áËÆ∞ÂõæÁâáÊä•ÂëäÂèëÈÄÅÊàêÂäü
          } else {
              throw new Error('Puppeteer ÁîüÊàê‰∏ãËΩΩÊä•ÂëäÂõæÁâáÂ§±Ë¥• (ËøîÂõûÁ©∫)');
          }
      } catch (reportError) {
          logger.error(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÁîüÊàêÊàñÂèëÈÄÅÂõæÁâáÊä•ÂëäÊó∂Âá∫Èîô:`, reportError);
          // ÂõæÁâáÊä•ÂëäÂ§±Ë¥•ÔºåÂáÜÂ§áÂèëÈÄÅÊñáÊú¨ÂíåÊó•ÂøóÂêàÂπ∂Ê∂àÊÅØ
          const logMessages = [];
          let coreStatusLineText = `Ê†∏ÂøÉ‰ªìÂ∫ì: ${coreRepoResult.success ? 'ÊàêÂäü' : 'Â§±Ë¥•'} (${coreRepoResult.nodeName})`;
          if (coreRepoResult.error) coreStatusLineText += ` | ÈîôËØØ: ${coreRepoResult.error.message}`;
          logMessages.push(coreStatusLineText);
          if (gitLog1) logMessages.push(`--- Ê†∏ÂøÉ‰ªìÂ∫ìÊúÄÊñ∞ ---\n${gitLog1}`);

          subsidiaryResults.forEach(res => {
              let subStatusLineText = `${res.repo === 2 ? '‰∫åÂè∑‰ªìÂ∫ì' : (res.repo === 3 ? '‰∏âÂè∑‰ªìÂ∫ì' : res.repo + 'Âè∑‰ªìÂ∫ì')}: `;
              if (res.nodeName === 'Êú¨Âú∞') subStatusLineText += 'Â∑≤Â≠òÂú®';
              else if (res.nodeName === 'Êú™ÈÖçÁΩÆ') subStatusLineText += 'Êú™ÈÖçÁΩÆ';
              else subStatusLineText += `${res.success ? 'ÊàêÂäü' : 'Â§±Ë¥•'} (${res.nodeName})`;
              if (res.error) subStatusLineText += ` | ÈîôËØØ: ${res.error.message}`;
              logMessages.push(subStatusLineText);
              if (res.gitLog) logMessages.push(`--- ${res.repo === 2 ? '‰∫åÂè∑' : (res.repo === 3 ? '‰∏âÂè∑' : res.repo + 'Âè∑')}‰ªìÂ∫ìÊúÄÊñ∞ ---\n${res.gitLog}`);
          });

          try {
              const forwardMsg = await common.makeForwardMsg(e, logMessages, '„ÄéÂíïÂíïÁâõ„Äè‰∏ãËΩΩÁªìÊûú‰∏éÊó•Âøó');
              if (forwardMsg) {
                  await e.reply(forwardMsg);
                  logger.info(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÂõæÁâáÊä•ÂëäÂ§±Ë¥•ÔºåÂ∑≤ÂèëÈÄÅÊñáÊú¨ÁªìÊûú‰∏éÊó•ÂøóÂêàÂπ∂Ê∂àÊÅØ„ÄÇ`);
                  reportSent = true; // Ê†áËÆ∞ÊñáÊú¨Êä•ÂëäÂèëÈÄÅÊàêÂäü
              } else {
                   logger.error(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÂàõÂª∫ÊñáÊú¨ÁªìÊûúÂêàÂπ∂Ê∂àÊÅØÂ§±Ë¥•„ÄÇ`);
              }
          } catch (fwdErr) {
              logger.error(`${logPrefix} [‰∏ãËΩΩÊä•Âëä] ÂèëÈÄÅÊñáÊú¨ÁªìÊûúÂêàÂπ∂Ê∂àÊÅØÂ§±Ë¥•:`, fwdErr);
          }
          // Â¶ÇÊûúÊñáÊú¨‰πüÂèëÈÄÅÂ§±Ë¥•ÔºåÂÜçË∞ÉÁî® ReportError
          if (!reportSent) {
              await this.ReportError(e, 'ÂèëÈÄÅ‰∏ãËΩΩÁªìÊûú', reportError);
          }

      } finally {
          // Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
          if (tempReportHtmlPath && fs.existsSync(tempReportHtmlPath)) {
              try { await fsPromises.unlink(tempReportHtmlPath); } catch (unlinkErr) {}
          }
          if (tempReportImgPath && fs.existsSync(tempReportImgPath)) {
              try { await fsPromises.unlink(tempReportImgPath); } catch (unlinkErr) {}
          }
          const possiblePuppeteerTempDir = path.join(MiaoPluginMBT.paths.tempPath, '..', 'guguniu-download-report');
          if (fs.existsSync(possiblePuppeteerTempDir)) { try { await safeDelete(possiblePuppeteerTempDir); } catch (deleteErr) {} }
      }


      //  ÊâßË°å‰∏ãËΩΩÂêéËÆæÁΩÆ 
      logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÂºÄÂßãÊâßË°å RunPostDownloadSetup...`);
      await MiaoPluginMBT.RunPostDownloadSetup(e, logger);
      logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] RunPostDownloadSetup ÊâßË°åÂÆåÊàê„ÄÇ`);

      await e.reply('„ÄéÂíïÂíïÁâõ„ÄèÊàêÂäüËøõÂÖ•ÂñµÂñµÈáåÈù¢ÔºÅ').catch(() => {});

    } catch (error) {
      logger.error(`${logPrefix} [DownloadTuKu-Ê†∏ÂøÉ] È°∂Â±ÇÊâßË°åÂá∫Èîô:`, error);
      await this.ReportError(e, '‰∏ãËΩΩÂõæÂ∫ìÈ°∂Â±Ç', error);
      overallSuccess = false;
    } finally {
      const durationFinal = ((Date.now() - startTime) / 1000).toFixed(1);
      logger.info(`${logPrefix} [Ê†∏ÂøÉ‰∏ãËΩΩ] ÊµÅÁ®ãÁªìÊùüÔºåÊÄªËÄóÊó∂ ${durationFinal} Áßí„ÄÇ`);
    }
    return true;
  }

 /**
   * @description Â§ÑÁêÜ #Êõ¥Êñ∞ÂíïÂíïÁâõ ÂëΩ‰ª§ÔºåÊâßË°åÂ§ö‰ªìÂ∫ìÊõ¥Êñ∞ÊµÅÁ®ãÔºåÂπ∂ÁîüÊàêÂõæÁâáÊä•Âëä„ÄÇ
   */
  async UpdateTuKu(e, isScheduled = false) {
    if (!isScheduled && !(await this.CheckInit(e))) return false; 

    const logger = this.logger;
    const logPrefix = this.logPrefix;

    const Repo1Exists = await MiaoPluginMBT.IsTuKuDownloaded(1);
    const Repo2UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Ass_Github_URL;
    let Repo2Exists = Repo2UrlConfigured && (await MiaoPluginMBT.IsTuKuDownloaded(2));
    const Repo3UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Sexy_Github_URL;
    let Repo3Exists = Repo3UrlConfigured && (await MiaoPluginMBT.IsTuKuDownloaded(3));

    let anyRepoMissing = false;
    if (!Repo1Exists) anyRepoMissing = true;
    if (Repo2UrlConfigured && !Repo2Exists) anyRepoMissing = true;
    if (Repo3UrlConfigured && !Repo3Exists) anyRepoMissing = true;

    if (anyRepoMissing && Repo1Exists) {
      if (!isScheduled && e) await e.reply("„ÄéÂíïÂíïÁâõüêÇ„ÄèÈÉ®ÂàÜÈôÑÂ±û‰ªìÂ∫ìÊú™‰∏ãËΩΩÔºåÂª∫ËÆÆÂÖà `#‰∏ãËΩΩÂíïÂíïÁâõ` Ë°•ÂÖ®„ÄÇ", true);
    } else if (!Repo1Exists) {
      if (!isScheduled && e) await e.reply("„ÄéÂíïÂíïÁâõüêÇ„ÄèÂõæÂ∫ìËøòÊ≤°‰∏ãËΩΩÂë¢ÔºåÂÖà `#‰∏ãËΩΩÂíïÂíïÁâõ` Âêß„ÄÇ", true);
      return false; // Ê†∏ÂøÉ‰ªìÂ∫ì‰∏çÂ≠òÂú®ÔºåÊó†Ê≥ïÊõ¥Êñ∞
    }

    const startTime = Date.now();
    if (!isScheduled && e) await e.reply("„ÄéÂíïÂíïÁâõüêÇ„ÄèÂºÄÂßãÊ£ÄÊü•Êõ¥Êñ∞ (ÊâÄÊúâ‰ªìÂ∫ì)ÔºåÁ®çÁ≠âÁâáÂàª...", true);
    logger.info(`${logPrefix} [Êõ¥Êñ∞ÊµÅÁ®ã] ÂºÄÂßã @ ${new Date(startTime).toISOString()}`);

    const reportResults = [];
    let overallSuccess = true;
    let overallHasChanges = false;

    // Êõ¥Êñ∞Ê†∏ÂøÉ‰ªìÂ∫ì (‰∏ÄÂè∑)
    if (Repo1Exists) {
      const result = await MiaoPluginMBT.UpdateSingleRepo(e, 1, MiaoPluginMBT.paths.LocalTuKuPath, "‰∏ÄÂè∑‰ªìÂ∫ì (Ê†∏ÂøÉ)", Default_Config.Main_Github_URL, MiaoPluginMBT.MBTConfig.SepositoryBranch || Default_Config.SepositoryBranch, isScheduled, logger);
      overallSuccess &&= result.success;
      overallHasChanges ||= result.hasChanges;
      reportResults.push({
        name: "‰∏ÄÂè∑‰ªìÂ∫ì (Ê†∏ÂøÉ)",
        statusText: result.success ? (result.hasChanges ? "Êõ¥Êñ∞ÊàêÂäü" : "Â∑≤ÊòØÊúÄÊñ∞") : "Êõ¥Êñ∞Â§±Ë¥•",
        statusClass: result.success ? (result.hasChanges ? "status-ok" : "status-no-change") : "status-fail",
        error: result.success ? null : (result.error || { message: "Êú™Áü•ÈîôËØØ" }),
        log: result.success ? (await MiaoPluginMBT.GetTuKuLog(5, MiaoPluginMBT.paths.LocalTuKuPath, logger)) : (result.error?.stderr || result.error?.message || "Ëé∑ÂèñÊó•ÂøóÂ§±Ë¥•"),
      });
    } else {
      reportResults.push({ name: "‰∏ÄÂè∑‰ªìÂ∫ì (Ê†∏ÂøÉ)", statusText: "Êú™‰∏ãËΩΩ", statusClass: "status-skipped", error: null, log: null });
      overallSuccess = false; // Ê†∏ÂøÉÊú™‰∏ãËΩΩÔºåÊï¥‰ΩìËßÜ‰∏∫Â§±Ë¥•
    }

    // Êõ¥Êñ∞ÈôÑÂ±û‰ªìÂ∫ì (‰∫åÂè∑) - ‰ªÖÂΩìÊ†∏ÂøÉ‰ªìÂ∫ìÊìç‰ΩúÂü∫Êú¨ÊàêÂäüÊàñÊú™ÈÖçÁΩÆÊó∂
    if (Repo2UrlConfigured) {
      if (Repo2Exists) {
        const result = await MiaoPluginMBT.UpdateSingleRepo(null, 2, MiaoPluginMBT.paths.LocalTuKuPath2, "‰∫åÂè∑‰ªìÂ∫ì (ÈôÑÂ±û)", MiaoPluginMBT.MBTConfig.Ass_Github_URL, MiaoPluginMBT.MBTConfig.SepositoryBranch || Default_Config.SepositoryBranch, isScheduled, logger);
        overallSuccess &&= result.success;
        overallHasChanges ||= result.hasChanges;
        reportResults.push({
          name: "‰∫åÂè∑‰ªìÂ∫ì (ÈôÑÂ±û)",
          statusText: result.success ? (result.hasChanges ? "Êõ¥Êñ∞ÊàêÂäü" : "Â∑≤ÊòØÊúÄÊñ∞") : "Êõ¥Êñ∞Â§±Ë¥•",
          statusClass: result.success ? (result.hasChanges ? "status-ok" : "status-no-change") : "status-fail",
          error: result.success ? null : (result.error || { message: "Êú™Áü•ÈîôËØØ" }),
          log: result.success ? (await MiaoPluginMBT.GetTuKuLog(5, MiaoPluginMBT.paths.LocalTuKuPath2, logger)) : (result.error?.stderr || result.error?.message || "Ëé∑ÂèñÊó•ÂøóÂ§±Ë¥•"),
        });
      } else {
        reportResults.push({ name: "‰∫åÂè∑‰ªìÂ∫ì (ÈôÑÂ±û)", statusText: "Êú™‰∏ãËΩΩ", statusClass: "status-skipped", error: null, log: null });
        // overallSuccess &&= false; // ÈôÑÂ±ûÊú™‰∏ãËΩΩ‰∏çÂΩ±ÂìçÊï¥‰ΩìÊàêÂäüÔºå‰ΩÜÂèØËÉΩÂΩ±ÂìçÂäüËÉΩ
      }
    } else {
      reportResults.push({ name: "‰∫åÂè∑‰ªìÂ∫ì (ÈôÑÂ±û)", statusText: "Êú™ÈÖçÁΩÆ", statusClass: "status-skipped", error: null, log: null });
    }

    // Êõ¥Êñ∞ÈôÑÂ±û‰ªìÂ∫ì (‰∏âÂè∑) - ‰ªÖÂΩìÊ†∏ÂøÉ‰ªìÂ∫ìÊìç‰ΩúÂü∫Êú¨ÊàêÂäüÊàñÊú™ÈÖçÁΩÆÊó∂
    if (Repo3UrlConfigured) {
      if (Repo3Exists) {
        const result = await MiaoPluginMBT.UpdateSingleRepo(null, 3, MiaoPluginMBT.paths.LocalTuKuPath3, "‰∏âÂè∑‰ªìÂ∫ì (Ê∂©Ê∂©)", MiaoPluginMBT.MBTConfig.Sexy_Github_URL, MiaoPluginMBT.MBTConfig.SepositoryBranch || Default_Config.SepositoryBranch, isScheduled, logger);
        overallSuccess &&= result.success;
        overallHasChanges ||= result.hasChanges;
        reportResults.push({
          name: "‰∏âÂè∑‰ªìÂ∫ì (Ê∂©Ê∂©)",
          statusText: result.success ? (result.hasChanges ? "Êõ¥Êñ∞ÊàêÂäü" : "Â∑≤ÊòØÊúÄÊñ∞") : "Êõ¥Êñ∞Â§±Ë¥•",
          statusClass: result.success ? (result.hasChanges ? "status-ok" : "status-no-change") : "status-fail",
          error: result.success ? null : (result.error || { message: "Êú™Áü•ÈîôËØØ" }),
          log: result.success ? (await MiaoPluginMBT.GetTuKuLog(5, MiaoPluginMBT.paths.LocalTuKuPath3, logger)) : (result.error?.stderr || result.error?.message || "Ëé∑ÂèñÊó•ÂøóÂ§±Ë¥•"),
        });
      } else {
        reportResults.push({ name: "‰∏âÂè∑‰ªìÂ∫ì (Ê∂©Ê∂©)", statusText: "Êú™‰∏ãËΩΩ", statusClass: "status-skipped", error: null, log: null });
        // overallSuccess &&= false;
      }
    } else {
      reportResults.push({ name: "‰∏âÂè∑‰ªìÂ∫ì (Ê∂©Ê∂©)", statusText: "Êú™ÈÖçÁΩÆ", statusClass: "status-skipped", error: null, log: null });
    }

    // ÂêéÁª≠Â§ÑÁêÜ
    if (overallSuccess && overallHasChanges) {
      logger.info(`${logPrefix} Ê£ÄÊµãÂà∞Êõ¥Êñ∞ÔºåÂºÄÂßãÊâßË°åÊõ¥Êñ∞ÂêéËÆæÁΩÆ...`);
      await MiaoPluginMBT.RunPostUpdateSetup(e, isScheduled, logger);
    }

    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
    const reportData = {
      pluginVersion: MiaoPluginMBT.GetVersionStatic(),
      duration: duration,
      scaleStyleValue: MiaoPluginMBT.getScaleStyleValue(),
      results: reportResults,
      overallSuccess: overallSuccess,
      overallHasChanges: overallHasChanges,
    };

    // ÁîüÊàêÂπ∂ÂèëÈÄÅÊä•ÂëäÂõæÁâá
    let tempHtmlFilePath = '';
    let tempImgFilePath = '';
    let reportSent = false;

    try {
      const sourceHtmlPath = path.join(MiaoPluginMBT.paths.commonResPath, 'html', 'update_report.html');
      // Á°Æ‰øùÊ®°ÊùøÂ≠òÂú®
      try {
          await fsPromises.access(sourceHtmlPath);
      } catch (err) {
          logger.error(`${logPrefix} [Êõ¥Êñ∞Êä•Âëä] Êâæ‰∏çÂà∞Êõ¥Êñ∞Êä•ÂëäÊ®°Êùø: ${sourceHtmlPath}`, err);
          // Â∞ùËØïÂèëÈÄÅÊñáÊú¨Ê∂àÊÅØ‰Ωú‰∏∫ÂõûÈÄÄ
          let fallbackMsg = `${logPrefix} Êõ¥Êñ∞Ê£ÄÊü•ÂÆåÊàê„ÄÇ\n`;
          reportResults.forEach(res => {
              fallbackMsg += `${res.name}: ${res.statusText}\n`;
              if (res.error) fallbackMsg += `  ÈîôËØØ: ${res.error.message}\n`;
          });
          if (e && !isScheduled) await e.reply(fallbackMsg);
          else if (isScheduled && Bot.master && Bot.master.length > 0) {
              Bot.master.forEach(masterId => Bot.pickUser(masterId).sendMsg(fallbackMsg).catch(err => logger.error("ÂèëÈÄÅÂÆöÊó∂Êõ¥Êñ∞ÊñáÊú¨Êä•ÂëäÁªô‰∏ª‰∫∫Â§±Ë¥•", err)));
          }
          return overallHasChanges; // Ê®°ÊùøÁº∫Â§±ÔºåÊèêÂâçËøîÂõû
      }

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, { recursive: true });
      tempHtmlFilePath = path.join(MiaoPluginMBT.paths.tempHtmlPath, `update-report-tpl-${Date.now()}.html`);

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, { recursive: true });
      tempImgFilePath = path.join(MiaoPluginMBT.paths.tempImgPath, `update-report-${Date.now()}.png`);

      logger.info(`${logPrefix} [Êõ¥Êñ∞Êä•Âëä] ÂºÄÂßãÁîüÊàêÂõæÁâáÊä•Âëä`);
      const img = await puppeteer.screenshot('guguniu-update-report', {
        tplFile: sourceHtmlPath, 
        savePath: tempImgFilePath,
        imgType: 'png',
        pageGotoParams: { waitUntil: 'networkidle0' },
        ...reportData,
        screenshotOptions: { fullPage: true }, // Ê†πÊçÆÂÜÖÂÆπË∞ÉÊï¥ÔºåÂ¶ÇÊûúÊó•ÂøóÂ§öÂèØËÉΩÈúÄË¶Åtrue
        pageBoundingRect: { selector: '.container', padding: 0 },
        width: 560,
      });

      if (img) {
        if (!isScheduled && e) {
          await e.reply(img);
        } else if (isScheduled && Bot.master && Bot.master.length > 0) {
          logger.info(`${logPrefix} [ÂÆöÊó∂Êõ¥Êñ∞] Ê£ÄÊµãÂà∞ÂèòÊõ¥ÊàñÈîôËØØÔºåÂáÜÂ§áÂêë‰∏ª‰∫∫ÂèëÈÄÅÂõæÁâáÊä•Âëä...`);
          for (const masterId of Bot.master) {
            try {
              await Bot.pickUser(masterId).sendMsg(img);
              logger.info(`${logPrefix} [ÂÆöÊó∂Êõ¥Êñ∞] ÂõæÁâáÊä•ÂëäÂ∑≤ÂèëÈÄÅÁªô‰∏ª‰∫∫ ${masterId}`);
            } catch (sendErr) {
              logger.error(`${logPrefix} [ÂÆöÊó∂Êõ¥Êñ∞] ÂèëÈÄÅÂõæÁâáÊä•ÂëäÁªô‰∏ª‰∫∫ ${masterId} Â§±Ë¥•:`, sendErr);
              // ÂèØ‰ª•ËÄÉËôëÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ
              let fallbackMsgMaster = `${logPrefix} ÂÆöÊó∂Êõ¥Êñ∞Êä•ÂëäÂõæÁâáÂèëÈÄÅÂ§±Ë¥•„ÄÇ\n`;
              reportResults.forEach(res => {
                  fallbackMsgMaster += `${res.name}: ${res.statusText}\n`;
                  if (res.error) fallbackMsgMaster += `  ÈîôËØØ: ${res.error.message}\n`;
              });
              await Bot.pickUser(masterId).sendMsg(fallbackMsgMaster).catch(()=>{});
            }
          }
        }
        reportSent = true;
      } else {
        logger.error(`${logPrefix} [Êõ¥Êñ∞Êä•Âëä] Puppeteer ÁîüÊàêÊõ¥Êñ∞Êä•ÂëäÂõæÁâáÂ§±Ë¥• (ËøîÂõûÁ©∫)„ÄÇ`);
      }

    } catch (reportError) {
      logger.error(`${logPrefix} [Êõ¥Êñ∞Êä•Âëä] ÁîüÊàêÊàñÂèëÈÄÅÂõæÁâáÊä•ÂëäÊó∂Âá∫Èîô:`, reportError);
      // Â∞ùËØïÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ
      if (!reportSent) {
          let fallbackMsg = `${logPrefix} Êõ¥Êñ∞Ê£ÄÊü•ÂÆåÊàêÔºå‰ΩÜÊä•ÂëäÂõæÁâáÁîüÊàêÂ§±Ë¥•„ÄÇ\n`;
          reportResults.forEach(res => {
              fallbackMsg += `${res.name}: ${res.statusText}\n`;
              if (res.error) fallbackMsg += `  ÈîôËØØ: ${res.error.message}\n`;
          });
          if (e && !isScheduled) await e.reply(fallbackMsg);
          else if (isScheduled && Bot.master && Bot.master.length > 0) {
              Bot.master.forEach(masterId => Bot.pickUser(masterId).sendMsg(fallbackMsg).catch(err => logger.error("ÂèëÈÄÅÂÆöÊó∂Êõ¥Êñ∞ÊñáÊú¨Êä•ÂëäÁªô‰∏ª‰∫∫Â§±Ë¥•(ÂõæÁâáÁîüÊàêÈîôËØØ)", err)));
          }
      }
    } finally {

      if (tempImgFilePath && fs.existsSync(tempImgFilePath)) {
        try { await fsPromises.unlink(tempImgFilePath); } catch (unlinkErr) {}
      }
      const possiblePuppeteerTempDir = path.join(MiaoPluginMBT.paths.tempPath, '..', 'guguniu-update-report');
      if (fs.existsSync(possiblePuppeteerTempDir)) { try { await safeDelete(possiblePuppeteerTempDir); } catch (deleteErr) {} }
    }

    logger.info(`${logPrefix} Êõ¥Êñ∞ÊµÅÁ®ãÁªìÊùüÔºåËÄóÊó∂ ${duration} Áßí„ÄÇ`);
    return overallHasChanges; // ËøîÂõûÊòØÂê¶Êúâ‰ªª‰Ωï‰ªìÂ∫ìÂèëÁîü‰∫ÜÂÆûÈôÖÁöÑ git pull ÂèòÊõ¥
  }

  /**
   * @description Â§ÑÁêÜ #ÈáçÁΩÆÂíïÂíïÁâõ ÂëΩ‰ª§ÔºåÂΩªÂ∫ïÊ∏ÖÁêÜÂõæÂ∫ìÁõ∏ÂÖ≥Êñá‰ª∂ÂíåÁä∂ÊÄÅ„ÄÇ
   */
  async ManageTuKu(e) {
    if (!(await this.CheckInit(e))) return true;
    if (!e.isMaster)
      return e.reply(`${this.logPrefix} Ëøô‰∏™Êìç‰ΩúÂè™ÊúâÊàëÁöÑ‰∏ª‰∫∫ÊâçËÉΩÁî®Âì¶~`);

    const msg = e.msg.trim();
    if (msg !== "#ÈáçÁΩÆÂíïÂíïÁâõ") {
      return false;
    }

    const actionVerb = "ÈáçÁΩÆ";
    const startMessage = "„ÄéÂíïÂíïÁâõüêÇ„ÄèÊî∂Âà∞ÔºÅÂºÄÂßãÂΩªÂ∫ïÈáçÁΩÆÂõæÂ∫ìÔºåËØ∑Á®çÁ≠â...";
    const successMessage =
      "„ÄéÂíïÂíïÁâõüêÇ„ÄèÈáçÁΩÆÂÆåÊàêÔºÅÊâÄÊúâÁõ∏ÂÖ≥Êñá‰ª∂ÂíåÁºìÂ≠òÈÉΩÊ∏ÖÁêÜÂπ≤ÂáÄÂï¶„ÄÇÁé∞Âú®ÂèØ‰ª•ÈáçÊñ∞ `#‰∏ãËΩΩÂíïÂíïÁâõ` ‰∫Ü„ÄÇ";
    const failureMessage =
      "„ÄéÂíïÂíïÁâõüêÇ„ÄèÈáçÁΩÆËøáÁ®ã‰∏≠Â•ΩÂÉèÂá∫‰∫ÜÁÇπÈóÆÈ¢òÔºåÂèØËÉΩÊ≤°Ê∏ÖÁêÜÂπ≤ÂáÄÔºåÂø´ÂéªÁúãÁúãÊó•ÂøóÂêßÔºÅ";

    await e.reply(startMessage, true);
    this.logger.info(
      `${this.logPrefix} Áî®Êà∑ ${e.user_id} ÊâßË°å ${actionVerb} Êìç‰Ωú.`
    );

    const pathsToDeleteDirectly = [
      MiaoPluginMBT.paths.LocalTuKuPath,
      MiaoPluginMBT.paths.LocalTuKuPath2,
      MiaoPluginMBT.paths.LocalTuKuPath3,
      MiaoPluginMBT.paths.commonResPath,
    ].filter(Boolean);

    let deleteSuccess = true;
    let firstError = null;

    for (const dirPath of pathsToDeleteDirectly) {
      this.logger.info(`${this.logPrefix} Ê≠£Âú®Âà†Èô§: ${dirPath}`);
      try {
        const deleted = await safeDelete(dirPath);
        if (!deleted) {
          this.logger.warn(
            `${this.logPrefix} Âà†Èô§ ${dirPath} Êú™ÂÆåÂÖ®ÊàêÂäü (ÂèØËÉΩÈÉ®ÂàÜÊñá‰ª∂ÊÆãÁïô)`
          );
        }
      } catch (err) {
        this.logger.error(`${this.logPrefix} Âà†Èô§ ${dirPath} Êó∂ÂèëÁîüÈîôËØØ:`, err);
        deleteSuccess = false;
        if (!firstError)
          firstError = {
            operation: `Âà†Èô§ÁõÆÂΩï ${path.basename(dirPath)}`,
            error: err,
          };
      }
    }

    this.logger.info(`${this.logPrefix} ÂºÄÂßãÊ∏ÖÁêÜÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï‰∏≠ÁöÑÊÆãÁïôÊñá‰ª∂...`);
    const targetPluginDirs = [
      MiaoPluginMBT.paths.target.miaoChar,
      MiaoPluginMBT.paths.target.zzzChar,
      MiaoPluginMBT.paths.target.wavesChar,
    ].filter(Boolean);

    let cleanSuccess = true;
    for (const dirPath of targetPluginDirs) {
      try {
        await MiaoPluginMBT.CleanTargetCharacterDirs(dirPath, this.logger);
      } catch (err) {
        this.logger.error(
          `${this.logPrefix} Ê∏ÖÁêÜÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï ${dirPath} Êó∂Âá∫Èîô:`,
          err
        );
        cleanSuccess = false;
        if (!firstError)
          firstError = {
            operation: `Ê∏ÖÁêÜÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï ${path.basename(dirPath)}`,
            error: err,
          };
      }
    }

    this.logger.info(`${this.logPrefix} ÈáçÁΩÆÂÜÖÂ≠òÁä∂ÊÄÅ...`);
    await MiaoPluginMBT.configMutex.acquire();
    // await MiaoPluginMBT.banMutex.acquire(); // ÁßªÈô§ banMutex
    try {
      MiaoPluginMBT.MBTConfig = {};
      MiaoPluginMBT._imgDataCache = Object.freeze([]);
      MiaoPluginMBT._userBanSet = new Set();
      MiaoPluginMBT._activeBanSet = new Set();
      MiaoPluginMBT._aliasData = null;
      MiaoPluginMBT.isGloballyInitialized = false;
      MiaoPluginMBT.initializationPromise = null;
      this.isPluginInited = false;
      this.logger.info(`${this.logPrefix} ÂÜÖÂ≠òÁä∂ÊÄÅÂ∑≤ÈáçÁΩÆ„ÄÇ`);
    } finally {
      // MiaoPluginMBT.banMutex.release(); // ÁßªÈô§ banMutex
      MiaoPluginMBT.configMutex.release();
    }

    if (deleteSuccess && cleanSuccess) {
      await e.reply(successMessage);
    } else {
      await e.reply(failureMessage);
      if (firstError) {
        await MiaoPluginMBT.ReportError(
          e,
          `ÈáçÁΩÆÂíïÂíïÁâõ (${firstError.operation})`,
          firstError.error,
          "",
          this.logger
        );
      }
    }

    return true;
  }

  /**
   * @description Â§ÑÁêÜ #Ê£ÄÊü•ÂíïÂíïÁâõ ÂëΩ‰ª§ÔºåÁîüÊàêÂπ∂ÂèëÈÄÅÁä∂ÊÄÅÊä•ÂëäÂõæÁâá„ÄÇ
   *              Â¢ûÂä†‰∏âÂè∑‰ªìÂ∫ìÁªüËÆ°ÂíåÂäüËÉΩÂºÄÂÖ≥Áä∂ÊÄÅÊòæÁ§∫„ÄÇ
   */
  async CheckStatus(e) {
    if (!(await this.CheckInit(e))) return true;
    this.logger.info(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ÂºÄÂßãÁîüÊàêÁä∂ÊÄÅÊä•Âëä...`);

    const Repo1Exists = await MiaoPluginMBT.IsTuKuDownloaded(1);
    const Repo2UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Ass_Github_URL;
    const Repo2Exists = Repo2UrlConfigured && (await MiaoPluginMBT.IsTuKuDownloaded(2));
    const Repo3UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Sexy_Github_URL;
    const Repo3Exists = Repo3UrlConfigured && (await MiaoPluginMBT.IsTuKuDownloaded(3));
    this.logger.info(
      `${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ‰ªìÂ∫ìÁä∂ÊÄÅ - ‰∏ÄÂè∑: ${Repo1Exists ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®'}, ‰∫åÂè∑: ${
        Repo2UrlConfigured ? (Repo2Exists ? 'Â≠òÂú®' : 'Êú™‰∏ãËΩΩ') : 'Êú™ÈÖçÁΩÆ'
      }, ‰∏âÂè∑: ${Repo3UrlConfigured ? (Repo3Exists ? 'Â≠òÂú®' : 'Êú™‰∏ãËΩΩ') : 'Êú™ÈÖçÁΩÆ'}`
    );

    if (!Repo1Exists) {
      return e.reply('„ÄéÂíïÂíïÁâõüêÇ„ÄèÂõæÂ∫ìËøòÊ≤°‰∏ãËΩΩÂë¢ÔºåÂÖà `#‰∏ãËΩΩÂíïÂíïÁâõ` ÂêßÔºÅ', true);
    }
    let missingSubsidiary = false;
    if (Repo2UrlConfigured && !Repo2Exists) missingSubsidiary = true;
    if (Repo3UrlConfigured && !Repo3Exists) missingSubsidiary = true;
    if (Repo1Exists && missingSubsidiary) {
      return e.reply('„ÄéÂíïÂíïÁâõüêÇ„ÄèÊ†∏ÂøÉ‰ªìÂ∫ìÂ∑≤‰∏ãËΩΩÔºå‰ΩÜÈÉ®ÂàÜÈôÑÂ±û‰ªìÂ∫ìÊú™‰∏ãËΩΩÊàñ‰∏¢Â§±„ÄÇÂª∫ËÆÆÂÖà `#‰∏ãËΩΩÂíïÂíïÁâõ` Ë°•ÂÖ®Êàñ `#ÈáçÁΩÆÂíïÂíïÁâõ` ÂêéÈáçÊñ∞‰∏ãËΩΩ„ÄÇ', true);
    }
    if (!Repo1Exists && (Repo2Exists || Repo3Exists)) {
      return e.reply('„ÄéÂíïÂíïÁâõüêÇ„ÄèÁä∂ÊÄÅÂºÇÂ∏∏ÔºÅÊ†∏ÂøÉ‰ªìÂ∫ìÊú™‰∏ãËΩΩÔºå‰ΩÜÈôÑÂ±û‰ªìÂ∫ìÂ∑≤Â≠òÂú®ÔºüÂª∫ËÆÆÂÖà `#ÈáçÁΩÆÂíïÂíïÁâõ`„ÄÇ', true);
    }


    let tempHtmlFilePath = '';
    let tempImgFilePath = '';

    try {
      const pluginVersion = MiaoPluginMBT.GetVersionStatic();
      const GameFoldersMap = { gs: 'ÂéüÁ•û', sr: 'ÊòüÈìÅ', zzz: 'ÁªùÂå∫Èõ∂', waves: 'È∏£ÊΩÆ' };
      const stats = {
        meta: { roles: 0, images: 0, games: {} },
        scan: { roles: 0, images: 0, gameImages: {}, gameRoles: {}, gameSizes: {}, gameSizesFormatted: {}, totalSize: 0, totalGitSize: 0, totalFilesSize: 0, totalSizeFormatted: '0 B', totalGitSizeFormatted: '0 B', totalFilesSizeFormatted: '0 B' },
        repos: {
          1: { name: '‰∏ÄÂè∑‰ªìÂ∫ì', exists: Repo1Exists, size: 0, gitSize: 0, filesSize: 0, sizeFormatted: 'N/A', gitSizeFormatted: 'N/A', filesSizeFormatted: 'N/A' },
          2: { name: '‰∫åÂè∑‰ªìÂ∫ì', exists: Repo2Exists && Repo2UrlConfigured, size: 0, gitSize: 0, filesSize: 0, sizeFormatted: 'N/A', gitSizeFormatted: 'N/A', filesSizeFormatted: 'N/A' },
          3: { name: '‰∏âÂè∑‰ªìÂ∫ì', exists: Repo3Exists && Repo3UrlConfigured, size: 0, gitSize: 0, filesSize: 0, sizeFormatted: 'N/A', gitSizeFormatted: 'N/A', filesSizeFormatted: 'N/A' }, // Ê∑ªÂä†‰∏âÂè∑‰ªìÂ∫ìÁªìÊûÑ
        },
      };
      Object.values(GameFoldersMap).forEach(gameName => {
        stats.meta.games[gameName] = 0;
        stats.scan.gameImages[gameName] = 0;
        stats.scan.gameRoles[gameName] = 0;
        stats.scan.gameSizes[gameName] = 0;
        stats.scan.gameSizesFormatted[gameName] = '0 B';
      });

      // ËØªÂèñÈÖçÁΩÆ‰ø°ÊÅØ
      const currentConfig = MiaoPluginMBT.MBTConfig; // Áõ¥Êé•‰ΩøÁî®ÂÜÖÂ≠ò‰∏≠ÁöÑÊúÄÊñ∞ÈÖçÁΩÆ
      const configForRender = {
        enabled: currentConfig?.TuKuOP ?? Default_Config.defaultTuKuOp,
        pflLevel: currentConfig?.PFL ?? Default_Config.defaultPfl,
        aiEnabled: currentConfig?.Ai ?? true,
        easterEggEnabled: currentConfig?.EasterEgg ?? true,
        layoutEnabled: currentConfig?.layout ?? true,
        pm18Enabled: currentConfig?.PM18 ?? false,
        activeBans: MiaoPluginMBT._activeBanSet?.size ?? 0,
        userBans: MiaoPluginMBT._userBanSet?.size ?? 0,
        purifiedBans: 0, // Ëøô‰∏™ËÆ°ÁÆó‰øùÊåÅ‰∏çÂèò
        enabledText: '',
        pflDesc: '',
        aiStatusText: '',
        easterEggStatusText: '',
        layoutStatusText: '',
        pm18StatusText: '',
      };
      configForRender.enabledText = configForRender.enabled ? 'Â∑≤ÂêØÁî®' : 'Â∑≤Á¶ÅÁî®';
      configForRender.purifiedBans = Math.max(0, configForRender.activeBans - configForRender.userBans);
      configForRender.pflDesc = Purify_Level.getDescription(configForRender.pflLevel);
      configForRender.aiStatusText = configForRender.aiEnabled ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠';
      configForRender.easterEggStatusText = configForRender.easterEggEnabled ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠';
      configForRender.layoutStatusText = configForRender.layoutEnabled ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠';
      configForRender.pm18StatusText = configForRender.pm18Enabled ? 'ÂºÄÂêØ' : 'ÂÖ≥Èó≠';


      // ÂÖÉÊï∞ÊçÆÁªüËÆ°
      const characterSet = new Set();
      if (Array.isArray(MiaoPluginMBT._imgDataCache) && MiaoPluginMBT._imgDataCache.length > 0) {
        stats.meta.images = MiaoPluginMBT._imgDataCache.length;
        MiaoPluginMBT._imgDataCache.forEach(item => {
          if (item && item.characterName) { characterSet.add(item.characterName); }
          const PathParts = item?.path?.split('/');
          if (PathParts?.length > 0) {
            const GameKey = PathParts[0].split('-')[0];
            const GameName = GameFoldersMap[GameKey];
            if (GameName) stats.meta.games[GameName] = (stats.meta.games[GameName] || 0) + 1;
          }
        });
      }
      stats.meta.roles = characterSet.size;
      this.logger.info(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ÂÖÉÊï∞ÊçÆ: ${stats.meta.roles}ËßíËâ≤, ${stats.meta.images}ÂõæÁâá`);

      // Êú¨Âú∞Êñá‰ª∂Êâ´ÊèèÁªüËÆ°
      const RepoStatsScan = {
        1: { path: MiaoPluginMBT.paths.LocalTuKuPath, gitPath: MiaoPluginMBT.paths.gitFolderPath, exists: Repo1Exists },
        2: { path: MiaoPluginMBT.paths.LocalTuKuPath2, gitPath: MiaoPluginMBT.paths.gitFolderPath2, exists: Repo2Exists && Repo2UrlConfigured },
        3: { path: MiaoPluginMBT.paths.LocalTuKuPath3, gitPath: MiaoPluginMBT.paths.gitFolderPath3, exists: Repo3Exists && Repo3UrlConfigured }, // Ê∑ªÂä†‰∏âÂè∑‰ªìÂ∫ì
      };
      const ScannedRoleImageCounts = {};
      const ScannedGameSizes = {};
      Object.values(GameFoldersMap).forEach(gameName => {
        ScannedRoleImageCounts[gameName] = {};
        ScannedGameSizes[gameName] = 0;
      });
      let totalGitSizeScan = 0;

      for (const RepoNum of Object.keys(RepoStatsScan)) {
        const Repo = RepoStatsScan[RepoNum];
        if (!Repo.exists) continue;
        try {
          const repoGitSize = await FolderSize(Repo.gitPath);
          totalGitSizeScan += repoGitSize;
          stats.repos[RepoNum].gitSize = repoGitSize;
          stats.repos[RepoNum].gitSizeFormatted = FormatBytes(repoGitSize);
        } catch (sizeError) {
          this.logger.error(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ËÆ°ÁÆó‰ªìÂ∫ì ${RepoNum} Git Â§ßÂ∞èÂ§±Ë¥•:`, sizeError);
          stats.repos[RepoNum].gitSizeFormatted = 'ÈîôËØØ';
        }
        for (const GameKey in GameFoldersMap) {
          const GameName = GameFoldersMap[GameKey];
          const sourceFolderName = MiaoPluginMBT.paths.sourceFolders[GameKey];
          if (!sourceFolderName || GameKey === 'gallery') continue;
          const gameFolderPath = path.join(Repo.path, sourceFolderName);
          try {
            await fsPromises.access(gameFolderPath);
            const characterDirs = await fsPromises.readdir(gameFolderPath, { withFileTypes: true });
            for (const charDir of characterDirs) {
              if (charDir.isDirectory()) {
                const characterName = charDir.name;
                const charFolderPath = path.join(gameFolderPath, characterName);
                let imageCountInCharDir = 0;
                try {
                  await fsPromises.access(charFolderPath);
                  const imageFiles = await fsPromises.readdir(charFolderPath, { withFileTypes: true });
                  for (const imageFile of imageFiles) {
                    const supportedScanExt = ['.jpg', '.png', '.jpeg', '.webp', '.bmp'];
                    if (imageFile.isFile() && supportedScanExt.includes(path.extname(imageFile.name).toLowerCase())) {
                      imageCountInCharDir++;
                      const imagePath = path.join(charFolderPath, imageFile.name);
                      try {
                        const fileStat = await fsPromises.stat(imagePath);
                        ScannedGameSizes[GameName] = (ScannedGameSizes[GameName] || 0) + fileStat.size;
                      } catch (statErr) {}
                    }
                  }
                } catch (readCharErr) {}
                if (imageCountInCharDir > 0) {
                  ScannedRoleImageCounts[GameName][characterName] =
                    (ScannedRoleImageCounts[GameName][characterName] || 0) + imageCountInCharDir;
                }
              }
            }
          } catch (accessGameErr) {}
        }
      }

      const scanResult = stats.scan;
      scanResult.totalGitSize = totalGitSizeScan;
      scanResult.totalGitSizeFormatted = FormatBytes(totalGitSizeScan);

      Object.values(GameFoldersMap).forEach(GameName => {
        const rolesInGame = ScannedRoleImageCounts[GameName] || {};
        const roleNames = Object.keys(rolesInGame);
        const roleCount = roleNames.length;
        let gameImageCount = 0;
        roleNames.forEach(roleName => { gameImageCount += rolesInGame[roleName] || 0; });
        scanResult.gameRoles[GameName] = roleCount;
        scanResult.gameImages[GameName] = gameImageCount;
        scanResult.roles += roleCount;
        scanResult.images += gameImageCount;
        const gameSizeBytes = ScannedGameSizes[GameName] || 0;
        scanResult.gameSizes[GameName] = gameSizeBytes;
        scanResult.gameSizesFormatted[GameName] = FormatBytes(gameSizeBytes);
        scanResult.totalFilesSize += gameSizeBytes;
      });

      scanResult.totalSize = scanResult.totalFilesSize + scanResult.totalGitSize;
      scanResult.totalFilesSizeFormatted = FormatBytes(scanResult.totalFilesSize);
      scanResult.totalSizeFormatted = FormatBytes(scanResult.totalSize);
      this.logger.info(
        `${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] Êú¨Âú∞Êâ´Êèè: ${scanResult.roles}ËßíËâ≤, ${scanResult.images}ÂõæÁâá, Êñá‰ª∂ ${scanResult.totalFilesSizeFormatted}, ÊÄª ${scanResult.totalSizeFormatted}`
      );

      // ËÆ°ÁÆóÂêÑ‰ªìÂ∫ìÊÄªÂç†Áî®ÂíåÊñá‰ª∂Âç†Áî® 
      for (const repoNum in stats.repos) {
        if (stats.repos[repoNum].exists) {
          try {
            const repoTotalSize = await FolderSize(RepoStatsScan[repoNum].path);
            const repoGitSize = stats.repos[repoNum].gitSize;
            stats.repos[repoNum].size = repoTotalSize;
            stats.repos[repoNum].filesSize = Math.max(0, repoTotalSize - repoGitSize);
            stats.repos[repoNum].sizeFormatted = FormatBytes(repoTotalSize);
            stats.repos[repoNum].filesSizeFormatted = FormatBytes(stats.repos[repoNum].filesSize);
          } catch (finalSizeError) {
            this.logger.error(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ËÆ°ÁÆó‰ªìÂ∫ì ${repoNum} ÊÄªÂç†Áî®Â§ßÂ∞èÂ§±Ë¥•:`, finalSizeError);
            stats.repos[repoNum].sizeFormatted = 'ÈîôËØØ';
            stats.repos[repoNum].filesSizeFormatted = 'ÈîôËØØ';
          }
        }
      }

      const repoCount = Object.values(stats.repos || {}).filter(repo => repo?.exists).length;
      const renderData = {
          pluginVersion,
          stats,
          config: configForRender, // ‰ΩøÁî®Â§ÑÁêÜËøáÁöÑÈÖçÁΩÆÂØπË±°
          repoCount
      };
      const scaleStyleValue = MiaoPluginMBT.getScaleStyleValue();

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, { recursive: true });
      await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, { recursive: true });
      const sourceHtmlPath = path.join(MiaoPluginMBT.paths.commonResPath, 'html', 'status.html');

      tempHtmlFilePath = path.join(
        MiaoPluginMBT.paths.tempHtmlPath,
        `status-${Date.now()}-${Math.random().toString(16).slice(2)}.html`
      );
      tempImgFilePath = path.join(
        MiaoPluginMBT.paths.tempImgPath,
        `status-${Date.now()}-${Math.random().toString(16).slice(2)}.png`
      );

      await fsPromises.copyFile(sourceHtmlPath, tempHtmlFilePath);

      this.logger.info(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ÂºÄÂßãË∞ÉÁî® Puppeteer ÁîüÊàêÁä∂ÊÄÅÊä•ÂëäÊà™Âõæ...`);
      const img = await puppeteer.screenshot('guguniu-status', {
        tplFile: tempHtmlFilePath,
        savePath: tempImgFilePath,
        imgType: 'png',
        pageGotoParams: { waitUntil: 'networkidle0' },
        ...renderData, 
        scaleStyleValue: scaleStyleValue, 
        screenshotOptions: { fullPage: false }, 
        pageBoundingRect: { selector: '.container', padding: 0 }, 
        width: 540, 
      });

      if (img) {
        await e.reply(img);
        this.logger.info(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] Áä∂ÊÄÅÊä•ÂëäÂõæÁâáÂ∑≤ÂèëÈÄÅ„ÄÇ`);
      } else {
        this.logger.error(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] Puppeteer Êú™ËÉΩÊàêÂäüÁîüÊàêÂõæÁâá„ÄÇ`);
        await e.reply('ÁîüÊàêÁä∂ÊÄÅÊä•ÂëäÂõæÁâáÂ§±Ë¥• (Êà™ÂõæÁéØËäÇÂá∫Èîô)ÔºåËØ∑Êü•ÁúãÊó•Âøó„ÄÇ');
      }
    } catch (error) {
      this.logger.error(`${this.logPrefix} [Ê£ÄÊü•Áä∂ÊÄÅ] ÁîüÊàêÁä∂ÊÄÅÊä•ÂëäÊó∂ÂèëÁîü‰∏•ÈáçÈîôËØØ:`, error);
      await this.ReportError(e, 'ÁîüÊàêÁä∂ÊÄÅÊä•ÂëäÂõæÁâá', error);
    } finally {
      if (tempHtmlFilePath) {
        try { await fsPromises.unlink(tempHtmlFilePath); } catch (unlinkErr) {}
      }
      if (tempImgFilePath) {
        try { await fsPromises.unlink(tempImgFilePath); } catch (unlinkErr) {}
      }
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂêØÁî®/Á¶ÅÁî®ÂíïÂíïÁâõ ÂëΩ‰ª§„ÄÇ
   *              Áªü‰∏Ä‰∫§‰∫íÈÄªËæëÔºå‰ºòÂÖàÂèëÈù¢ÊùøÔºåÂ§±Ë¥•ÂÜçÂèëÊñáÂ≠ó„ÄÇ
   */
  async ManageTuKuOption(e) {
    const logger = this.logger;
    const logPrefix = this.logPrefix;
    // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ËøõÂÖ• ManageTuKuOption ÂáΩÊï∞`);

    if (!(await this.CheckInit(e))) {
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] CheckInit ËøîÂõû falseÔºåÈÄÄÂá∫„ÄÇ`);
      return true;
    }
    if (!e.isMaster) {
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] Èùû MasterÔºåÈÄÄÂá∫„ÄÇ`);
      return e.reply(`${logPrefix} Âè™Êúâ‰∏ª‰∫∫ÊâçËÉΩÂºÄÂÖ≥ÂõæÂ∫ìÂï¶~`);
    }

    const match = e.msg.match(/^#(ÂêØÁî®|Á¶ÅÁî®)ÂíïÂíïÁâõ$/i);
    if (!match) {
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] Ê≠£Âàô‰∏çÂåπÈÖçÔºåÈÄÄÂá∫„ÄÇ`);
      return false;
    }

    const action = match[1];
    const enable = action === "ÂêØÁî®";
    let configChanged = false;
    let asyncError = null;
    let saveWarning = "";

    // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ËØ∑Ê±ÇÂä®‰Ωú: ${action}`);
    // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] Â∞ùËØïËé∑ÂèñÈÖçÁΩÆÈîÅ...`);
    await MiaoPluginMBT.configMutex.acquire();
    // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] Â∑≤Ëé∑ÂèñÈÖçÁΩÆÈîÅ„ÄÇ`);
    try {
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] Âä†ËΩΩÊúÄÊñ∞ÈÖçÁΩÆ...`);
      await MiaoPluginMBT.LoadTuKuConfig(true, logger);
      const currentStatus =
        MiaoPluginMBT.MBTConfig.TuKuOP ?? Default_Config.defaultTuKuOp;
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ÂΩìÂâçÁä∂ÊÄÅ: ${currentStatus}, ËØ∑Ê±ÇÁä∂ÊÄÅ: ${enable}`);

      if (currentStatus === enable) {
        logger.info(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] Áä∂ÊÄÅÊú™ÂèòÔºåÂ∞ùËØïÊòæÁ§∫Èù¢Êùø„ÄÇ`);
        try {
          await this.ShowSettingsPanel(e, `ÂõæÂ∫ìÂ∑≤ÁªèÊòØ„Äå${action}„ÄçÁä∂ÊÄÅ‰∫Ü„ÄÇ`);
        } catch (panelError) {
          logger.error(
            `${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ÊòæÁ§∫ÂΩìÂâçÁä∂ÊÄÅÈù¢ÊùøÂ§±Ë¥•ÔºåÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ:`,
            panelError
          );
          await e.reply(
            `${logPrefix} ÂõæÂ∫ìÂ∑≤ÁªèÊòØ„Äå${action}„ÄçÁä∂ÊÄÅ‰∫ÜÔºåÊó†ÈúÄÊõ¥Êîπ„ÄÇ`,
            true
          );
        }
        MiaoPluginMBT.configMutex.release();
        // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (Áä∂ÊÄÅÊú™ÂèòË∑ØÂæÑ)„ÄÇ`);
        return true;
      }

      MiaoPluginMBT.MBTConfig.TuKuOP = enable;
      configChanged = true;
      logger.info(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ÂÜÖÂ≠òÁä∂ÊÄÅÂèòÊõ¥‰∏∫ -> ${enable}`);

      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] Â∞ùËØï‰øùÂ≠òÈÖçÁΩÆ...`);
      const saveSuccess = await MiaoPluginMBT.SaveTuKuConfig(
        MiaoPluginMBT.MBTConfig,
        logger
      );
      if (!saveSuccess) {
        saveWarning = "‚ö†Ô∏è ÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•ÔºÅËÆæÁΩÆÂèØËÉΩ‰∏ç‰ºöÊåÅ‰πÖÁîüÊïà„ÄÇ";
        MiaoPluginMBT.MBTConfig.TuKuOP = !enable;
        configChanged = false;
        logger.error(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ‰øùÂ≠òÂ§±Ë¥•ÔºåÂÜÖÂ≠òÁä∂ÊÄÅÂ∑≤ÂõûÊªö„ÄÇ`);
        await this.ReportError(
          e,
          `${action}ÂíïÂíïÁâõ`,
          new Error("‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•"),
          saveWarning
        );
        MiaoPluginMBT.configMutex.release();
        // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (‰øùÂ≠òÂ§±Ë¥•Ë∑ØÂæÑ)„ÄÇ`);
        return true;
      }
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ÈÖçÁΩÆ‰øùÂ≠òÊàêÂäü„ÄÇ`);
    } catch (configError) {
      logger.error(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] Â§ÑÁêÜÈÖçÁΩÆÊó∂Âá∫Èîô:`, configError);
      await this.ReportError(
        e,
        `${action}ÂíïÂíïÁâõ`,
        configError,
        "Â§ÑÁêÜÈÖçÁΩÆÊó∂Âá∫Èîô"
      );
      MiaoPluginMBT.configMutex.release();
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (ÈÖçÁΩÆÂ§ÑÁêÜÈîôËØØË∑ØÂæÑ)„ÄÇ`);
      return true;
    } finally {
      MiaoPluginMBT.configMutex.release();
      // logger.debug(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (finally Âùó)„ÄÇ`);
    }

    if (configChanged) {
      try {
        logger.info(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ÂºÄÂßãÊâßË°åÂêéÂè∞Êìç‰Ωú...`);
        if (enable) {
          await MiaoPluginMBT.SyncCharacterFolders(logger);
          await MiaoPluginMBT.GenerateAndApplyBanList(
            MiaoPluginMBT._imgDataCache,
            logger
          );
        } else {
          await MiaoPluginMBT.CleanTargetCharacterDirs(
            MiaoPluginMBT.paths.target.miaoChar,
            logger
          );
          await MiaoPluginMBT.CleanTargetCharacterDirs(
            MiaoPluginMBT.paths.target.zzzChar,
            logger
          );
          await MiaoPluginMBT.CleanTargetCharacterDirs(
            MiaoPluginMBT.paths.target.wavesChar,
            logger
          );
        }
        logger.info(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ÂêéÂè∞Êìç‰ΩúÂÆåÊàê„ÄÇ`);
      } catch (error) {
        asyncError = error;
        logger.error(`${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ÂêéÂè∞Êìç‰ΩúÂ§±Ë¥•:`, error);
        await this.ReportError(e, `${action}ÂíïÂíïÁâõ (ÂêéÂè∞Êìç‰Ωú)`, error);
      }
    }

    let panelSent = false;
    try {
      let extraPanelMsg = "";
      if (asyncError)
        extraPanelMsg += `\n(ÂêéÂè∞${
          action === "ÂêØÁî®" ? "ÂêåÊ≠•" : "Ê∏ÖÁêÜ"
        }Êó∂ÈÅáÂà∞ÈóÆÈ¢ò)`;
      if (saveWarning) extraPanelMsg += `\n${saveWarning}`;
      await this.ShowSettingsPanel(e, extraPanelMsg.trim());
      panelSent = true;
    } catch (panelError) {
      logger.error(
        `${logPrefix} [ÂêØÁî®Á¶ÅÁî®] ÊòæÁ§∫ËÆæÁΩÆÈù¢ÊùøÂ§±Ë¥•ÔºåÂ∞ÜÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ:`,
        panelError
      );
      panelSent = false;
      let finalUserMessage = `${logPrefix} ÂõæÂ∫ìÂ∑≤ÊàêÂäüËÆæ‰∏∫„Äå${action}„ÄçÔºå‰ΩÜÈù¢ÊùøÂõæÁâáÂèëÈÄÅÂ§±Ë¥•„ÄÇ`;
      if (asyncError)
        finalUserMessage += `\n(ÂêéÂè∞${
          enable ? "ÂêåÊ≠•" : "Ê∏ÖÁêÜ"
        }Êó∂ÈÅáÂà∞ÈóÆÈ¢òÔºåËØ¶ËßÅÊó•Âøó)`;
      if (saveWarning) finalUserMessage += `\n${saveWarning}`;
      await e.reply(finalUserMessage, true);
    }

    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂíïÂíïÁâõ ÂëΩ‰ª§ÔºåÊòæÁ§∫Êèí‰ª∂ÁâàÊú¨„ÄÅÂÆâË£ÖÊó∂Èó¥ÂíåÁ≥ªÁªü‰ø°ÊÅØ„ÄÇ
   */
  async PluginInfo(e) {
    if (!(await this.CheckInit(e))) return true;

    const version = MiaoPluginMBT.GetVersionStatic();
    await e.reply(`üêÇ ${this.logPrefix} ${version} Ê≠£Âú®ËøêË°å‰∏≠...`);

    let installTimeRepo1 = "Êú™ÂÆâË£Ö",
      installTimeRepo2 = "Êú™ÈÖçÁΩÆ",
      installTimeRepo3 = "Êú™ÈÖçÁΩÆ";
    let Repo1Exists = false,
      Repo2Exists = false,
      Repo3Exists = false;

    try {
      const stats1 = await fsPromises
        .stat(MiaoPluginMBT.paths.LocalTuKuPath)
        .catch(() => null);
      if (stats1) {
        installTimeRepo1 = stats1.ctime.toLocaleString("zh-CN", {
          timeZone: "Asia/Shanghai",
        });
        Repo1Exists = true;
      }
    } catch {}

    const Repo2UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Ass_Github_URL;
    if (Repo2UrlConfigured) {
      installTimeRepo2 = "Â∑≤ÈÖçÁΩÆ‰ΩÜÊú™‰∏ãËΩΩ";
      try {
        const stats2 = await fsPromises
          .stat(MiaoPluginMBT.paths.LocalTuKuPath2)
          .catch(() => null);
        if (stats2) {
          installTimeRepo2 = stats2.ctime.toLocaleString("zh-CN", {
            timeZone: "Asia/Shanghai",
          });
          Repo2Exists = true;
        } else if (await MiaoPluginMBT.IsTuKuDownloaded(2)) {
          Repo2Exists = true;
          installTimeRepo2 = "Â∑≤‰∏ãËΩΩ (Êó†Ê≥ïËé∑ÂèñÊó∂Èó¥)";
        }
      } catch {}
    }

    const Repo3UrlConfigured = !!MiaoPluginMBT.MBTConfig?.Sexy_Github_URL;
    if (Repo3UrlConfigured) {
      installTimeRepo3 = "Â∑≤ÈÖçÁΩÆ‰ΩÜÊú™‰∏ãËΩΩ";
      try {
        const stats3 = await fsPromises
          .stat(MiaoPluginMBT.paths.LocalTuKuPath3)
          .catch(() => null);
        if (stats3) {
          installTimeRepo3 = stats3.ctime.toLocaleString("zh-CN", {
            timeZone: "Asia/Shanghai",
          });
          Repo3Exists = true;
        } else if (await MiaoPluginMBT.IsTuKuDownloaded(3)) {
          Repo3Exists = true;
          installTimeRepo3 = "Â∑≤‰∏ãËΩΩ (Êó†Ê≥ïËé∑ÂèñÊó∂Èó¥)";
        }
      } catch {}
    }

    await e.reply(
      `> ‰∏ÄÂè∑‰ªìÂ∫ìÂÆâË£ÖÊó∂Èó¥: ${installTimeRepo1}\n> ‰∫åÂè∑‰ªìÂ∫ìÁä∂ÊÄÅ: ${installTimeRepo2}\n> ‰∏âÂè∑‰ªìÂ∫ìÁä∂ÊÄÅ: ${installTimeRepo3}`
    );

    let logMessages = [];

    if (Repo1Exists) {
      const gitLog1 = await MiaoPluginMBT.GetTuKuLog(
        50,
        MiaoPluginMBT.paths.LocalTuKuPath,
        this.logger
      );
      if (gitLog1) {
        logMessages.push(`--- ‰∏ÄÂè∑‰ªìÂ∫ìÊúÄËøë 50 Êù°Êõ¥Êñ∞ËÆ∞ÂΩï ---\n${gitLog1}`);
      } else {
        logMessages.push("--- Êó†Ê≥ïËé∑Âèñ‰∏ÄÂè∑‰ªìÂ∫ìÊó•Âøó ---");
      }
    } else {
      logMessages.push("--- ‰∏ÄÂè∑‰ªìÂ∫ìÊú™‰∏ãËΩΩ ---");
    }

    if (Repo2Exists) {
      const gitLog2 = await MiaoPluginMBT.GetTuKuLog(
        50,
        MiaoPluginMBT.paths.LocalTuKuPath2,
        this.logger
      );
      if (gitLog2) {
        logMessages.push(`--- ‰∫åÂè∑‰ªìÂ∫ìÊúÄËøë 50 Êù°Êõ¥Êñ∞ËÆ∞ÂΩï ---\n${gitLog2}`);
      } else {
        logMessages.push("--- Êó†Ê≥ïËé∑Âèñ‰∫åÂè∑‰ªìÂ∫ìÊó•Âøó ---");
      }
    } else if (Repo2UrlConfigured) {
      logMessages.push("--- ‰∫åÂè∑‰ªìÂ∫ìÂ∑≤ÈÖçÁΩÆ‰ΩÜÊú™‰∏ãËΩΩ ---");
    }

    if (Repo3Exists) {
      Ëé∑Âèñ;
      const gitLog3 = await MiaoPluginMBT.GetTuKuLog(
        50,
        MiaoPluginMBT.paths.LocalTuKuPath3,
        this.logger
      );
      if (gitLog3) {
        logMessages.push(`--- ‰∏âÂè∑‰ªìÂ∫ìÊúÄËøë 50 Êù°Êõ¥Êñ∞ËÆ∞ÂΩï ---\n${gitLog3}`);
      } else {
        logMessages.push("--- Êó†Ê≥ïËé∑Âèñ‰∏âÂè∑‰ªìÂ∫ìÊó•Âøó ---");
      }
    } else if (Repo3UrlConfigured) {
      logMessages.push("--- ‰∏âÂè∑‰ªìÂ∫ìÂ∑≤ÈÖçÁΩÆ‰ΩÜÊú™‰∏ãËΩΩ ---");
    }

    if (logMessages.length > 0) {
      try {
        const forwardMsg = await common.makeForwardMsg(
          e,
          logMessages,
          "„ÄéÂíïÂíïÁâõüêÇ„Äè‰ªìÂ∫ìÊó•Âøó"
        );
        if (forwardMsg) await e.reply(forwardMsg);
        else await e.reply("ÁîüÊàê‰ªìÂ∫ìÊó•ÂøóÊ∂àÊÅØÂ§±Ë¥•„ÄÇ");
      } catch (fwdErr) {
        this.logger.error(`${this.logPrefix} ÂàõÂª∫Êó•ÂøóËΩ¨ÂèëÊ∂àÊÅØÂ§±Ë¥•:`, fwdErr);
        await e.reply("ÂèëÈÄÅ‰ªìÂ∫ìÊó•ÂøóÊó∂Âá∫Èîô„ÄÇ");
      }
    }

    let systemInfo = "";
    try {
      const platform = `${os.platform()} ${os.arch()}`;
      const nodeVersion = process.version;
      const memUsage = process.memoryUsage();
      const usedMB = (memUsage.rss / 1024 / 1024).toFixed(1);
      let yunzaiVersion = "Êú™Áü•";
      try {
        const pkgPath = path.join(
          MiaoPluginMBT.paths.YunzaiPath,
          "package.json"
        );
        const pkg = JSON.parse(await fsPromises.readFile(pkgPath, "utf-8"));
        yunzaiVersion = pkg.version || "Êú™Áü•";
      } catch {}

      systemInfo = [
        `--- ËøêË°åÁéØÂ¢É ---`,
        `Á≥ªÁªü: ${platform}`,
        `Node.js: ${nodeVersion}`,
        `Yunzai-Bot: ${yunzaiVersion}`,
        `ÂíïÂíïÁâõÊèí‰ª∂: ${version}`,
        `ÂÜÖÂ≠òÂç†Áî®: ${usedMB} MB`,
      ].join("\n");
    } catch (sysErr) {
      this.logger.warn(`${this.logPrefix} Ëé∑ÂèñÁ≥ªÁªü‰ø°ÊÅØÂ§±Ë¥•:`, sysErr);
      systemInfo = "Ëé∑ÂèñÁ≥ªÁªü‰ø°ÊÅØÂ§±Ë¥•‰∫Ü...";
    }
    await e.reply(systemInfo);

    return true;
  }

  /**
   * @description Â§ÑÁêÜÂ∞ÅÁ¶ÅÁõ∏ÂÖ≥ÂëΩ‰ª§ (#ÂíïÂíïÁâõÂ∞ÅÁ¶Å, #ÂíïÂíïÁâõËß£Á¶Å, #banÂàóË°®)„ÄÇ
   *              ÁÆÄÂåñ PFL Ê†áËÆ∞‰∏∫ [ÂáÄÂåñ]„ÄÇ
   */
  async ManageUserBans(e) {
    if (!(await this.CheckInit(e))) return true;
    const msg = e.msg.trim();
    const isMaster = e.isMaster;
    const logPrefix = this.logPrefix;
    const logger = this.logger;

    if (
      (msg.startsWith("#ÂíïÂíïÁâõÂ∞ÅÁ¶Å ") || msg.startsWith("#ÂíïÂíïÁâõËß£Á¶Å ")) &&
      !isMaster
    )
      return e.reply(`${logPrefix} Âè™Êúâ‰∏ª‰∫∫ÊâçËÉΩËøõË°åÂ∞ÅÁ¶ÅÊàñËß£Á¶ÅÊìç‰ΩúÂì¶~`);

    //  Â§ÑÁêÜ #banÂàóË°® Êàñ #ÂíïÂíïÁâõÂ∞ÅÁ¶ÅÂàóË°® 
    if (msg === "#banÂàóË°®" || msg === "#ÂíïÂíïÁâõÂ∞ÅÁ¶ÅÂàóË°®") {
      const activeBanCount = MiaoPluginMBT._activeBanSet.size;
      const userBanCount = MiaoPluginMBT._userBanSet.size;
      const currentPFL = MiaoPluginMBT.MBTConfig?.PFL ?? Purify_Level.NONE;
      const config = MiaoPluginMBT.MBTConfig;

      if (activeBanCount === 0) {
        return e.reply("ÂΩìÂâçÊ≤°Êúâ‰ªª‰ΩïÂõæÁâáË¢´Â∞ÅÁ¶Å„ÄÇ", true);
      }

      await e.reply(`Ê≠£Âú®Êï¥ÁêÜÂàóË°®ÔºåÂèØËÉΩÈúÄË¶Å‰∏ÄÁÇπÊó∂Èó¥...`, true);

      const purifiedBansData = [];
      const userBansData = [];
      const pluginVersion = MiaoPluginMBT.GetVersionStatic();

      const sortedActiveBans = Array.from(MiaoPluginMBT._activeBanSet).sort();
      await Promise.all(
        sortedActiveBans.map(async (relativePath) => {
          const fileName = path.basename(relativePath);
          const fileNameNoExt = fileName.replace(/\.webp$/i, "");
          const absolutePath = await MiaoPluginMBT.FindImageAbsolutePath(
            relativePath
          );
          const thumbnailPath = absolutePath
            ? `file://${absolutePath.replace(/\\/g, "/")}`
            : "";

          if (MiaoPluginMBT._userBanSet.has(relativePath)) {
            userBansData.push({ fileNameNoExt, thumbnailPath });
          } else {
            const imgData = MiaoPluginMBT._imgDataCache.find(
              (img) => img.path?.replace(/\\/g, "/") === relativePath
            );
            const reasons = [];

            if (
              imgData &&
              currentPFL > Purify_Level.NONE &&
              MiaoPluginMBT.CheckIfPurifiedByLevel(imgData, currentPFL)
            ) {
              reasons.push("ÂáÄÂåñ");
            }

            if (imgData?.attributes) {
              const attrs = imgData.attributes;
              if (config?.Ai === false && attrs.isAiImage === true)
                reasons.push("Ai");
              if (config?.EasterEgg === false && attrs.isEasterEgg === true)
                reasons.push("ÂΩ©Ëõã");
              if (config?.layout === false && attrs.layout === "fullscreen")
                reasons.push("Ê®™Â±è");
            }

            if (reasons.length === 0) {
              reasons.push("Êú™Áü•");
              logger.warn(
                `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÂõæÁâá ${relativePath} Âú®ÁîüÊïàÂàóË°®‰ΩÜÊú™ÊâæÂà∞ÊòéÁ°ÆÂ±èËîΩÂéüÂõ†?`
              );
            }

            purifiedBansData.push({ fileNameNoExt, thumbnailPath, reasons });
          }
        })
      );

      let manualSent = false;
      const sourceHtmlPath = path.join(
        MiaoPluginMBT.paths.commonResPath,
        "html",
        "banlist.html"
      );
      const scaleStyleValue = MiaoPluginMBT.getScaleStyleValue();

      if (userBansData.length > 0) {
        logger.info(
          `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÂáÜÂ§áÁîüÊàêÊâãÂä®ÂàóË°®ÂõæÁâá (${userBansData.length}È°π)...`
        );
        let tempHtmlFilePathManual = "";
        let tempImgFilePathManual = "";
        try {
          const renderDataManual = {
            pluginVersion: pluginVersion,
            purifiedBans: [],
            userBans: userBansData,
            listType: "ÊâãÂä®Â∞ÅÁ¶Å",
            scaleStyleValue: scaleStyleValue,
            batchInfo: "",
          };
          await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, {
            recursive: true,
          });
          await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, {
            recursive: true,
          });
          const timestampManual = Date.now();
          tempHtmlFilePathManual = path.join(
            MiaoPluginMBT.paths.tempHtmlPath,
            `banlist-manual-${timestampManual}.html`
          );
          tempImgFilePathManual = path.join(
            MiaoPluginMBT.paths.tempImgPath,
            `banlist-manual-${timestampManual}.png`
          );
          await fsPromises.copyFile(sourceHtmlPath, tempHtmlFilePathManual);
          const img = await puppeteer.screenshot("guguniu-banlist-manual", {
            tplFile: tempHtmlFilePathManual,
            savePath: tempImgFilePathManual,
            imgType: "png",
            pageGotoParams: { waitUntil: "networkidle0" },
            ...renderDataManual,
            screenshotOptions: { fullPage: true },
            width: 640,
          });
          if (img) {
            await e.reply(img);
            manualSent = true;
            logger.info(`${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÊâãÂä®Â∞ÅÁ¶ÅÂàóË°®ÂõæÁâáÂ∑≤ÂèëÈÄÅ„ÄÇ`);
            if (purifiedBansData.length > 0) {
              await common.sleep(1000);
            }
          } else {
            logger.error(`${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÁîüÊàêÊâãÂä®ÂàóË°®Êà™ÂõæÂ§±Ë¥•„ÄÇ`);
          }
        } catch (renderError) {
          logger.error(
            `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÁîüÊàêÊâãÂä®ÂàóË°®Êà™ÂõæÊó∂Âá∫Èîô:`,
            renderError
          );
          await this.ReportError(e, "ÁîüÊàêÊâãÂä®Â∞ÅÁ¶ÅÂàóË°®", renderError);
        } finally {
          if (tempHtmlFilePathManual && fs.existsSync(tempHtmlFilePathManual)) {
            try {
              await fsPromises.unlink(tempHtmlFilePathManual);
            } catch (unlinkErr) {}
          }
          if (tempImgFilePathManual && fs.existsSync(tempImgFilePathManual)) {
            try {
              await fsPromises.unlink(tempImgFilePathManual);
            } catch (unlinkErr) {}
          }
        }
      } else {
        logger.info(`${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] Êó†ÊâãÂä®Â∞ÅÁ¶ÅÈ°π„ÄÇ`);
      }

      if (purifiedBansData.length > 0) {
        logger.info(
          `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] Ê£ÄÊµãÂà∞ ${purifiedBansData.length} È°πËá™Âä®Â±èËîΩÈ°πÔºåÂºÄÂßãÂàÜÊâπÂ§ÑÁêÜ...`
        );
        const ITEMS_PER_BATCH = 28;
        const totalItemsPurified = purifiedBansData.length;
        const totalBatchesPurified = Math.ceil(
          totalItemsPurified / ITEMS_PER_BATCH
        );
        const forwardListPurified = [];
        const forwardTitle = `[Ëá™Âä®Â±èËîΩÂàóË°® (ÂÖ± ${totalItemsPurified} È°π)]`;
        forwardListPurified.push([forwardTitle]);

        for (let batchNum = 1; batchNum <= totalBatchesPurified; batchNum++) {
          const startIndex = (batchNum - 1) * ITEMS_PER_BATCH;
          const endIndex = Math.min(
            startIndex + ITEMS_PER_BATCH,
            totalItemsPurified
          );
          const currentBatchData = purifiedBansData.slice(startIndex, endIndex);
          logger.info(
            `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÂáÜÂ§áÁîüÊàêËá™Âä®Â±èËîΩÂàóË°®Á¨¨ ${batchNum}/${totalBatchesPurified} Êâπ (${currentBatchData.length} È°π)...`
          );
          let tempHtmlFilePathPurified = "";
          let tempImgFilePathPurified = "";
          const timestampPurified = `${Date.now()}-batch${batchNum}`;
          try {
            const renderDataPurifiedBatch = {
              pluginVersion: pluginVersion,
              purifiedBans: currentBatchData,
              userBans: [],
              listType: "Ëá™Âä®Â±èËîΩ",
              scaleStyleValue: scaleStyleValue,
              batchInfo: `(Á¨¨ ${batchNum} / ${totalBatchesPurified} Êâπ)`,
            };
            await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, {
              recursive: true,
            });
            await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, {
              recursive: true,
            });
            tempHtmlFilePathPurified = path.join(
              MiaoPluginMBT.paths.tempHtmlPath,
              `banlist-auto-${timestampPurified}.html`
            );
            tempImgFilePathPurified = path.join(
              MiaoPluginMBT.paths.tempImgPath,
              `banlist-auto-${timestampPurified}.png`
            );
            await fsPromises.copyFile(sourceHtmlPath, tempHtmlFilePathPurified);
            const imgBatch = await puppeteer.screenshot(
              `guguniu-banlist-auto-batch${batchNum}`,
              {
                tplFile: tempHtmlFilePathPurified,
                savePath: tempImgFilePathPurified,
                imgType: "png",
                pageGotoParams: { waitUntil: "networkidle0" },
                ...renderDataPurifiedBatch,
                screenshotOptions: { fullPage: true },
                width: 640,
              }
            );
            if (imgBatch) {
              forwardListPurified.push(imgBatch);
              logger.info(
                `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] Ëá™Âä®Â±èËîΩÂàóË°®Á¨¨ ${batchNum}/${totalBatchesPurified} ÊâπÂõæÁâáÁîüÊàêÊàêÂäü„ÄÇ`
              );
            } else {
              logger.error(
                `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÁîüÊàêËá™Âä®Â±èËîΩÂàóË°®Á¨¨ ${batchNum}/${totalBatchesPurified} ÊâπÊà™ÂõæÂ§±Ë¥•„ÄÇ`
              );
              forwardListPurified.push(
                `[‚ùå Á¨¨ ${batchNum}/${totalBatchesPurified} ÊâπÊ∏≤ÊüìÂ§±Ë¥•]`
              );
            }
          } catch (renderBatchError) {
            logger.error(
              `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÁîüÊàêËá™Âä®Â±èËîΩÂàóË°®Á¨¨ ${batchNum}/${totalBatchesPurified} ÊâπÊà™ÂõæÊó∂Âá∫Èîô:`,
              renderBatchError
            );
            forwardListPurified.push(
              `[‚ùå Á¨¨ ${batchNum}/${totalBatchesPurified} ÊâπÂ§ÑÁêÜÂá∫Èîô]`
            );
            await this.ReportError(
              e,
              `ÁîüÊàêËá™Âä®Â±èËîΩÂàóË°® (ÊâπÊ¨° ${batchNum})`,
              renderBatchError
            );
          } finally {
            if (
              tempHtmlFilePathPurified &&
              fs.existsSync(tempHtmlFilePathPurified)
            ) {
              try {
                await fsPromises.unlink(tempHtmlFilePathPurified);
              } catch (unlinkErr) {}
            }
            if (
              tempImgFilePathPurified &&
              fs.existsSync(tempImgFilePathPurified)
            ) {
              try {
                await fsPromises.unlink(tempImgFilePathPurified);
              } catch (unlinkErr) {}
            }
          }
        }

        if (forwardListPurified.length > 1) {
          try {
            const forwardMsgPurified = await common.makeForwardMsg(
              e,
              forwardListPurified,
              "Ëá™Âä®Â±èËîΩÂàóË°®ËØ¶ÊÉÖ"
            );
            if (forwardMsgPurified) {
              await e.reply(forwardMsgPurified);
              logger.info(
                `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÂêàÂπ∂ÁöÑËá™Âä®Â±èËîΩÂàóË°®Ê∂àÊÅØÂ∑≤ÂèëÈÄÅ„ÄÇ`
              );
            } else {
              logger.error(
                `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÂàõÂª∫Ëá™Âä®Â±èËîΩÂàóË°®ÂêàÂπ∂Ê∂àÊÅØÂ§±Ë¥• (makeForwardMsg ËøîÂõûÁ©∫)„ÄÇ`
              );
              await e.reply(
                "ÁîüÊàêÂêàÂπ∂ÁöÑËá™Âä®Â±èËîΩÂàóË°®Ê∂àÊÅØÂ§±Ë¥• (ÂÜÖÈÉ®ÈîôËØØ)„ÄÇ",
                true
              );
            }
          } catch (sendForwardError) {
            logger.error(
              `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] ÂèëÈÄÅËá™Âä®Â±èËîΩÂàóË°®ÂêàÂπ∂Ê∂àÊÅØÂ§±Ë¥•:`,
              sendForwardError
            );
            await e.reply("ÂèëÈÄÅÂêàÂπ∂ÁöÑËá™Âä®Â±èËîΩÂàóË°®Ê∂àÊÅØÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊó•Âøó„ÄÇ", true);
          }
        } else {
          logger.warn(
            `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] Ëá™Âä®Â±èËîΩÂàóË°®Â§ÑÁêÜÂêé‰∏∫Á©∫ÔºåÊú™ÂèëÈÄÅÂêàÂπ∂Ê∂àÊÅØ„ÄÇ`
          );
          if (!manualSent) {
            await e.reply(
              "ÂΩìÂâçÊ≤°ÊúâÊâãÂä®Â∞ÅÁ¶ÅÔºå‰πüÊ≤°ÊúâË¢´Ëá™Âä®ËßÑÂàôÂ±èËîΩÁöÑÂõæÁâá„ÄÇ",
              true
            );
          }
        }
      } else {
        logger.info(
          `${logPrefix} [Â∞ÅÁ¶ÅÂàóË°®] Ê≤°ÊúâË¢´ PFL ÊàñÂÖ®Â±ÄÂºÄÂÖ≥Â±èËîΩÁöÑÂõæÁâá„ÄÇ`
        );
        if (!manualSent) {
          await e.reply("ÂΩìÂâçÊ≤°ÊúâÊâãÂä®Â∞ÅÁ¶ÅÔºå‰πüÊ≤°ÊúâË¢´Ëá™Âä®ËßÑÂàôÂ±èËîΩÁöÑÂõæÁâá„ÄÇ", true);
        }
      }

      if (
        userBansData.length > 0 &&
        !manualSent &&
        purifiedBansData.length === 0
      ) {
        await e.reply("ÁîüÊàêÊâãÂä®Â∞ÅÁ¶ÅÂàóË°®ÂõæÁâáÂ§±Ë¥•‰∫ÜÔºåËØ∑Ê£ÄÊü•Êó•Âøó„ÄÇ", true);
      }

      return true;
    }

    //  Â§ÑÁêÜ #ÂíïÂíïÁâõÂ∞ÅÁ¶Å / #ÂíïÂíïÁâõËß£Á¶Å 
    const addMatch = msg.match(/^#ÂíïÂíïÁâõÂ∞ÅÁ¶Å\s*(.+)/i);
    const delMatch = msg.match(/^#ÂíïÂíïÁâõËß£Á¶Å\s*(.+)/i);
    if (addMatch || delMatch) {
      const isAdding = !!addMatch;
      const targetIdentifierRaw = (isAdding ? addMatch[1] : delMatch[1]).trim();
      const actionVerb = isAdding ? "Â∞ÅÁ¶Å" : "Ëß£Á¶Å";
      if (!targetIdentifierRaw) {
        return e.reply(
          `Ë¶Å${actionVerb}Âì™‰∏™ÂõæÁâáÂëÄÔºüÊ†ºÂºèÔºö#ÂíïÂíïÁâõ${actionVerb}ËßíËâ≤Âêç+ÁºñÂè∑`,
          true
        );
      }
      const parsedId = MiaoPluginMBT.ParseRoleIdentifier(targetIdentifierRaw);
      if (!parsedId) {
        return e.reply("Ê†ºÂºèÂ•ΩÂÉè‰∏çÂØπÂì¶ÔºåÂ∫îËØ•ÊòØ ËßíËâ≤Âêç+ÁºñÂè∑", true);
      }
      const { mainName: rawMainName, imageNumber } = parsedId;
      const aliasResult = await MiaoPluginMBT.FindRoleAlias(
        rawMainName,
        logger
      );
      const standardMainName = aliasResult.exists
        ? aliasResult.mainName
        : rawMainName;
      const expectedFilenameLower = `${standardMainName.toLowerCase()}gu${imageNumber}.webp`;
      const imageData = MiaoPluginMBT._imgDataCache.find(
        (img) =>
          img.characterName === standardMainName &&
          img.path
            ?.toLowerCase()
            .replace(/\\/g, "/")
            .endsWith(`/${expectedFilenameLower}`)
      );
      if (!imageData || !imageData.path) {
        let hint = `(ÂèØËÉΩÂéüÂõ†ÔºöÁºñÂè∑‰∏çÂ≠òÂú®„ÄÅËßíËâ≤Âêç/Âà´ÂêçÊâìÈîô‰∫ÜÔºü)`;
        const roleExistsInData = MiaoPluginMBT._imgDataCache.some(
          (img) => img.characterName === standardMainName
        );
        if (!roleExistsInData) {
          hint = `(ÂõæÂ∫ìÈáåÂ•ΩÂÉèÊ≤°Êúâ '${standardMainName}' Ëøô‰∏™ËßíËâ≤Âì¶)`;
        } else {
          hint = `(ÊâæÂà∞‰∫ÜËßíËâ≤ '${standardMainName}'Ôºå‰ΩÜÊòØÊ≤°ÊúâÊâæÂà∞ÁºñÂè∑ ${imageNumber} ÁöÑÂõæÁâá)`;
        }
        return e.reply(
          `Âú®ÂõæÂ∫ìÊï∞ÊçÆÈáåÊ≤°ÊâæÂà∞Ëøô‰∏™ÂõæÁâá: ${standardMainName}Gu${imageNumber}„ÄÇ\n${hint}`,
          true
        );
      }
      const targetRelativePath = imageData.path.replace(/\\/g, "/");
      const targetFileName = path.basename(targetRelativePath);
      await this.PerformBanOperation(
        e,
        isAdding,
        targetRelativePath,
        targetFileName,
        actionVerb
      );
      return true;
    }

    return false;
  }

  /**
   * @description ÊâßË°åÂÖ∑‰ΩìÁöÑÂ∞ÅÁ¶ÅÊàñËß£Á¶ÅÊìç‰ΩúÔºåÊõ¥Êñ∞ÂÜÖÂ≠òÁä∂ÊÄÅ„ÄÅ‰øùÂ≠òÊñá‰ª∂Âπ∂Â∫îÁî®„ÄÇ
   *              ÁßªÈô§ banMutex ÈîÅ„ÄÇ
   */
  async PerformBanOperation(
    e,
    isAdding,
    targetRelativePath,
    targetFileName,
    actionVerb
  ) {
    const logger = this.logger;
    const logPrefix = this.logPrefix;
    let configChanged = false;
    let replyMsg = "";
    let saved = false;
    let needsRestore = false;

    try {
      const currentPFL =
        MiaoPluginMBT.MBTConfig?.PFL ?? Default_Config.defaultPfl;
      const imgData = MiaoPluginMBT._imgDataCache.find(
        (img) => img.path?.replace(/\\/g, "/") === targetRelativePath
      );

      if (
        currentPFL > Purify_Level.NONE &&
        imgData &&
        MiaoPluginMBT.CheckIfPurifiedByLevel(imgData, currentPFL)
      ) {
        replyMsg = `‚ö†Ô∏è ${targetFileName} ÂèóÂà∞ÂΩìÂâçÁöÑÂáÄÂåñËßÑÂàô (Á≠âÁ∫ß ${currentPFL}) Â±èËîΩÔºåÊó†Ê≥ïËøõË°åÊâãÂä®${actionVerb}Êìç‰Ωú„ÄÇ`;
        logger.warn(
          `${logPrefix} [${actionVerb}] Êìç‰ΩúË¢´ÈòªÊ≠¢ÔºåÂõ†‰∏∫ÂõæÁâá ${targetFileName} Ë¢´ PFL ${currentPFL} Â±èËîΩ„ÄÇ`
        );
        await e.reply(replyMsg, true);
        return;
      }

      const isCurrentlyUserBanned =
        MiaoPluginMBT._userBanSet.has(targetRelativePath);

      if (isAdding) {
        if (isCurrentlyUserBanned) {
          replyMsg = `${targetFileName} ‚ùåÔ∏è Â∑≤ÁªèË¢´‰Ω†ÊâãÂä®Â∞ÅÁ¶ÅÂï¶„ÄÇ`;
        } else {
          try {
            MiaoPluginMBT._userBanSet.add(targetRelativePath);
            configChanged = true;
            logger.info(
              `${logPrefix} [${actionVerb}] Ê∑ªÂä†Âà∞ÂÜÖÂ≠òÂ∞ÅÁ¶ÅÂàóË°®: ${targetRelativePath}`
            );
            saved = await MiaoPluginMBT.SaveUserBans(logger);
            if (!saved) {
              logger.error(
                `${logPrefix} [${actionVerb}] ‰øùÂ≠òÁî®Êà∑Â∞ÅÁ¶ÅÂàóË°®Â§±Ë¥•ÔºÅ`
              );
              MiaoPluginMBT._userBanSet.delete(targetRelativePath);
              replyMsg = `„ÄéÂíïÂíïÁâõ„Äè${actionVerb}Â§±Ë¥•‰∫ÜÔºÅÊ≤°Ê≥ï‰øùÂ≠òÂ∞ÅÁ¶ÅÂàóË°®ÔºåÂàöÊâçÁöÑÊìç‰ΩúÂèØËÉΩÊ≤°ÁîüÊïàÔºÅ`;
              configChanged = false;
              await this.ReportError(
                e,
                `${actionVerb}ÂõæÁâá`,
                new Error("‰øùÂ≠òÂ∞ÅÁ¶ÅÂàóË°®Â§±Ë¥•")
              );
            } else {
              replyMsg = `${targetFileName} üö´ Â∑≤ÁªèÂ∞ÅÁ¶Å‰∫Ü„ÄÇ`;
            }
          } catch (err) {
            logger.error(
              `${logPrefix} [${actionVerb}] Ê∑ªÂä†Â∞ÅÁ¶ÅÊó∂ÂèëÁîüÂÜÖÈÉ®ÈîôËØØ:`,
              err
            );
            replyMsg = `„ÄéÂíïÂíïÁâõ„ÄèÂ§ÑÁêÜ${actionVerb}Êìç‰ΩúÊó∂ÂÜÖÈÉ®Âá∫ÈîôÔºåÊìç‰ΩúÊú™ÁîüÊïà„ÄÇ`;
            configChanged = false;
            await this.ReportError(e, `${actionVerb}ÂõæÁâá`, err);
          }
        }
      } else {
        // Ëß£Á¶Å
        if (!isCurrentlyUserBanned) {
          replyMsg = `${targetFileName} ‚ùì Âí¶ÔºüËøô‰∏™Â∞±Ê≤°Âú®‰Ω†ÁöÑÂ∞ÅÁ¶ÅÂàóË°®ÈáåÂëÄ„ÄÇ`;
        } else {
          try {
            MiaoPluginMBT._userBanSet.delete(targetRelativePath);
            configChanged = true;
            needsRestore = true;
            logger.info(
              `${logPrefix} [${actionVerb}] ‰ªéÂÜÖÂ≠òÂ∞ÅÁ¶ÅÂàóË°®ÁßªÈô§: ${targetRelativePath}`
            );
            saved = await MiaoPluginMBT.SaveUserBans(logger);
            if (!saved) {
              logger.error(
                `${logPrefix} [${actionVerb}] ‰øùÂ≠òÁî®Êà∑Â∞ÅÁ¶ÅÂàóË°®Â§±Ë¥•ÔºÅ`
              );
              MiaoPluginMBT._userBanSet.add(targetRelativePath);
              replyMsg = `„ÄéÂíïÂíïÁâõ„Äè${actionVerb}Â§±Ë¥•‰∫ÜÔºÅÊ≤°Ê≥ï‰øùÂ≠òÂ∞ÅÁ¶ÅÂàóË°®ÔºåÂàöÊâçÁöÑÊìç‰ΩúÂèØËÉΩÊ≤°ÁîüÊïàÔºÅ`;
              configChanged = false;
              needsRestore = false;
              await this.ReportError(
                e,
                `${actionVerb}ÂõæÁâá`,
                new Error("‰øùÂ≠òÂ∞ÅÁ¶ÅÂàóË°®Â§±Ë¥•")
              );
            } else {
              replyMsg = `${targetFileName} ‚úÖÔ∏è Â•ΩÂòûÔºåÂ∑≤Áªè‰ªé‰Ω†ÁöÑÊâãÂä®Â∞ÅÁ¶ÅÂàóË°®ÈáåÁßªÈô§‰∫Ü„ÄÇ`;
            }
          } catch (err) {
            logger.error(
              `${logPrefix} [${actionVerb}] Ëß£Á¶ÅÊó∂ÂèëÁîüÂÜÖÈÉ®ÈîôËØØ:`,
              err
            );
            if (!MiaoPluginMBT._userBanSet.has(targetRelativePath)) {
              MiaoPluginMBT._userBanSet.add(targetRelativePath);
            }
            replyMsg = `„ÄéÂíïÂíïÁâõ„ÄèÂ§ÑÁêÜ${actionVerb}Êìç‰ΩúÊó∂ÂÜÖÈÉ®Âá∫ÈîôÔºåÊìç‰ΩúÊú™ÁîüÊïà„ÄÇ`;
            configChanged = false;
            needsRestore = false;
            await this.ReportError(e, `${actionVerb}ÂõæÁâá`, err);
          }
        }
      }
    } catch (error) {
      logger.error(`${logPrefix} [${actionVerb}] Â§ÑÁêÜÊó∂ÂèëÁîüÊÑèÂ§ñÈîôËØØ:`, error);
      await this.ReportError(
        e,
        `${actionVerb}ÂõæÁâá`,
        error,
        `ÁõÆÊ†á: ${targetFileName}`
      );
      configChanged = false;
      needsRestore = false;
      replyMsg = `„ÄéÂíïÂíïÁâõ„ÄèÂ§ÑÁêÜ${actionVerb}Êìç‰ΩúÊó∂ÂÜÖÈÉ®Âá∫ÈîôÔºåÊìç‰ΩúÊú™ÁîüÊïà„ÄÇ`;
    }

    await e.reply(replyMsg, true);

    if (configChanged && saved) {
      setImmediate(async () => {
        try {
          await MiaoPluginMBT.GenerateAndApplyBanList(
            MiaoPluginMBT._imgDataCache,
            logger
          );
          logger.info(
            `${logPrefix} [${actionVerb}] Êìç‰ΩúÂêéÔºåÂêéÂè∞Â∑≤ÈáçÊñ∞Â∫îÁî®ÁîüÊïàÂ∞ÅÁ¶ÅÂàóË°®„ÄÇ`
          );
          if (needsRestore) {
            const restored = await MiaoPluginMBT.RestoreFileFromSource(
              targetRelativePath,
              logger
            );
            if (!restored) {
              logger.warn(
                `${logPrefix} [Ëß£Á¶Å] Â∞ùËØïÊÅ¢Â§ç ${targetFileName} Â§±Ë¥• (ÂèØËÉΩÊ∫êÊñá‰ª∂‰∏¢Â§±)„ÄÇ`
              );
            } else {
              logger.info(
                `${logPrefix} [Ëß£Á¶Å] Êñá‰ª∂ ${targetFileName} Â∑≤Â∞ùËØïÊÅ¢Â§ç„ÄÇ`
              );
            }
          }
        } catch (err) {
          logger.error(
            `${logPrefix} [${actionVerb}] ÂêéÂè∞Â∫îÁî®ÁîüÊïàÂàóË°®ÊàñÊÅ¢Â§çÊñá‰ª∂Êó∂Âá∫Èîô:`,
            err
          );
          await this.ReportError(e, `${actionVerb}ÂõæÁâá (ÂêéÂè∞‰ªªÂä°)`, err);
        }
      });
    }
  }

  /**
   * @description Â§ÑÁêÜ #Êü•Áúã ÂëΩ‰ª§ÔºåÊòæÁ§∫ÊåáÂÆöËßíËâ≤ÁöÑÊâÄÊúâÂõæÁâáÂèäÁä∂ÊÄÅ„ÄÇ
   */
  async FindRoleSplashes(e) {
    if (!(await this.CheckInit(e))) return true;
    if (!(await MiaoPluginMBT.IsTuKuDownloaded(1)))
      return e.reply("„ÄéÂíïÂíïÁâõ„ÄèÊ†∏ÂøÉÂ∫ìËøòÊ≤°‰∏ãËΩΩÂë¢ÔºÅ", true);

    const match = e.msg.match(/^#Êü•Áúã\s*(.+)$/i);
    if (!match?.[1]) return e.reply("ÊÉ≥ÁúãÂì™‰∏™ËßíËâ≤ÂëÄÔºüÊ†ºÂºèÔºö#Êü•Áúã ËßíËâ≤Âêç", true);

    const roleNameInput = match[1].trim();
    try {
      const { mainName, exists } = await MiaoPluginMBT.FindRoleAlias(
        roleNameInput,
        this.logger
      );
      const standardMainName = mainName || roleNameInput;

      const rawRoleImageData = MiaoPluginMBT._imgDataCache.filter(
        (img) => img.characterName === standardMainName
      );

      if (rawRoleImageData.length === 0) {
        const dirExists = await MiaoPluginMBT.CheckRoleDirExists(
          standardMainName
        );
        if (dirExists)
          return e.reply(
            `„Äé${standardMainName}„ÄèÁöÑËßíËâ≤Êñá‰ª∂Â§πÂú®Ôºå‰ΩÜÊòØÂõæÂ∫ìÊï∞ÊçÆÈáåÊ≤°ÊúâÂõæÁâá‰ø°ÊÅØÂì¶„ÄÇ`
          );
        else
          return e.reply(`ÂõæÂ∫ìÈáåÂ•ΩÂÉèÊ≤°Êúâ„Äé${standardMainName}„ÄèËøô‰∏™ËßíËâ≤Âë¢„ÄÇ`);
      }

      const config = MiaoPluginMBT.MBTConfig;
      const roleImageData = MiaoPluginMBT.FilterImagesBySwitches(
        rawRoleImageData,
        config
      );

      if (roleImageData.length === 0) {
        return e.reply(
          `Ê†πÊçÆÂΩìÂâçÁöÑËÆæÁΩÆÔºåÊ≤°ÊúâÊâæÂà∞„Äé${standardMainName}„ÄèÁöÑÂèØÁî®ÂõæÁâá„ÄÇ`,
          true
        );
      }

      roleImageData.sort(
        (a, b) =>
          parseInt(a.path?.match(/Gu(\d+)\.webp$/i)?.[1] || "0") -
          parseInt(b.path?.match(/Gu(\d+)\.webp$/i)?.[1] || "0")
      );

      const ITEMS_PER_BATCH = 28;
      const BATCH_SIZE = 28;
      const totalItems = roleImageData.length;
      const totalBatches = Math.ceil(totalItems / ITEMS_PER_BATCH);

      this.logger.info(
        `${this.logPrefix} [Êü•Áúã] ËßíËâ≤ ${standardMainName} ÂÖ± ${totalItems} Âº†ÂèØÁî®ÂõæÁâá (ËøáÊª§Âêé)ÔºåÂ∞ÜÂàÜ ${totalBatches} ÊâπÂèëÈÄÅ„ÄÇ`
      );

      for (let batchNum = 1; batchNum <= totalBatches; batchNum++) {
        const startIndex = (batchNum - 1) * ITEMS_PER_BATCH;
        const endIndex = Math.min(startIndex + BATCH_SIZE, totalItems);
        const currentBatchData = roleImageData.slice(startIndex, endIndex);

        const batchTitle = `Êü•Áúã„Äé${standardMainName}„Äè (${
          startIndex + 1
        }-${endIndex} / ${totalItems} Âº†)`;
        const currentForwardList = [[batchTitle]];
        if (batchNum === 1) {
          currentForwardList.push([
            `ÊÉ≥ÂØºÂá∫ÂõæÁâáÔºüËØïËØï: #ÂíïÂíïÁâõÂØºÂá∫${standardMainName}1`,
          ]);
        }

        this.logger.info(
          `${this.logPrefix} [Êü•Áúã] Ê≠£Âú®ÂáÜÂ§áÁ¨¨ ${batchNum}/${totalBatches} Êâπ...`
        );

        for (let i = 0; i < currentBatchData.length; i++) {
          const item = currentBatchData[i];
          const globalIndex = startIndex + i;

          const { path: relativePath } = item;
          if (!relativePath) continue;

          const normalizedPath = relativePath.replace(/\\/g, "/");
          const fileName = path.basename(normalizedPath);
          const baseName = fileName.replace(/\.webp$/i, "");

          const isEffectivelyBanned =
            MiaoPluginMBT._activeBanSet.has(normalizedPath);
          const isUserBanned = MiaoPluginMBT._userBanSet.has(normalizedPath);
          const isPurified = MiaoPluginMBT.CheckIfPurifiedByLevel(
            item,
            MiaoPluginMBT.MBTConfig.PFL ?? Default_Config.defaultPfl
          );

          let labelStr = "";
          if (isEffectivelyBanned) {
            labelStr += " ‚ùåÂ∞ÅÁ¶Å";
            if (isPurified && !isUserBanned) labelStr += " üå±ÂáÄÂåñ";
          }

          const entryText = `${globalIndex + 1}„ÄÅ${baseName}${labelStr}`;
          const absolutePath = await MiaoPluginMBT.FindImageAbsolutePath(
            normalizedPath
          );

          if (absolutePath) {
            try {
              await fsPromises.access(absolutePath, fs.constants.R_OK);
              currentForwardList.push([
                entryText,
                segment.image(`file://${absolutePath}`),
              ]);
            } catch (accessErr) {
              this.logger.warn(
                `${this.logPrefix} [Êü•Áúã] Êñá‰ª∂Êó†Ê≥ïËÆøÈóÆ: ${absolutePath}`,
                accessErr.code
              );
              currentForwardList.push(`${entryText} (Êñá‰ª∂Áä∂ÊÄÅÂºÇÂ∏∏)`);
            }
          } else {
            this.logger.warn(
              `${this.logPrefix} [Êü•Áúã] Êñá‰ª∂‰∏¢Â§±: ${normalizedPath}`
            );
            currentForwardList.push(`${entryText} (Êñá‰ª∂‰∏¢Â§±‰∫Ü...)`);
          }
        }

        if (currentForwardList.length > 1) {
          try {
            const forwardMsg = await common.makeForwardMsg(
              e,
              currentForwardList,
              `[${standardMainName}] ÂõæÂ∫ìËØ¶ÊÉÖ (${batchNum}/${totalBatches})`
            );
            if (forwardMsg) {
              await e.reply(forwardMsg);
              this.logger.info(
                `${this.logPrefix} [Êü•Áúã] Á¨¨ ${batchNum}/${totalBatches} ÊâπÂ∑≤ÂèëÈÄÅ„ÄÇ`
              );
            } else {
              this.logger.error(
                `${this.logPrefix} [Êü•Áúã] common.makeForwardMsg ËøîÂõûÁ©∫ (ÊâπÊ¨° ${batchNum})`
              );
              await e.reply(
                `ÁîüÊàêÁ¨¨ ${batchNum}/${totalBatches} ÊâπÂõæÁâáÂàóË°®Â§±Ë¥•‰∫Ü (makeForwardMsg failed)„ÄÇ`,
                true
              );
            }
          } catch (sendError) {
            this.logger.error(
              `${this.logPrefix} [Êü•Áúã] ÂèëÈÄÅÁ¨¨ ${batchNum}/${totalBatches} ÊâπÂêàÂπ∂ËΩ¨ÂèëÊ∂àÊÅØÂ§±Ë¥•:`,
              sendError
            );
            await e.reply(
              `ÂèëÈÄÅÁ¨¨ ${batchNum}/${totalBatches} ÊâπÂõæÁâáÂàóË°®Â§±Ë¥•‰∫ÜÔºåËØ∑Ê£ÄÊü•ÂêéÂè∞Êó•Âøó„ÄÇ`,
              true
            );
          }

          if (batchNum < totalBatches) {
            await common.sleep(1500);
          }
        } else {
          this.logger.warn(
            `${this.logPrefix} [Êü•Áúã] Á¨¨ ${batchNum}/${totalBatches} Êâπ‰∏∫Á©∫ÔºåË∑≥ËøáÂèëÈÄÅ„ÄÇ`
          );
        }
      }
    } catch (error) {
      await this.ReportError(e, `Êü•ÁúãËßíËâ≤ ${roleNameInput}`, error);
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂèØËßÜÂåñ ÂëΩ‰ª§Ôºå‰∏•Ê†ºÂõûÂΩí V4.8.4 ÈÄªËæë„ÄÇ
   */
  async VisualizeRoleSplashes(e) {
    if (!(await this.CheckInit(e))) return true;

    const match = e.msg.match(/^#ÂèØËßÜÂåñ\s*(.+)$/i);
    if (!match?.[1])
      return e.reply("ÊÉ≥ÂèØËßÜÂåñÂì™‰∏™ËßíËâ≤ÂëÄÔºüÊ†ºÂºèÔºö#ÂèØËßÜÂåñËßíËâ≤Âêç", true);
    const roleNameInput = match[1].trim();

    let standardMainName = "";
    const logger = this.logger;
    const logPrefix = this.logPrefix;
    const BATCH_SIZE = 20;

    try {
      const aliasResult = await MiaoPluginMBT.FindRoleAlias(
        roleNameInput,
        logger
      );
      standardMainName = aliasResult.mainName || roleNameInput;
      logger.info(
        `${logPrefix} [ÂèØËßÜÂåñ] ËØ∑Ê±ÇÂèØËßÜÂåñËßíËâ≤: '${roleNameInput}', Ê†áÂáÜÂêç: '${standardMainName}'`
      );

      let roleFolderPath = null;
      const targetDirsToCheck = [
        MiaoPluginMBT.paths.target.miaoChar,
        MiaoPluginMBT.paths.target.zzzChar,
        MiaoPluginMBT.paths.target.wavesChar,
      ].filter(Boolean);

      logger.info(
        `${logPrefix} [ÂèØËßÜÂåñ] ÂºÄÂßãÂú®ÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩïÊü•ÊâæËßíËâ≤ '${standardMainName}' ÁöÑÊñá‰ª∂Â§π...`
      );
      for (const targetDir of targetDirsToCheck) {
        if (!targetDir) continue;
        const potentialPath = path.join(targetDir, standardMainName);
        try {
          await fsPromises.access(potentialPath);
          const stats = await fsPromises.stat(potentialPath);
          if (stats.isDirectory()) {
            roleFolderPath = potentialPath;
            logger.info(
              `${logPrefix} [ÂèØËßÜÂåñ] Âú®ÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩïÊâæÂà∞ËßíËâ≤Êñá‰ª∂Â§π: ${roleFolderPath}`
            );
            break;
          }
        } catch (err) {
          if (err.code !== ERROR_CODES.NotFound) {
            logger.warn(
              `${logPrefix} [ÂèØËßÜÂåñ] ËÆøÈóÆÁõÆÊ†áË∑ØÂæÑ ${potentialPath} Êó∂Âá∫Èîô (ÈùûENOENT):`,
              err.code
            );
          }
        }
      }

      if (!roleFolderPath) {
        logger.warn(
          `${logPrefix} [ÂèØËßÜÂåñ] Êú™Âú®‰ªª‰ΩïÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï‰∏≠ÊâæÂà∞ËßíËâ≤ '${standardMainName}' ÁöÑÊñá‰ª∂Â§π„ÄÇ`
        );
        return e.reply(
          `Âú®ÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï‰∏≠Ê≤°ÊúâÊâæÂà∞ËßíËâ≤„Äé${standardMainName}„ÄèÁöÑÂõæÁâáÊñá‰ª∂Â§πÂì¶ÔºåÊòØ‰∏çÊòØËøòÊ≤°ÂêåÊ≠•ÊàñËÄÖËßíËâ≤ÂêçÈîô‰∫ÜÔºü`
        );
      }

      const supportedExtensions = [".jpg", ".png", ".jpeg", ".webp", ".bmp"];
      let allImageFiles = [];
      try {
        const files = await fsPromises.readdir(roleFolderPath);
        allImageFiles = files.filter((file) =>
          supportedExtensions.includes(path.extname(file).toLowerCase())
        );
        logger.info(
          `${logPrefix} [ÂèØËßÜÂåñ] Âú® ${roleFolderPath} ‰∏≠ÊâæÂà∞ ${allImageFiles.length} ‰∏™ÊîØÊåÅÁöÑÂõæÁâáÊñá‰ª∂„ÄÇ`
        );
      } catch (readErr) {
        logger.error(
          `${logPrefix} [ÂèØËßÜÂåñ] ËØªÂèñËßíËâ≤Êñá‰ª∂Â§πÂ§±Ë¥•: ${roleFolderPath}`,
          readErr
        );
        await this.ReportError(
          e,
          `ÂèØËßÜÂåñËßíËâ≤ ${standardMainName}`,
          readErr,
          "ËØªÂèñËßíËâ≤Êñá‰ª∂Â§πÂ§±Ë¥•"
        );
        return true;
      }

      if (allImageFiles.length === 0) {
        logger.warn(
          `${logPrefix} [ÂèØËßÜÂåñ] ËßíËâ≤Êñá‰ª∂Â§π ${roleFolderPath} ‰∏∫Á©∫Êàñ‰∏çÂåÖÂê´ÊîØÊåÅÁöÑÂõæÁâáÊ†ºÂºè„ÄÇ`
        );
        return e.reply(
          `„Äé${standardMainName}„ÄèÁöÑÊñá‰ª∂Â§πÈáåÊ≤°ÊúâÊâæÂà∞ÊîØÊåÅÁöÑÂõæÁâáÊñá‰ª∂Âì¶„ÄÇ`
        );
      }

      allImageFiles.sort((a, b) => {
        const numA = parseInt(a.match(/(\d+)\.\w+$/)?.[1] || "0");
        const numB = parseInt(b.match(/(\d+)\.\w+$/)?.[1] || "0");
        if (numA === numB) return a.localeCompare(b);
        return numA - numB;
      });

      const totalImageCount = allImageFiles.length;
      const totalBatches = Math.ceil(totalImageCount / BATCH_SIZE);

      logger.info(
        `${logPrefix} [ÂèØËßÜÂåñ] ÊâæÂà∞ ${totalImageCount} Âº†ÂõæÁâáÔºåÂ∞ÜÂàÜ ${totalBatches} ÊâπÂèëÈÄÅ...`
      );
      await e.reply(
        `${logPrefix} Ê≠£Âú®Êï¥ÁêÜ ${totalImageCount} Âº† [${standardMainName}] ÁöÑÂõæÁâá, ÂàÜ ${totalBatches} ÊâπÂèëÈÄÅ, ËØ∑Ê≥®ÊÑèÊü•Êî∂~`
      );
      await common.sleep(500);

      let sourceTplFilePath = path.join(
        MiaoPluginMBT.paths.commonResPath,
        "html",
        "visualize.html"
      );
      try {
        await fsPromises.access(sourceTplFilePath);
        // logger.debug(`${logPrefix} [ÂèØËßÜÂåñ] ‰ΩøÁî®ÂÖ¨ÂÖ±ËµÑÊ∫êÁõÆÂΩïÁöÑÊ®°Êùø: ${sourceTplFilePath}`); //Ë∞ÉËØïÊó•Âøó
      } catch (commonErr) {
        if (commonErr.code === ERROR_CODES.NotFound) {
          logger.warn(
            `${logPrefix} [ÂèØËßÜÂåñ] ÂÖ¨ÂÖ±ËµÑÊ∫êÊ®°Êùø (${sourceTplFilePath}) Êú™ÊâæÂà∞ÔºåÂ∞ùËØïÊèí‰ª∂ËµÑÊ∫êÁõÆÂΩï...`
          );
          sourceTplFilePath = path.resolve(
            __dirname,
            "..",
            "resources",
            "GuGuNiu-Gallery",
            "html",
            "visualize.html"
          );
          try {
            await fsPromises.access(sourceTplFilePath);
            // logger.debug(`${logPrefix} [ÂèØËßÜÂåñ] ‰ΩøÁî®Êèí‰ª∂ËµÑÊ∫êÁõÆÂΩïÁöÑÊ®°Êùø: ${sourceTplFilePath}`); //Ë∞ÉËØïÊó•Âøó
          } catch (pluginErr) {
            logger.error(
              `${logPrefix} [ÂèØËßÜÂåñ] ‰∏ªÊ®°ÊùøÂíåÂ§áÁî®Ê®°ÊùøÂùáÊú™ÊâæÂà∞: ${sourceTplFilePath}`,
              pluginErr
            );
            await e.reply(
              "ÁîüÊàêÂèØËßÜÂåñÂõæÁâáÂ§±Ë¥•ÔºöÁº∫Â∞ëÂøÖË¶ÅÁöÑ visualize.html Ê®°ÊùøÊñá‰ª∂„ÄÇ"
            );
            return true;
          }
        } else {
          logger.error(
            `${logPrefix} [ÂèØËßÜÂåñ] ËÆøÈóÆÂÖ¨ÂÖ±ËµÑÊ∫êÊ®°ÊùøÊó∂Âá∫Èîô: ${sourceTplFilePath}`,
            commonErr
          );
          await e.reply("ÁîüÊàêÂèØËßÜÂåñÂõæÁâáÂ§±Ë¥•ÔºöËÆøÈóÆÊ®°ÊùøÊñá‰ª∂Êó∂Âá∫Èîô„ÄÇ");
          return true;
        }
      }

      for (let batchNum = 1; batchNum <= totalBatches; batchNum++) {
        let tempHtmlFilePath = "";
        let tempImgFilePath = "";
        const tempFileNameBase = `visualize-${standardMainName.replace(
          /[^a-zA-Z0-9]/g,
          "_"
        )}-batch${batchNum}-${Date.now()}`;

        try {
          const startIndex = (batchNum - 1) * BATCH_SIZE;
          const endIndex = Math.min(startIndex + BATCH_SIZE, totalImageCount);
          const currentBatchFiles = allImageFiles.slice(startIndex, endIndex);

          logger.info(
            `${logPrefix} [ÂèØËßÜÂåñ] Ê≠£Âú®ÁîüÊàêÁ¨¨ ${batchNum}/${totalBatches} Êâπ (${currentBatchFiles.length} Âº†ÂõæÁâá)...`
          );

          const imagesDataForRender = currentBatchFiles.map(
            (fileName, index) => {
              const isGu = /gu/i.test(fileName);
              return {
                fileName: fileName.replace(/\.\w+$/, ""),
                filePath: `file://${path
                  .join(roleFolderPath, fileName)
                  .replace(/\\/g, "/")}`,
                originalIndex: startIndex + index,
                isGu: isGu,
              };
            }
          );

          const pluginVersion = MiaoPluginMBT.GetVersionStatic();
          const scaleStyleValue = MiaoPluginMBT.getScaleStyleValue();

          const renderData = {
            pluginVersion: pluginVersion,
            characterName: standardMainName,
            imageCount: totalImageCount,
            images: imagesDataForRender,
            batchNum: batchNum,
            totalBatches: totalBatches,
            batchStartIndex: startIndex,
            scaleStyleValue: scaleStyleValue,
          };

          await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, {
            recursive: true,
          });
          await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, {
            recursive: true,
          });
          tempHtmlFilePath = path.join(
            MiaoPluginMBT.paths.tempHtmlPath,
            `${tempFileNameBase}.html`
          );
          tempImgFilePath = path.join(
            MiaoPluginMBT.paths.tempImgPath,
            `${tempFileNameBase}.png`
          );

          try {
            await fsPromises.copyFile(sourceTplFilePath, tempHtmlFilePath);
          } catch (copyError) {
            logger.error(
              `${logPrefix} [ÂèØËßÜÂåñ] ÊâπÊ¨° ${batchNum}: Â§çÂà∂Ê®°ÊùøÂà∞‰∏¥Êó∂Êñá‰ª∂Â§±Ë¥•:`,
              copyError
            );
            await e.reply(
              `ÁîüÊàêÁ¨¨ ${batchNum}/${totalBatches} ÊâπÈ¢ÑËßàÂõæÂ§±Ë¥•ÔºöÊó†Ê≥ïÂàõÂª∫‰∏¥Êó∂Ê®°ÊùøÊñá‰ª∂„ÄÇ`
            );
            continue;
          }

          let img = null;
          try {
            img = await puppeteer.screenshot(
              `guguniu-visualize-${standardMainName}-batch${batchNum}`,
              {
                tplFile: tempHtmlFilePath,
                savePath: tempImgFilePath,
                imgType: "png",
                pageGotoParams: { waitUntil: "networkidle0", timeout: 45000 },
                ...renderData,
                screenshotOptions: { fullPage: true },
                width: 800,
              }
            );
          } catch (screenshotError) {
            logger.error(
              `${logPrefix} [ÂèØËßÜÂåñ] Puppeteer ÁîüÊàêÁ¨¨ ${batchNum}/${totalBatches} ÊâπÊà™ÂõæÂ§±Ë¥•:`,
              screenshotError
            );
            if (screenshotError.message?.includes("timeout")) {
              await e.reply(
                `ÁîüÊàêÁ¨¨ ${batchNum}/${totalBatches} ÊâπÈ¢ÑËßàÂõæË∂ÖÊó∂‰∫Ü...`
              );
            } else {
              await e.reply(
                `ÁîüÊàêÁ¨¨ ${batchNum}/${totalBatches} ÊâπÈ¢ÑËßàÂõæÂ§±Ë¥•‰∫ÜÔºåËØ∑Êü•ÁúãÊéßÂà∂Âè∞Êó•Âøó„ÄÇ`
              );
            }
            img = null;
          }

          if (img) {
            await e.reply(img);
            logger.info(
              `${logPrefix} [ÂèØËßÜÂåñ] „Äé${standardMainName}„ÄèÁ¨¨ ${batchNum}/${totalBatches} ÊâπÂõæÁâáÂ∑≤ÂèëÈÄÅ„ÄÇ`
            );
          } else {
            logger.error(
              `${logPrefix} [ÂèØËßÜÂåñ] Á¨¨ ${batchNum}/${totalBatches} ÊâπÊà™ÂõæÁîüÊàêÂ§±Ë¥•ÊàñËøîÂõûÁ©∫„ÄÇ`
            );
          }
        } catch (batchProcessingError) {
          logger.error(
            `${logPrefix} [ÂèØËßÜÂåñ] Â§ÑÁêÜÁ¨¨ ${batchNum}/${totalBatches} ÊâπÊó∂ÂèëÁîüÈîôËØØ:`,
            batchProcessingError
          );
          await e.reply(
            `Â§ÑÁêÜÁ¨¨ ${batchNum}/${totalBatches} ÊâπÊï∞ÊçÆÊó∂Âá∫ÈîôÔºåË∑≥ËøáÊ≠§ÊâπÊ¨°„ÄÇ`
          );
        } finally {
          if (tempHtmlFilePath && fs.existsSync(tempHtmlFilePath)) {
            try {
              await fsPromises.unlink(tempHtmlFilePath);
            } catch (unlinkErr) {}
          }
          if (tempImgFilePath && fs.existsSync(tempImgFilePath)) {
            try {
              await fsPromises.unlink(tempImgFilePath);
            } catch (unlinkErr) {}
          }
          const possiblePuppeteerTempDir = path.join(
            MiaoPluginMBT.paths.tempPath,
            "..",
            `guguniu-visualize-${standardMainName}-batch${batchNum}`
          );
          if (fs.existsSync(possiblePuppeteerTempDir)) {
            try {
              await safeDelete(possiblePuppeteerTempDir);
            } catch (deleteErr) {}
          }

          if (batchNum < totalBatches) {
            await common.sleep(2500);
          }
        }
      }

      logger.info(
        `${logPrefix} [ÂèØËßÜÂåñ] „Äé${standardMainName}„ÄèÊâÄÊúâÊâπÊ¨°Â§ÑÁêÜÂÆåÊàê„ÄÇ`
      );
    } catch (error) {
      logger.error(
        `${logPrefix} [ÂèØËßÜÂåñ] Â§ÑÁêÜËßíËâ≤ '${roleNameInput}' Êó∂ÂèëÁîüÈ°∂Â±ÇÈîôËØØ:`,
        error
      );
      await this.ReportError(e, `ÂèØËßÜÂåñËßíËâ≤ ${roleNameInput}`, error);
    } finally {
      if (standardMainName) {
        const possibleGenericDir = path.join(
          MiaoPluginMBT.paths.tempPath,
          "..",
          `guguniu-visualize-${standardMainName}`
        );
        if (fs.existsSync(possibleGenericDir)) {
          try {
            await safeDelete(possibleGenericDir);
          } catch (deleteErr) {}
        }
      }
      // logger.debug(`${logPrefix} [ÂèØËßÜÂåñ] VisualizeRoleSplashes ÊâßË°åÂÆåÊØï.`); //Ë∞ÉËØïÊó•Âøó
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂíïÂíïÁâõÂØºÂá∫ ÂëΩ‰ª§ÔºåÂèëÈÄÅÊåáÂÆöÂõæÁâáÊñá‰ª∂„ÄÇ
   */
  async ExportSingleImage(e) {
    if (!(await this.CheckInit(e))) return true;
    if (!(await MiaoPluginMBT.IsTuKuDownloaded(1)))
      return e.reply("„ÄéÂíïÂíïÁâõ„ÄèÊ†∏ÂøÉÂ∫ìËøòÊ≤°‰∏ãËΩΩÂë¢ÔºÅ", true);

    const match = e.msg.match(/^#ÂíïÂíïÁâõÂØºÂá∫\s*(.+)/i);
    if (!match?.[1])
      return e.reply(
        "Ë¶ÅÂØºÂá∫Âì™‰∏™ÂõæÁâáÂëÄÔºüÊ†ºÂºèÔºö#ÂíïÂíïÁâõÂØºÂá∫ ËßíËâ≤Âêç+ÁºñÂè∑ (‰æãÂ¶ÇÔºöÂøÉÊµ∑1)",
        true
      );

    const targetIdentifierRaw = match[1].trim();
    let targetRelativePath = null;
    let targetFileName = "";
    let absolutePath = null;

    try {
      const parsedId = MiaoPluginMBT.ParseRoleIdentifier(targetIdentifierRaw);
      if (!parsedId)
        return e.reply("Ê†ºÂºèÂ•ΩÂÉè‰∏çÂØπÂì¶ÔºåÂ∫îËØ•ÊòØ ËßíËâ≤Âêç+ÁºñÂè∑ÔºåÊØîÂ¶ÇÔºöËä±ÁÅ´1", true);
      const { mainName: rawMainName, imageNumber } = parsedId;

      const aliasResult = await MiaoPluginMBT.FindRoleAlias(
        rawMainName,
        this.logger
      );
      const standardMainName = aliasResult.exists
        ? aliasResult.mainName
        : rawMainName;

      const expectedFilenameLower = `${standardMainName.toLowerCase()}gu${imageNumber}.webp`;
      let foundCount = 0;
      const imageData = MiaoPluginMBT._imgDataCache.find((img) => {
        const nameMatch = img.characterName === standardMainName;
        const pathLower = img.path?.toLowerCase().replace(/\\/g, "/");
        const filenameMatch = pathLower?.endsWith(`/${expectedFilenameLower}`);
        if (nameMatch) foundCount++;
        return nameMatch && filenameMatch;
      });

      if (!imageData || !imageData.path) {
        let hint = `(ÂèØËÉΩÂéüÂõ†ÔºöÁºñÂè∑‰∏çÂ≠òÂú®„ÄÅËßíËâ≤Âêç/Âà´ÂêçÊâìÈîô‰∫ÜÔºü)`;
        if (MiaoPluginMBT._imgDataCache.length === 0) hint = `(ÂõæÂ∫ìÊï∞ÊçÆÊòØÁ©∫ÁöÑ)`;
        else if (foundCount === 0 && MiaoPluginMBT._imgDataCache.length > 0)
          hint = `(ÂõæÂ∫ìÈáåÂ•ΩÂÉèÊ≤°Êúâ '${standardMainName}' Ëøô‰∏™ËßíËâ≤Âì¶)`;
        else if (foundCount > 0)
          hint = `(ÊâæÂà∞‰∫ÜËßíËâ≤ '${standardMainName}'Ôºå‰ΩÜÊòØÊ≤°ÊúâÊâæÂà∞ÁºñÂè∑ ${imageNumber} ÁöÑÂõæÁâá)`;
        return e.reply(
          `Âú®ÂõæÂ∫ìÊï∞ÊçÆÈáåÊ≤°ÊâæÂà∞Ëøô‰∏™ÂõæÁâá: ${standardMainName}Gu${imageNumber}„ÄÇ\n${hint}`,
          true
        );
      }

      targetRelativePath = imageData.path.replace(/\\/g, "/");
      targetFileName = path.basename(targetRelativePath);

      if (MiaoPluginMBT._activeBanSet.has(targetRelativePath)) {
        return e.reply(`ÂõæÁâá ${targetFileName} Ë¢´Â∞ÅÁ¶Å‰∫ÜÔºå‰∏çËÉΩÂØºÂá∫Âì¶„ÄÇ`, true);
      }

      absolutePath = await MiaoPluginMBT.FindImageAbsolutePath(
        targetRelativePath
      );
      if (!absolutePath) {
        return e.reply(`Á≥üÁ≥ïÔºåÊñá‰ª∂‰∏¢Â§±‰∫ÜÔºö${targetFileName}ÔºåÊ≤°Ê≥ïÂØºÂá∫„ÄÇ`, true);
      }

      let fileBuffer = null;
      try {
        fileBuffer = await fsPromises.readFile(absolutePath);
        if (!fileBuffer || fileBuffer.length === 0) {
          throw new Error("ËØªÂèñÂà∞ÁöÑÊñá‰ª∂ Buffer ‰∏∫Á©∫");
        }
        this.logger.info(
          `${this.logPrefix} [ÂØºÂá∫] ÊàêÂäüËØªÂèñÊñá‰ª∂Âà∞ Buffer: ${targetFileName}, Â§ßÂ∞è: ${fileBuffer.length} bytes`
        );
      } catch (readError) {
        this.logger.error(
          `${this.logPrefix} [ÂØºÂá∫] ËØªÂèñÊñá‰ª∂Â§±Ë¥•: ${absolutePath}`,
          readError
        );
        await this.ReportError(
          e,
          `ÂØºÂá∫Êñá‰ª∂ ${targetFileName}`,
          readError,
          "ËØªÂèñÊñá‰ª∂Â§±Ë¥•"
        );
        return true;
      }

      this.logger.info(
        `${this.logPrefix} Áî®Êà∑ ${e.user_id} Ê≠£Âú®ÂØºÂá∫: ${targetFileName}`
      );

      await e.reply(`üì¶ ÂØºÂá∫ÊàêÂäüÔºÅÁªô‰Ω† -> ${targetFileName}`);
      await common.sleep(200);

      const fileSegment = segment.file(fileBuffer, targetFileName);

      await e.reply(fileSegment);
    } catch (sendErr) {
      this.logger.error(
        `${this.logPrefix} ÂØºÂá∫ ${
          targetFileName || targetIdentifierRaw
        } Êó∂ÂèëÈÄÅÂ§±Ë¥•:`,
        sendErr
      );
      try {
        if (
          sendErr?.message?.includes("highway") ||
          sendErr?.message?.includes("file size") ||
          sendErr?.code === -36 ||
          sendErr?.code === 210005 ||
          sendErr?.code === 210003
        ) {
          await e.reply(
            `ÂèëÈÄÅÊñá‰ª∂Â§±Ë¥•‰∫Ü,Êñá‰ª∂ÈÄöÈÅìÂ•ΩÂÉèÂá∫‰∫ÜÁÇπÈóÆÈ¢ò (${
              sendErr.code || "Êú™Áü•‰ª£Á†Å"
            })ÔºåÂèØËÉΩÊòØÊñá‰ª∂Â§™Â§ß„ÄÅÁΩëÁªú‰∏çÂ•ΩÊàñËÄÖË¢´QQÈôêÂà∂‰∫Ü„ÄÇ`,
            true
          );
        } else {
          await this.ReportError(
            e,
            `ÂØºÂá∫Êñá‰ª∂ ${targetFileName || targetIdentifierRaw}`,
            sendErr
          );
        }
      } catch (replyError) {
        this.logger.error(
          `${this.logPrefix} ÂèëÈÄÅÂØºÂá∫Â§±Ë¥•ÊèêÁ§∫Êó∂‰πüÂá∫Èîô:`,
          replyError
        );
      }
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂíïÂíïÁâõÂ∏ÆÂä© ÂëΩ‰ª§„ÄÇ
   */
  async Help(e) {
    const networkHelpUrl =
      "https://s2.loli.net/2025/05/05/zirbKvjTAByl3HS.webp";
    const localHelpPath = MiaoPluginMBT.paths.helpImagePath;

    try {
      await fsPromises.access(localHelpPath, fs.constants.R_OK);
      await e.reply(segment.image(`file://${localHelpPath}`));
    } catch (localError) {
      if (localError.code !== ERROR_CODES.NotFound) {
        this.logger.warn(
          `${this.logPrefix} [Â∏ÆÂä©] ËÆøÈóÆÊú¨Âú∞Â∏ÆÂä©ÂõæÁâáÂ§±Ë¥•:`,
          localError.code
        );
      }
      this.logger.info(
        `${this.logPrefix} [Â∏ÆÂä©] Êú¨Âú∞Â∏ÆÂä©Âõæ (${localHelpPath}) Âä†ËΩΩÂ§±Ë¥•ÔºåÂ∞ùËØïÂèëÈÄÅÂú®Á∫øÁâàÊú¨...`
      );
      try {
        await e.reply(segment.image(networkHelpUrl));
      } catch (networkError) {
        this.logger.error(
          `${this.logPrefix} [Â∏ÆÂä©] ÂèëÈÄÅÂú®Á∫øÂ∏ÆÂä©ÂõæÁâá‰πüÂ§±Ë¥•‰∫Ü:`,
          networkError.message
        );
        await e.reply(
          `${this.logPrefix} ÂìéÂëÄÔºåÂ∏ÆÂä©ÂõæÁâáÂä†ËΩΩ‰∏çÂá∫Êù•...\n` +
            `‰∏ªË¶ÅÂëΩ‰ª§ÊúâËøô‰∫õÔºö\n` +
            `#‰∏ãËΩΩÂíïÂíïÁâõ (‰∏ª‰∫∫Áî®)\n` +
            `#Êõ¥Êñ∞ÂíïÂíïÁâõ (‰∏ª‰∫∫Áî®)\n` +
            `#ÈáçÁΩÆÂíïÂíïÁâõ (‰∏ª‰∫∫Áî®, Ê∏ÖÁ©∫ÊâÄÊúâ!)\n` +
            `#Ê£ÄÊü•ÂíïÂíïÁâõ (ÁúãÁä∂ÊÄÅ)\n` +
            `#Êü•Áúã [ËßíËâ≤Âêç] (ÁúãÊüê‰∏™ËßíËâ≤ÁöÑÂõæ)\n` +
            `#ÂíïÂíïÁâõÂ∞ÅÁ¶Å [ËßíËâ≤Âêç+ÁºñÂè∑] (‰∏ª‰∫∫Áî®, ‰æã: #ÂíïÂíïÁâõÂ∞ÅÁ¶Å Ëä±ÁÅ´1)\n` +
            `#ÂíïÂíïÁâõËß£Á¶Å [ËßíËâ≤Âêç+ÁºñÂè∑] (‰∏ª‰∫∫Áî®)\n` +
            `#banÂàóË°® (ÁúãÂì™‰∫õÂõæË¢´Â±èËîΩ‰∫Ü)\n` +
            `#ËÆæÁΩÆÂíïÂíïÁâõÂáÄÂåñÁ≠âÁ∫ß [0|1|2] (‰∏ª‰∫∫Áî®)\n` +
            `#ÂêØÁî®ÂíïÂíïÁâõ / #Á¶ÅÁî®ÂíïÂíïÁâõ (‰∏ª‰∫∫Áî®)\n` +
            `#ÂíïÂíïÁâõÂØºÂá∫ [ËßíËâ≤Âêç+ÁºñÂè∑] (ÂØºÂá∫ÂõæÁâáÊñá‰ª∂)\n` +
            `#ÂíïÂíïÁâõÊµãÈÄü (Êµã‰∏ãËΩΩÈÄüÂ∫¶)\n` +
            `#ÂíïÂíïÁâõ (ÁúãÁâàÊú¨ÂíåÁ≥ªÁªü‰ø°ÊÅØ)\n` +
            `#ÂíïÂíïÁâõËÆæÁΩÆ[ai|ÂΩ©Ëõã|Ê®™Â±è][ÂºÄÂêØ|ÂÖ≥Èó≠] (‰∏ª‰∫∫Áî®)`
        );
      }
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂíïÂíïÁâõÊµãÈÄü ÂëΩ‰ª§ÔºåÊµãËØï‰ª£ÁêÜËäÇÁÇπÈÄüÂ∫¶Âπ∂ÂèëÈÄÅÂõæÁâáÊä•Âëä„ÄÇ
   *              Ê®°‰ªøÊ£ÄÊü•ÂëΩ‰ª§Ôºå‰ΩøÁî® tplFile + ...data Êà™ÂõæÊñπÂºè„ÄÇ
   */
  async ManualTestProxies(e) {
    if (!(await this.CheckInit(e))) return true;
    await e.reply(`${this.logPrefix} Êî∂Âà∞ÔºÅÂºÄÂßãÁÅ´ÂäõÂÖ®ÂºÄÊµãËØïÁΩëÁªúËäÇÁÇπ...`, true);
    const startTime = Date.now();
    let speeds1 = [],
      best1 = null;
    let tempHtmlFilePath = "";
    let tempImgFilePath = "";
    const logger = this.logger;
    const logPrefix = this.logPrefix;

    const sourceHtmlPath = path.join(
      MiaoPluginMBT.paths.commonResPath,
      "html",
      "speedtest.html"
    );

    try {
      try {
        await fsPromises.access(sourceHtmlPath);
        // logger.debug(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] ‰ΩøÁî®Â§ñÈÉ®Ê®°Êùø: ${sourceHtmlPath}`); //Ë∞ÉËØïÊó•Âøó
      } catch (err) {
        logger.error(
          `${logPrefix} [ÊâãÂä®ÊµãÈÄü] Êâæ‰∏çÂà∞Â§ñÈÉ®Ê®°ÊùøÊñá‰ª∂: ${sourceHtmlPath}`,
          err
        );
        await e
          .reply("ÁîüÊàêÊµãÈÄüÊä•ÂëäÂ§±Ë¥•ÔºöÁº∫Â∞ë speedtest.html Ê®°ÊùøÊñá‰ª∂„ÄÇ")
          .catch(() => {});
        return true;
      }

      speeds1 = await MiaoPluginMBT.TestProxies(RAW_URL_Repo1, logger);
      const available1 = MiaoPluginMBT.GetSortedAvailableSources(
        speeds1,
        true,
        logger
      );
      best1 = available1[0] || null;
      const duration = ((Date.now() - startTime) / 1000).toFixed(1);
      const processSpeeds = (speeds) => {
        return speeds
          .map((s) => {
            let statusText = "timeout";
            if (s.testUrlPrefix === null) statusText = "na";
            else if (Number.isFinite(s.speed) && s.speed >= 0)
              statusText = "ok";
            return { ...s, statusText };
          })
          .sort(
            (a, b) =>
              (a.priority ?? 999) - (b.priority ?? 999) ||
              (a.speed === Infinity || a.statusText === "na"
                ? 1
                : b.speed === Infinity || b.statusText === "na"
                ? -1
                : a.speed - b.speed)
          );
      };
      const processedSpeedsResult = processSpeeds(speeds1);
      const scaleStyleValue = MiaoPluginMBT.getScaleStyleValue();

      const renderData = {
        speeds1: processedSpeedsResult,
        best1: best1,
        duration: duration,
        scaleStyleValue: scaleStyleValue,
      };
      // logger.debug(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] [ËØäÊñ≠ V1.28] ÂáÜÂ§áÂ±ïÂºÄ‰º†ÈÄíÁöÑÊï∞ÊçÆ (renderData):`, renderData); //Ë∞ÉËØïÊó•Âøó

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, {
        recursive: true,
      });
      tempHtmlFilePath = path.join(
        MiaoPluginMBT.paths.tempHtmlPath,
        `manual-speedtest-temp-${Date.now()}-${Math.random()
          .toString(16)
          .slice(2)}.html`
      );
      try {
        await fsPromises.copyFile(sourceHtmlPath, tempHtmlFilePath);
        // logger.debug(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] Â∑≤Â∞ÜÂ§ñÈÉ®Ê®°ÊùøÂ§çÂà∂Âà∞‰∏¥Êó∂Êñá‰ª∂: ${tempHtmlFilePath}`); //Ë∞ÉËØïÊó•Âøó
      } catch (copyErr) {
        logger.error(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] Â§çÂà∂Ê®°ÊùøÊñá‰ª∂Â§±Ë¥•:`, copyErr);
        await this.ReportError(
          e,
          "ÊâãÂä®ÁΩëÁªúÊµãÈÄü",
          copyErr,
          "Êó†Ê≥ïÂàõÂª∫‰∏¥Êó∂Ê®°ÊùøÊñá‰ª∂"
        );
        return true;
      }

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, {
        recursive: true,
      });
      tempImgFilePath = path.join(
        MiaoPluginMBT.paths.tempImgPath,
        `speedtest-${Date.now()}-${Math.random().toString(16).slice(2)}.png`
      );

      // logger.info(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] [ËØäÊñ≠ V1.28] ÂáÜÂ§áË∞ÉÁî® puppeteer.screenshot (tplFile + ...data ÊñπÂºè)...`); //Ë∞ÉËØïÊó•Âøó
      // logger.debug(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] [ËØäÊñ≠ V1.28] tplFile: ${tempHtmlFilePath}`); //Ë∞ÉËØïÊó•Âøó

      const img = await puppeteer.screenshot("guguniu-speedtest", {
        tplFile: tempHtmlFilePath,
        savePath: tempImgFilePath,
        imgType: "png",
        pageGotoParams: { waitUntil: "networkidle0" },
        ...renderData,
        screenshotOptions: { fullPage: false },
        pageBoundingRect: { selector: "body", padding: 0 },
        width: 540,
      });
      // logger.info(`${logPrefix} [ÊâãÂä®ÊµãÈÄü] [ËØäÊñ≠ V1.28] puppeteer.screenshot Ë∞ÉÁî®ÂÆåÊàêÔºåËøîÂõûÁ±ªÂûã: ${typeof img}`); //Ë∞ÉËØïÊó•Âøó

      if (img) {
        await e.reply(img);
      } else {
        logger.error(
          `${this.logPrefix} [ÊâãÂä®ÊµãÈÄü] ÁîüÊàêÊà™ÂõæÂ§±Ë¥• (Puppeteer ËøîÂõûÁ©∫)„ÄÇ`
        );
        await e.reply("ÁîüÊàêÊµãÈÄüÊä•ÂëäÂõæÁâáÂ§±Ë¥•‰∫ÜÔºåËØ∑ÁúãÁúãÊó•Âøó„ÄÇ");
      }
    } catch (error) {
      await this.ReportError(
        e,
        "ÊâãÂä®ÁΩëÁªúÊµãÈÄü",
        error,
        `ÊµãÈÄüÁªìÊûú(ÂéüÂßã): ${JSON.stringify(speeds1)}`
      );
    } finally {
      if (tempHtmlFilePath && fs.existsSync(tempHtmlFilePath)) {
        try {
          await fsPromises.unlink(tempHtmlFilePath);
        } catch (unlinkErr) {}
      }
      if (tempImgFilePath && fs.existsSync(tempImgFilePath)) {
        try {
          await fsPromises.unlink(tempImgFilePath);
        } catch (unlinkErr) {}
      }
      const possiblePuppeteerTempDir = path.join(
        MiaoPluginMBT.paths.tempPath,
        "..",
        "guguniu-speedtest"
      );
      if (fs.existsSync(possiblePuppeteerTempDir)) {
        try {
          await safeDelete(possiblePuppeteerTempDir);
        } catch (deleteErr) {}
      }
    }
    return true;
  }
  /**
   * @description ÊòæÁ§∫ËÆæÁΩÆÈù¢ÊùøÂõæÁâá„ÄÇ
   *              Ê®°‰ªøÊ£ÄÊü•ÂëΩ‰ª§Ôºå‰ΩøÁî® tplFile + ...data Êà™ÂõæÊñπÂºè„ÄÇ
   */
  async ShowSettingsPanel(e, extraMsg = "") {
    if (!(await this.CheckInit(e))) return true;

    const logger = this.logger;
    const logPrefix = this.logPrefix;

    let tempHtmlFilePath = "";
    let tempImgFilePath = "";
    const sourceHtmlPath = path.join(
      MiaoPluginMBT.paths.commonResPath,
      "html",
      "settings_panel.html"
    );

    try {
      try {
        await fsPromises.access(sourceHtmlPath);
        // logger.debug(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] ÊâæÂà∞Ê®°ÊùøÊñá‰ª∂: ${sourceHtmlPath}`); //Ë∞ÉËØïÊó•Âøó
      } catch (err) {
        logger.error(
          `${logPrefix} [ËÆæÁΩÆÈù¢Êùø] Êâæ‰∏çÂà∞Ê®°ÊùøÊñá‰ª∂: ${sourceHtmlPath}`,
          err
        );
        await e.reply("Êó†Ê≥ïÊòæÁ§∫ËÆæÁΩÆÈù¢ÊùøÔºöÁº∫Â∞ë settings_panel.html Ê®°ÊùøÊñá‰ª∂„ÄÇ");
        return true;
      }

      const config = MiaoPluginMBT.MBTConfig;
      const tuKuEnabled = config?.TuKuOP ?? Default_Config.defaultTuKuOp;
      const pflLevel = config?.PFL ?? Default_Config.defaultPfl;
      const aiEnabled = config?.Ai ?? true;
      const easterEggEnabled = config?.EasterEgg ?? true;
      const layoutEnabled = config?.layout ?? true;
      const pm18Enabled = config?.PM18 ?? false;

      const scaleStyleValue = MiaoPluginMBT.getScaleStyleValue();
      const randomBgImageUrl = MiaoPluginMBT.getRandomBgImageUrl();

      const renderData = {
        pluginVersion: MiaoPluginMBT.GetVersionStatic(),
        tuKuStatus: {
          text: tuKuEnabled ? "Â∑≤ÂêØÁî®" : "Â∑≤Á¶ÅÁî®",
          class: tuKuEnabled ? "value-enabled" : "value-disabled",
        },
        pflStatus: {
          level: pflLevel,
          description: Purify_Level.getDescription(pflLevel),
          class: `value-level-${pflLevel}`,
        },
        aiStatus: {
          text: aiEnabled ? "Â∑≤ÂºÄÂêØ" : "Â∑≤ÂÖ≥Èó≠",
          class: aiEnabled ? "value-enabled" : "value-disabled",
        },
        easterEggStatus: {
          text: easterEggEnabled ? "Â∑≤ÂºÄÂêØ" : "Â∑≤ÂÖ≥Èó≠",
          class: easterEggEnabled ? "value-enabled" : "value-disabled",
        },
        layoutStatus: {
          text: layoutEnabled ? "Â∑≤ÂºÄÂêØ" : "Â∑≤ÂÖ≥Èó≠",
          class: layoutEnabled ? "value-enabled" : "value-disabled",
        },
        PM18Status: { 
          text: pm18Enabled ? 'Â∑≤ÂºÄÂêØ' : 'Â∑≤ÂÖ≥Èó≠', 
          class: pm18Enabled ? 'value-enabled' : 'value-disabled' 
        },
        scaleStyleValue: scaleStyleValue,
        backgroundImageUrl: randomBgImageUrl,
      };
      // logger.debug(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] [ËØäÊñ≠] ÂáÜÂ§áÂ±ïÂºÄ‰º†ÈÄíÁªôÊà™ÂõæÁöÑÊï∞ÊçÆ:`, renderData); //Ë∞ÉËØïÊó•Âøó

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, {
        recursive: true,
      });
      tempHtmlFilePath = path.join(
        MiaoPluginMBT.paths.tempHtmlPath,
        `settings-panel-tpl-${Date.now()}.html`
      );
      await fsPromises.copyFile(sourceHtmlPath, tempHtmlFilePath);
      // logger.debug(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] [ËØäÊñ≠] Â∑≤Â§çÂà∂Ê®°ÊùøÂà∞‰∏¥Êó∂Êñá‰ª∂: ${tempHtmlFilePath}`); //Ë∞ÉËØïÊó•Âøó

      await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, {
        recursive: true,
      });
      tempImgFilePath = path.join(
        MiaoPluginMBT.paths.tempImgPath,
        `settings-${Date.now()}.png`
      );

      logger.info(
        `${logPrefix} [ËÆæÁΩÆÈù¢Êùø] ÂºÄÂßãÁîüÊàêËÆæÁΩÆÈù¢ÊùøÊà™Âõæ (tplFile + ...data ÊñπÂºè)...`
      );
      // logger.debug(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] [ËØäÊñ≠] tplFile: ${tempHtmlFilePath}`); //Ë∞ÉËØïÊó•Âøó
      const screenshotData = { ...renderData };
      // logger.debug(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] [ËØäÊñ≠] data:`, screenshotData); //Ë∞ÉËØïÊó•Âøó

      const img = await puppeteer.screenshot("guguniu-settings-panel", {
        tplFile: tempHtmlFilePath,
        savePath: tempImgFilePath,
        imgType: "png",
        pageGotoParams: { waitUntil: "networkidle0" },
        ...screenshotData,
        screenshotOptions: { fullPage: true },
        pageBoundingRect: { selector: ".panel", padding: 15 },
        width: 480,
      });
      // logger.info(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] [ËØäÊñ≠] puppeteer.screenshot Ë∞ÉÁî®ÂÆåÊàêÔºåËøîÂõûÁ±ªÂûã: ${typeof img}`); //Ë∞ÉËØïÊó•Âøó

      if (img) {
        if (extraMsg) {
          await e.reply(extraMsg, true);
          await common.sleep(300);
        }
        await e.reply(img);
        logger.info(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] ËÆæÁΩÆÈù¢ÊùøÂõæÁâáÂ∑≤ÂèëÈÄÅ„ÄÇ`);
      } else {
        logger.error(
          `${logPrefix} [ËÆæÁΩÆÈù¢Êùø] Puppeteer Êú™ËÉΩÊàêÂäüÁîüÊàêÂõæÁâá (ËøîÂõûÁ©∫)„ÄÇ`
        );
        await e.reply("ÁîüÊàêËÆæÁΩÆÈù¢ÊùøÂõæÁâáÂ§±Ë¥•ÔºåËØ∑Êü•ÁúãÊó•Âøó„ÄÇ");
      }
    } catch (error) {
      logger.error(`${logPrefix} [ËÆæÁΩÆÈù¢Êùø] ÁîüÊàêÊàñÂèëÈÄÅÈù¢ÊùøÊó∂ÂèëÁîüÈîôËØØ:`, error);
      if (error.message?.includes("Cannot read properties of undefined")) {
        logger.error(
          `${logPrefix} [ËÆæÁΩÆÈù¢Êùø] [ËØäÊñ≠] Êà™ÂõæÊä•Èîô 'Cannot read properties of undefined'ÔºåËØ∑ÂÜçÊ¨°Á°ÆËÆ§Ê®°ÊùøÊñá‰ª∂ (${sourceHtmlPath}) ‰∏≠ÁöÑÂèòÈáèÂêç (Â¶Ç tuKuStatus.class) ÊòØÂê¶‰∏é‰ª£Á†Å‰∏≠ renderData ÁöÑÁªìÊûÑÂÆåÂÖ®‰∏ÄËá¥ÔºÅ`
        );
      }
      await this.ReportError(e, "ÊòæÁ§∫ËÆæÁΩÆÈù¢Êùø", error);
    } finally {
      if (tempHtmlFilePath && fs.existsSync(tempHtmlFilePath)) {
        try {
          await fsPromises.unlink(tempHtmlFilePath);
        } catch (unlinkErr) {}
      }
      if (tempImgFilePath && fs.existsSync(tempImgFilePath)) {
        try {
          await fsPromises.unlink(tempImgFilePath);
        } catch (unlinkErr) {}
      }
      const possiblePuppeteerTempDir = path.join(
        MiaoPluginMBT.paths.tempPath,
        "..",
        "guguniu-settings-panel"
      );
      if (fs.existsSync(possiblePuppeteerTempDir)) {
        try {
          await safeDelete(possiblePuppeteerTempDir);
        } catch (deleteErr) {}
      }
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜ #ÂíïÂíïÁâõËß¶ÂèëÈîôËØØ ÂëΩ‰ª§
   */
  async TriggerError(e) {
    if (!e.isMaster) return e.reply("‰ªÖÈôê‰∏ª‰∫∫ÊµãËØï„ÄÇ");
    const match = e.msg.match(
      /#ÂíïÂíïÁâõËß¶ÂèëÈîôËØØ(?:\s*(git|fs|config|data|ref|type|Repo1|Repo2|notify|other))?/i
    );
    const errorType = match?.[1]?.toLowerCase() || "other";
    let mockError = new Error(`Ê®°ÊãüÈîôËØØ (${errorType})`);
    this.logger.warn(
      `${this.logPrefix} Áî®Êà∑ ${e.user_id} Ëß¶ÂèëÊ®°ÊãüÈîôËØØ: "${errorType}"...`
    );
    await e.reply(`${this.logPrefix} Ëß¶ÂèëÁ±ªÂûã "${errorType}" ...`);
    try {
      switch (errorType) {
        case "git":
          mockError.message = "Ê®°ÊãüGitÂ§±Ë¥•";
          mockError.code = 128;
          mockError.stderr = "fatal: Repo not found";
          throw mockError;
        case "fs":
          mockError = new Error("Ê®°ÊãüFSÈîôËØØ");
          mockError.code = ERROR_CODES.NotFound;
          await fsPromises.access("/non/existent/path");
          break;
        case "config":
          mockError = new Error("Ê®°ÊãüÈÖçÁΩÆÂ§±Ë¥•");
          mockError.code = "YAMLParseError";
          throw mockError;
        case "data":
          mockError = new Error("Ê®°ÊãüÂÖÉÊï∞ÊçÆÂ§±Ë¥•");
          mockError.code = "JSONParseError";
          throw mockError;
        case "ref":
          mockError = new ReferenceError(
            "Ê®°ÊãüÂºïÁî®ÈîôËØØ: someUndefinedVariable is not defined"
          );
          console.log(someUndefinedVariable);
          break;
        case "type":
          mockError = new TypeError(
            "Ê®°ÊãüÁ±ªÂûãÈîôËØØ: (intermediate value).iDontExist is not a function"
          );
          (123).iDontExist();
          break;
        case "Repo1":
          mockError = new Error("Ê®°Êãü‰∏ÄÂè∑‰ªìÂ∫ìËÆøÈóÆÂ§±Ë¥•");
          mockError.code = ERROR_CODES.NotFound;
          await fsPromises.access(
            path.join(MiaoPluginMBT.paths.LocalTuKuPath, "non-existent")
          );
          break;
        case "Repo2":
          mockError = new Error("Ê®°Êãü‰∫åÂè∑‰ªìÂ∫ìËÆøÈóÆÂ§±Ë¥•");
          mockError.code = ERROR_CODES.NotFound;
          if (await MiaoPluginMBT.IsTuKuDownloaded(2))
            await fsPromises.access(
              path.join(MiaoPluginMBT.paths.LocalTuKuPath2, "non-existent")
            );
          else throw new Error("‰∫åÂè∑‰ªìÂ∫ìÊú™‰∏ãËΩΩÔºåÊó†Ê≥ïÊ®°ÊãüËÆøÈóÆÂ§±Ë¥•");
          break;
        case "notify":
          this.logger.info(`${this.logPrefix} [Ëß¶ÂèëÈîôËØØ] Ê®°ÊãüÈÄöÁü•‰∏ª‰∫∫...`);
          const fakeCommitHash = Math.random().toString(16).substring(2, 9);
          const fakeDate = new Date()
            .toLocaleString("zh-CN", {
              month: "2-digit",
              day: "2-digit",
              hour: "2-digit",
              minute: "2-digit",
              hour12: false,
            })
            .replace(",", "");
          const fakeLog = `${fakeDate.replace(
            "/",
            "-"
          )} [${fakeCommitHash}] fix: ËøôÊòØ‰∏Ä‰∏™Ê®°ÊãüÁöÑÊõ¥Êñ∞ÊàêÂäüÈÄöÁü•`;
          const notifyMsg = `„ÄéÂíïÂíïÁâõüêÇ„ÄèÂÆöÊó∂Êõ¥Êñ∞ÊàêÂäüÔºÅ\nÊúÄÊñ∞Êèê‰∫§Ôºö${fakeLog}`;
          await MiaoPluginMBT.SendMasterMsg(
            notifyMsg,
            undefined,
            1000,
            this.logger
          );
          await e.reply(`${this.logPrefix} Â∑≤Â∞ùËØïÂèëÈÄÅÊ®°ÊãüÈÄöÁü•„ÄÇ`);
          return true;
        default:
          throw mockError;
      }
      throw mockError;
    } catch (error) {
      await this.ReportError(
        e,
        `Ê®°ÊãüÈîôËØØ (${errorType})`,
        error,
        `Áî®Êà∑Ëß¶Âèë: ${e.msg}`
      );
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜÁªü‰∏ÄÁöÑ #ÂíïÂíïÁâõËÆæÁΩÆ ÂëΩ‰ª§„ÄÇ
   */
  async HandleSettingsCommand(e) {
    if (!(await this.CheckInit(e))) return true;
    if (!e.isMaster)
      return e.reply(`${this.logPrefix} Âè™Êúâ‰∏ª‰∫∫ÊâçËÉΩ‰ΩøÁî®ËÆæÁΩÆÂëΩ‰ª§Âì¶~`);

    const match = e.msg.match(/^#ÂíïÂíïÁâõËÆæÁΩÆ(ai|ÂΩ©Ëõã|Ê®™Â±è|ÂáÄÂåñÁ≠âÁ∫ß|pm18)([012]|ÂºÄÂêØ|ÂÖ≥Èó≠)$/i);
    if (!match || !match[1] || !match[2]) {
      this.logger.warn(
        `${this.logPrefix} [Áªü‰∏ÄËÆæÁΩÆ] Ê≠£ÂàôÂåπÈÖçÂºÇÂ∏∏? msg: ${e.msg}`
      );
      return false;
    }

    const featureKeyRaw = match[1].toLowerCase();
    const valueRaw = match[2];
    const logger = this.logger;
    const logPrefix = this.logPrefix;

    // logger.debug(`${logPrefix} [Áªü‰∏ÄËÆæÁΩÆ][ËØäÊñ≠] featureKeyRaw: ${featureKeyRaw}, valueRaw: ${valueRaw}`); //Ë∞ÉËØïÊó•Âøó

    if (featureKeyRaw === "ÂáÄÂåñÁ≠âÁ∫ß") {
      const level = parseInt(valueRaw, 10);
      if (isNaN(level) || ![0, 1, 2].includes(level)) {
        return e.reply(
          `Êó†ÊïàÁöÑÂáÄÂåñÁ≠âÁ∫ßÂÄº: ${valueRaw}ÔºåÂè™ËÉΩÊòØ 0, 1, Êàñ 2„ÄÇ`,
          true
        );
      }
      // logger.debug(`${logPrefix} [Áªü‰∏ÄËÆæÁΩÆ][ËØäÊñ≠] ÂáÜÂ§áË∞ÉÁî® setPurificationLevelInternal, level: ${level}`); //Ë∞ÉËØïÊó•Âøó
      await this.setPurificationLevelInternal(e, level);
    } else {
      if (!['ÂºÄÂêØ', 'ÂÖ≥Èó≠'].includes(valueRaw)) {
          if (!(featureKeyRaw === 'pm18' && ['0', '1'].includes(valueRaw))) {
              return e.reply(`Êó†ÊïàÁöÑÊìç‰Ωú: ${valueRaw}ÔºåËØ∑‰ΩøÁî® 'ÂºÄÂêØ' Êàñ 'ÂÖ≥Èó≠'„ÄÇ`, true);
          }
      }

      const enable = valueRaw === 'ÂºÄÂêØ' || valueRaw === '1';
      let configKey = '';
      let featureName = '';
      switch (featureKeyRaw) {
          case 'ai': configKey = 'Ai'; featureName = 'Ai Âõæ'; break;
          case 'ÂΩ©Ëõã': configKey = 'EasterEgg'; featureName = 'ÂΩ©ËõãÂõæ'; break;
          case 'Ê®™Â±è': configKey = 'layout'; featureName = 'Ê®™Â±èÂõæ'; break;
          case 'pm18': configKey = 'PM18'; featureName = 'PM18 ÂäüËÉΩ'; break; 
          default:
              logger.error(`${logPrefix} [Áªü‰∏ÄËÆæÁΩÆ] Êú™Áü•ÁöÑ featureKeyRaw: ${featureKeyRaw}`);
              return false;
      }
      // logger.debug(`${logPrefix} [Áªü‰∏ÄËÆæÁΩÆ][ËØäÊñ≠] ÂáÜÂ§áË∞ÉÁî® handleSwitchCommand, configKey: ${configKey}, featureName: ${featureName}, enable: ${enable}`); //Ë∞ÉËØïÊó•Âøó
      await this.handleSwitchCommand(e, configKey, featureName, enable);
    }
    return true;
  }

  /**
   * @description Â§ÑÁêÜÂáÄÂåñÁ≠âÁ∫ßËÆæÁΩÆÁöÑÊ†∏ÂøÉÈÄªËæë (‰ªéÊóß SetPurificationLevel ËøÅÁßªÂπ∂‰øÆÊîπ)„ÄÇ
   *              Áî± HandleSettingsCommand Ë∞ÉÁî®„ÄÇ
   */
  async setPurificationLevelInternal(e, level) {
    const logger = this.logger;
    const logPrefix = this.logPrefix;
    let configChanged = false;
    let saveWarning = "";
    let asyncError = null;

    // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÂºÄÂßãÂ§ÑÁêÜÔºåËØ∑Ê±ÇÁ≠âÁ∫ß: ${level}`); //Ë∞ÉËØïÊó•Âøó
    await MiaoPluginMBT.configMutex.acquire();
    // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] Â∑≤Ëé∑ÂèñÈÖçÁΩÆÈîÅ„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
    try {
      await MiaoPluginMBT.LoadTuKuConfig(true, logger);
      const currentLevel =
        MiaoPluginMBT.MBTConfig.PFL ?? Default_Config.defaultPfl;
      // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÂΩìÂâçÁ≠âÁ∫ß: ${currentLevel}`); //Ë∞ÉËØïÊó•Âøó

      if (level === currentLevel) {
        logger.info(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] Á≠âÁ∫ßÊú™ÂèòÔºåÂ∞ùËØïÊòæÁ§∫Èù¢Êùø„ÄÇ`);
        try {
          await this.ShowSettingsPanel(
            e,
            `ÂáÄÂåñÁ≠âÁ∫ßÂ∑≤ÁªèÊòØ ${level} (${Purify_Level.getDescription(
              level
            )}) Âï¶„ÄÇ`
          );
        } catch (panelError) {
          logger.error(
            `${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÊòæÁ§∫ÂΩìÂâçÁä∂ÊÄÅÈù¢ÊùøÂ§±Ë¥•ÔºåÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ:`,
            panelError
          );
          await e.reply(
            `${logPrefix} ÂáÄÂåñÁ≠âÁ∫ßÂ∑≤ÁªèÊòØ ${level} (${Purify_Level.getDescription(
              level
            )}) Âï¶„ÄÇ`,
            true
          );
        }
        MiaoPluginMBT.configMutex.release();
        // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (Áä∂ÊÄÅÊú™ÂèòË∑ØÂæÑ)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
        return;
      }

      MiaoPluginMBT.MBTConfig.PFL = level;
      configChanged = true;
      logger.info(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÂÜÖÂ≠òÁä∂ÊÄÅÂèòÊõ¥‰∏∫ -> ${level}`);

      // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] Â∞ùËØï‰øùÂ≠òÈÖçÁΩÆ...`); //Ë∞ÉËØïÊó•Âøó
      const saveSuccess = await MiaoPluginMBT.SaveTuKuConfig(
        MiaoPluginMBT.MBTConfig,
        logger
      );
      if (!saveSuccess) {
        saveWarning = "‚ö†Ô∏è ‰ΩÜÊòØÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•‰∫ÜÔºÅËÆæÁΩÆÂèØËÉΩ‰∏ç‰ºöÊåÅ‰πÖÁîüÊïà„ÄÇ";
        MiaoPluginMBT.MBTConfig.PFL = currentLevel;
        configChanged = false;
        logger.error(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ‰øùÂ≠òÂ§±Ë¥•ÔºåÂÜÖÂ≠òÁä∂ÊÄÅÂ∑≤ÂõûÊªö„ÄÇ`);
        await this.ReportError(
          e,
          "ËÆæÁΩÆÂáÄÂåñÁ≠âÁ∫ß",
          new Error("‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•"),
          saveWarning
        );
        MiaoPluginMBT.configMutex.release();
        // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (‰øùÂ≠òÂ§±Ë¥•Ë∑ØÂæÑ)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
        return;
      }
      // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÈÖçÁΩÆ‰øùÂ≠òÊàêÂäü„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
    } catch (configError) {
      logger.error(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] Â§ÑÁêÜÈÖçÁΩÆÊó∂Âá∫Èîô:`, configError);
      await this.ReportError(e, "ËÆæÁΩÆÂáÄÂåñÁ≠âÁ∫ß", configError, "Â§ÑÁêÜÈÖçÁΩÆÊó∂Âá∫Èîô");
      MiaoPluginMBT.configMutex.release();
      // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (ÈÖçÁΩÆÂ§ÑÁêÜÈîôËØØË∑ØÂæÑ)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
      return;
    } finally {
      MiaoPluginMBT.configMutex.release();
      // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (finally Âùó)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
    }

    if (configChanged) {
      // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÈÖçÁΩÆÂ∑≤Êõ¥ÊîπÔºåÂáÜÂ§áÂêéÂè∞Â∫îÁî®...`); //Ë∞ÉËØïÊó•Âøó
      setImmediate(async () => {
        // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] setImmediate ÂõûË∞ÉÂºÄÂßã„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
        try {
          logger.info(
            `${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÂêéÂè∞ÂºÄÂßãÂ∫îÁî®Êñ∞ÁöÑÂáÄÂåñÁ≠âÁ∫ß ${level}...`
          );
          // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] Ë∞ÉÁî® GenerateAndApplyBanList...`); //Ë∞ÉËØïÊó•Âøó
          await MiaoPluginMBT.GenerateAndApplyBanList(
            MiaoPluginMBT._imgDataCache,
            logger
          );
          logger.info(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] Êñ∞ÁöÑÁîüÊïàÂ∞ÅÁ¶ÅÂàóË°®Â∑≤Â∫îÁî®„ÄÇ`);
          if (MiaoPluginMBT.MBTConfig.TuKuOP) {
            logger.info(
              `${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÂõæÂ∫ìÂ∑≤ÂêØÁî®ÔºåÂºÄÂßãÈáçÊñ∞ÂêåÊ≠•ËßíËâ≤Êñá‰ª∂Â§π...`
            );
            // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] Ë∞ÉÁî® SyncCharacterFolders...`); //Ë∞ÉËØïÊó•Âøó
            await MiaoPluginMBT.SyncCharacterFolders(logger);
            logger.info(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ËßíËâ≤Êñá‰ª∂Â§πÈáçÊñ∞ÂêåÊ≠•ÂÆåÊàê„ÄÇ`);
          } else {
            logger.info(
              `${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÂõæÂ∫ìÂ∑≤Á¶ÅÁî®ÔºåË∑≥ËøáËßíËâ≤Êñá‰ª∂Â§πÂêåÊ≠•„ÄÇ`
            );
          }
        } catch (applyError) {
          logger.error(
            `${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÂêéÂè∞Â∫îÁî®ÊàñÂêåÊ≠•Êó∂Âá∫Èîô:`,
            applyError
          );
          asyncError = applyError;
          await this.ReportError(e, "Â∫îÁî®ÂáÄÂåñÁ≠âÁ∫ß (ÂêéÂè∞)", applyError);
        } finally {
          // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] setImmediate ÂõûË∞ÉÁªìÊùüÔºåÂ∞ùËØïÊòæÁ§∫Èù¢Êùø„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
          let panelSent = false;
          try {
            let extraPanelMsg = "";
            if (asyncError) extraPanelMsg += `\n(ÂêéÂè∞Â∫îÁî®Êó∂ÈÅáÂà∞ÈóÆÈ¢ò)`;
            if (saveWarning) extraPanelMsg += `\n${saveWarning}`;
            await this.ShowSettingsPanel(e, extraPanelMsg.trim());
            panelSent = true;
            // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] ÊúÄÁªàÈù¢ÊùøÊòæÁ§∫ÊàêÂäü„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
          } catch (panelError) {
            logger.error(
              `${logPrefix} [ÂáÄÂåñËÆæÁΩÆ] ÊòæÁ§∫ËÆæÁΩÆÈù¢ÊùøÂ§±Ë¥•ÔºåÂ∞ÜÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ:`,
              panelError
            );
            panelSent = false;
            let finalUserMessage = `${logPrefix} ÂáÄÂåñÁ≠âÁ∫ßÂ∑≤ËÆæ‰∏∫ ${level} (${Purify_Level.getDescription(
              level
            )})„ÄÇ`;
            if (level === Purify_Level.PX18_PLUS)
              finalUserMessage += "\n(Px18 ÊåáËΩªÂæÆÊÄßÊöóÁ§∫Êàñ‰ΩéÂ∫¶ÊåëÈÄóÊÄßÂõæÁâá)";
            if (saveWarning) finalUserMessage += `\n${saveWarning}`;
            if (asyncError) finalUserMessage += "\n(ÂêéÂè∞Â∫îÁî®Êó∂Âá∫ÈîôÔºåËØ¶ËßÅÊó•Âøó)";
            await e.reply(finalUserMessage, true);
          }
        }
      });
    }
    // logger.debug(`${logPrefix} [ÂáÄÂåñËÆæÁΩÆÂÜÖÈÉ®][ËØäÊñ≠] Â§ÑÁêÜÁªìÊùü„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
  }

  /**
   * @description ÈÄöÁî®ÁöÑÂºÄÂÖ≥ÂëΩ‰ª§Â§ÑÁêÜÈÄªËæë (‰ªéÊóß SetFeatureSwitch ËøÅÁßªÂπ∂‰øÆÊîπ)„ÄÇ
   *              Áî± HandleSettingsCommand Ë∞ÉÁî®„ÄÇ
   *              Â¢ûÂä† enable ÂèÇÊï∞ÔºåÁßªÈô§ÂëΩ‰ª§Ëß£Êûê„ÄÇ
   */
  async handleSwitchCommand(e, configKey, featureName, enable) {
    const logger = this.logger;
    const logPrefix = this.logPrefix;
    // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ËøõÂÖ• handleSwitchCommand ÂáΩÊï∞, enable: ${enable}`); //Ë∞ÉËØïÊó•Âøó

    let configChanged = false;
    let saveWarning = "";
    let asyncError = null;
    let backgroundTaskMsg = ''; 

    // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] Â∞ùËØïËé∑ÂèñÈÖçÁΩÆÈîÅ...`); //Ë∞ÉËØïÊó•Âøó
    await MiaoPluginMBT.configMutex.acquire();
    // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] Â∑≤Ëé∑ÂèñÈÖçÁΩÆÈîÅ„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
    try {
      // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] Âä†ËΩΩÊúÄÊñ∞ÈÖçÁΩÆ...`); //Ë∞ÉËØïÊó•Âøó
      await MiaoPluginMBT.LoadTuKuConfig(true, logger);
      const currentStatus = MiaoPluginMBT.MBTConfig[configKey];
      // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÂΩìÂâçÁä∂ÊÄÅ: ${currentStatus}`); //Ë∞ÉËØïÊó•Âøó

      if (currentStatus === enable) {
        logger.info(
          `${logPrefix} [${featureName}ËÆæÁΩÆ] ÂΩìÂâçÁä∂ÊÄÅÂ∑≤ÊòØ ${
            enable ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠"
          }ÔºåÊó†ÈúÄÊõ¥Êîπ„ÄÇ`
        );
        try {
          await this.ShowSettingsPanel(
            e,
            `${featureName}Â∑≤ÁªèÊòØ„Äå${enable ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠"}„ÄçÁä∂ÊÄÅ‰∫Ü„ÄÇ`
          );
        } catch (panelError) {
          logger.error(
            `${logPrefix} [${featureName}ËÆæÁΩÆ] ÊòæÁ§∫ÂΩìÂâçÁä∂ÊÄÅÈù¢ÊùøÂ§±Ë¥•ÔºåÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ:`,
            panelError
          );
          await e.reply(
            `${logPrefix} ${featureName}Â∑≤ÁªèÊòØ„Äå${
              enable ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠"
            }„ÄçÁä∂ÊÄÅ‰∫ÜÔºåÊó†ÈúÄÊõ¥Êîπ„ÄÇ`,
            true
          );
        }
        MiaoPluginMBT.configMutex.release();
        // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (Áä∂ÊÄÅÊú™ÂèòË∑ØÂæÑ)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
        return;
      }
      MiaoPluginMBT.MBTConfig[configKey] = enable;
      configChanged = true;
      logger.info(
        `${logPrefix} [${featureName}ËÆæÁΩÆ] ÂÜÖÂ≠òÁä∂ÊÄÅÂèòÊõ¥‰∏∫ -> ${enable}`
      );

      // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] Â∞ùËØï‰øùÂ≠òÈÖçÁΩÆ...`); //Ë∞ÉËØïÊó•Âøó
      const saveSuccess = await MiaoPluginMBT.SaveTuKuConfig(
        MiaoPluginMBT.MBTConfig,
        logger
      );
      if (!saveSuccess) {
        saveWarning = `‚ö†Ô∏è ‰ΩÜÊòØÈÖçÁΩÆ‰øùÂ≠òÂ§±Ë¥•‰∫ÜÔºÅËÆæÁΩÆÂèØËÉΩ‰∏ç‰ºöÊåÅ‰πÖÁîüÊïà„ÄÇ`;
        MiaoPluginMBT.MBTConfig[configKey] = !enable;
        configChanged = false;
        logger.error(
          `${logPrefix} [${featureName}ËÆæÁΩÆ] ‰øùÂ≠òÂ§±Ë¥•ÔºåÂÜÖÂ≠òÁä∂ÊÄÅÂ∑≤ÂõûÊªö„ÄÇ`
        );
        await this.ReportError(
          e,
          `ËÆæÁΩÆ${featureName}`,
          new Error("‰øùÂ≠òÈÖçÁΩÆÂ§±Ë¥•"),
          saveWarning
        );
        MiaoPluginMBT.configMutex.release();
        // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (‰øùÂ≠òÂ§±Ë¥•Ë∑ØÂæÑ)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
        return;
      }
      // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÈÖçÁΩÆ‰øùÂ≠òÊàêÂäü„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
    } catch (configError) {
      logger.error(
        `${logPrefix} [${featureName}ËÆæÁΩÆ] Â§ÑÁêÜÈÖçÁΩÆÊó∂Âá∫Èîô:`,
        configError
      );
      await this.ReportError(
        e,
        `ËÆæÁΩÆ${featureName}`,
        configError,
        "Â§ÑÁêÜÈÖçÁΩÆÊó∂Âá∫Èîô"
      );
      MiaoPluginMBT.configMutex.release();
      // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (ÈÖçÁΩÆÂ§ÑÁêÜÈîôËØØË∑ØÂæÑ)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
      return;
    } finally {
      MiaoPluginMBT.configMutex.release();
      // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÈáäÊîæÈÖçÁΩÆÈîÅ (finally Âùó)„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
    }

    if (configChanged) {

      if (configChanged && configKey === 'PM18') {
          logger.info(`${logPrefix} [${featureName}ËÆæÁΩÆ] ÈÖçÁΩÆÂ∑≤Êõ¥ÊîπÔºåÂáÜÂ§áÂêØÂä®‰ªªÂä°`);
          backgroundTaskMsg = `\n‚è≥ ${enable ? 'ÈÉ®ÁΩ≤' : 'Ê∏ÖÁêÜ'}‰ªªÂä°Â∑≤ÂêØÂä®`;
          setImmediate(async () => { 
              if (enable) {
                  await MiaoPluginMBT.deployPM18Files(logger);
              } else {
                  await MiaoPluginMBT.cleanPM18Files(logger);
              }
          });
      }
      let panelSent = false;
      try {
        let extraPanelMsg = "";
        if (saveWarning) extraPanelMsg += `\n${saveWarning}`;
        // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] Â∞ùËØïÊòæÁ§∫ÊúÄÁªàÈù¢Êùø...`); //Ë∞ÉËØïÊó•Âøó
        await this.ShowSettingsPanel(e, extraPanelMsg.trim());
        panelSent = true;
        // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÊúÄÁªàÈù¢ÊùøÊòæÁ§∫ÊàêÂäü„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
      } catch (panelError) {
        logger.error(
          `${logPrefix} [${featureName}ËÆæÁΩÆ] ÊòæÁ§∫ËÆæÁΩÆÈù¢ÊùøÂ§±Ë¥•ÔºåÂ∞ÜÂèëÈÄÅÊñáÊú¨ÂõûÈÄÄ:`,
          panelError
        );
        panelSent = false;
        let finalUserMessage = `${logPrefix} ${featureName}Â∑≤ÊàêÂäüËÆæ‰∏∫„Äå${
          enable ? "ÂºÄÂêØ" : "ÂÖ≥Èó≠"
        }„ÄçÔºå‰ΩÜÈù¢ÊùøÂõæÁâáÂèëÈÄÅÂ§±Ë¥•„ÄÇ`;
        if (saveWarning) finalUserMessage += `\n${saveWarning}`;
        await e.reply(finalUserMessage, true);
      }
    }
    // logger.debug(`${logPrefix} [${featureName}ËÆæÁΩÆ][ËØäÊñ≠] ÂáΩÊï∞Â§ÑÁêÜÁªìÊùü„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
  }

  // --- ÈùôÊÄÅËæÖÂä©ÊñπÊ≥ï ---

  /**
   * @description Êèí‰ª∂ÂÖ®Â±ÄÈùôÊÄÅÂàùÂßãÂåñÂÖ•Âè£„ÄÇ
   */
  static async InitializePlugin(logger = global.logger || console) {
    const logPrefix = Default_Config.logPrefix;

    if (MiaoPluginMBT.isInitializing) {
      logger.warn(`${logPrefix} [ÂàùÂßãÂåñ] Ê£ÄÊµãÂà∞ÂàùÂßãÂåñÊ≠£Âú®ËøõË°å‰∏≠ÔºåÁ≠âÂæÖÂÆåÊàê...`);
      try {
        await MiaoPluginMBT.initializationPromise;
      } catch (waitError) {}
      return MiaoPluginMBT.initializationPromise;
    }

    if (MiaoPluginMBT.initializationPromise) {
      return MiaoPluginMBT.initializationPromise;
    }
    if (MiaoPluginMBT.isGloballyInitialized) {
      return Promise.resolve();
    }

    MiaoPluginMBT.isInitializing = true;
    logger.info(
      `${logPrefix} ÂºÄÂßãÂÖ®Â±ÄÂàùÂßãÂåñ(V${MiaoPluginMBT.GetVersionStatic()})...`
    );
    MiaoPluginMBT.isGloballyInitialized = false;

    MiaoPluginMBT.initializationPromise = (async () => {
      let fatalError = null;
      let localImgDataCache = [];

      try {
        const config = await MiaoPluginMBT.LoadTuKuConfig(true, logger);
        if (!config) throw new Error("Êó†Ê≥ïÂä†ËΩΩÂõæÂ∫ìÈÖçÁΩÆ");

        localImgDataCache = await MiaoPluginMBT.LoadImageData(true, logger);
        if (!Array.isArray(localImgDataCache)) {
          logger.error(
            `${logPrefix} [ÂàùÂßãÂåñ] CRITICAL: ÂÖÉÊï∞ÊçÆÂä†ËΩΩÂ§±Ë¥•ÊàñÊ†ºÂºèÈîôËØØ!`
          );
          localImgDataCache = [];
          throw new Error("Âä†ËΩΩÂõæÁâáÂÖÉÊï∞ÊçÆÂ§±Ë¥•");
        } else if (localImgDataCache.length === 0) {
          logger.warn(`${logPrefix} [Ë≠¶Âëä] ÂÖÉÊï∞ÊçÆ‰∏∫Á©∫`);
        }

        const bansLoaded = await MiaoPluginMBT.LoadUserBans(true, logger);
        if (!bansLoaded) {
          logger.warn(`${logPrefix} [Ë≠¶Âëä] Âä†ËΩΩÁî®Êà∑Â∞ÅÁ¶ÅÂàóË°®Â§±Ë¥•`);
        }

        const aliasLoaded = await MiaoPluginMBT.LoadAliasData(true, logger);
        if (!MiaoPluginMBT._aliasData?.combined) {
          logger.warn(`${logPrefix} [Ë≠¶Âëä] Âä†ËΩΩÂà´ÂêçÊï∞ÊçÆÂ§±Ë¥•`);
          MiaoPluginMBT._aliasData = { combined: {} };
        } else if (!aliasLoaded) {
          logger.warn(`${logPrefix} [Ë≠¶Âëä] ÈÉ®ÂàÜÂà´ÂêçÂä†ËΩΩÂ§±Ë¥•`);
        } else if (
          Object.keys(MiaoPluginMBT._aliasData.combined).length === 0
        ) {
          logger.warn(`${logPrefix} [Ë≠¶Âëä] Âà´ÂêçÊï∞ÊçÆ‰∏∫Á©∫`);
        }

        await MiaoPluginMBT.GenerateAndApplyBanList(localImgDataCache, logger);
        MiaoPluginMBT._imgDataCache = Object.freeze(localImgDataCache);

        try {
          await fsPromises.access(MiaoPluginMBT.paths.backgroundImgPath);
          const files = await fsPromises.readdir(
            MiaoPluginMBT.paths.backgroundImgPath
          );
          MiaoPluginMBT._backgroundImages = files.filter((file) =>
            /\.webp$/i.test(file)
          );
          if (MiaoPluginMBT._backgroundImages.length > 0) {
            logger.info(
              `${logPrefix} [ÂàùÂßãÂåñ] Âä†ËΩΩ‰∫Ü ${MiaoPluginMBT._backgroundImages.length} Âº†ËÉåÊôØÂõæ`
            );
          }
        } catch (err) {
          if (err.code !== ERROR_CODES.NotFound) {
            logger.error(`${logPrefix} [ÂàùÂßãÂåñ] ËØªÂèñËÉåÊôØÂõæÁâáÁõÆÂΩïÊó∂Âá∫Èîô:`, err);
          }
          MiaoPluginMBT._backgroundImages = [];
        }

        MiaoPluginMBT.isGloballyInitialized = true;
        logger.info(`${logPrefix} ÂÖ®Â±ÄÂàùÂßãÂåñÊàêÂäü„ÄÇ`);

        if (!MiaoPluginMBT.oldFileDeletionScheduled) {
          MiaoPluginMBT.oldFileDeletionScheduled = true;
          const delaySeconds = 15;
          logger.info(
            `${logPrefix} [ÂàùÂßãÂåñ] Â∑≤Ë∞ÉÂ∫¶Âª∂Ëøü ${delaySeconds} ÁßíÂêéÊ∏ÖÁêÜÊóßÊñá‰ª∂‰ªªÂä°„ÄÇ`
          );
          setTimeout(async () => {
            const oldPluginFileName = "ÂíïÂíïÁâõÂõæÂ∫ì‰∏ãËΩΩÂô®.js";
            const oldPluginPath = path.join(
              MiaoPluginMBT.paths.target.exampleJs,
              oldPluginFileName
            );
            try {
              await fsPromises.access(oldPluginPath);
              logger.warn(
                `${logPrefix} [Âª∂ËøüÊ∏ÖÁêÜ] Ê£ÄÊµãÂà∞ÊóßÊèí‰ª∂Êñá‰ª∂ (${oldPluginFileName})ÔºåÂ∞ÜÂ∞ùËØïÂà†Èô§...`
              );
              await fsPromises.unlink(oldPluginPath);
              logger.info(
                `${logPrefix} [Âª∂ËøüÊ∏ÖÁêÜ] ÊóßÊèí‰ª∂Êñá‰ª∂ (${oldPluginFileName}) Â∑≤ÊàêÂäüÂà†Èô§„ÄÇ`
              );
            } catch (err) {
              if (err.code !== ERROR_CODES.NotFound) {
                logger.error(
                  `${logPrefix} [Âª∂ËøüÊ∏ÖÁêÜ] Âà†Èô§ÊóßÊèí‰ª∂Êñá‰ª∂ (${oldPluginPath}) Êó∂Âá∫Èîô:`,
                  err
                );
              } else {
                // logger.debug(`${logPrefix} [Âª∂ËøüÊ∏ÖÁêÜ] Êú™Ê£ÄÊµãÂà∞ÊóßÊèí‰ª∂Êñá‰ª∂ÔºåÊó†ÈúÄÊ∏ÖÁêÜ„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
              }
            }
          }, delaySeconds * 1000);
        }
      } catch (error) {
        fatalError = error;
        MiaoPluginMBT.isGloballyInitialized = false;
        logger.error(
          `${logPrefix} !!! ÂÖ®Â±ÄÂàùÂßãÂåñÂ§±Ë¥•: ${fatalError.message} !!!`
        );
        logger.error(fatalError.stack);
        MiaoPluginMBT._imgDataCache = Object.freeze([]);
        MiaoPluginMBT._userBanSet = new Set();
        MiaoPluginMBT._activeBanSet = new Set();
        MiaoPluginMBT._aliasData = null;
        throw fatalError;
      } finally {
        MiaoPluginMBT.isInitializing = false;
        // logger.debug(`${logPrefix} [ÂàùÂßãÂåñ] ÂêåÊ≠•ÈîÅÂ∑≤ÈáäÊîæ„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
      }
    })();

    MiaoPluginMBT.initializationPromise.catch((err) => {});

    return MiaoPluginMBT.initializationPromise;
  }

  /**
   * @description Âä†ËΩΩÂõæÂ∫ìÈÖçÁΩÆÊñá‰ª∂„ÄÇ
   *              ‰ºòÂåñÁ±ªÂûãÂ§ÑÁêÜÔºåÂÖºÂÆπ YAML ‰∏≠ÁöÑ 0/1ÔºåÁßªÈô§ÂÜÖÈÉ®ÈîÅ„ÄÇ
   */
  static async LoadTuKuConfig(
    forceReload = false,
    logger = global.logger || console,
    configPath = MiaoPluginMBT.paths.configFilePath
  ) {
    const logPrefix = Default_Config.logPrefix;
    try {
      if (
        !forceReload &&
        MiaoPluginMBT.MBTConfig &&
        Object.keys(MiaoPluginMBT.MBTConfig).length > 0
      ) {
        return MiaoPluginMBT.MBTConfig;
      }

      let configData = {};
      try {
        await fsPromises.access(configPath);
        const content = await fsPromises.readFile(configPath, "utf8");
        configData = yaml.parse(content) || {};
      } catch (error) {
        if (error.code === ERROR_CODES.NotFound) {
          logger.info(
            `${logPrefix} [Âä†ËΩΩÈÖçÁΩÆ] ${configPath} Êú™ÊâæÂà∞ÔºåÂ∞Ü‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ„ÄÇ`
          );
          configData = {};
        } else {
          logger.error(
            `${logPrefix} [Âä†ËΩΩÈÖçÁΩÆ] ËØªÂèñÊàñËß£ÊûêÈÖçÁΩÆÊñá‰ª∂ ${configPath} Â§±Ë¥•:`,
            error
          );
          configData = {};
        }
      }

      const parseBoolOrNum = (value, defaultValue) => {
        if (value === 1 || String(value).toLowerCase() === "true") return true;
        if (value === 0 || String(value).toLowerCase() === "false")
          return false;
        return defaultValue;
      };

      const loadedConfig = {
        TuKuOP: parseBoolOrNum(configData.TuKuOP, Default_Config.defaultTuKuOp),
        PFL: configData.PFL ?? Default_Config.defaultPfl,
        Ai: parseBoolOrNum(configData.Ai, true),
        EasterEgg: parseBoolOrNum(configData.EasterEgg, true),
        layout: parseBoolOrNum(configData.layout, true),
        PM18: parseBoolOrNum(configData.PM18, false),
        Main_Github_URL: Default_Config.Main_Github_URL,
        Ass_Github_URL: Default_Config.Ass_Github_URL,
        Sexy_Github_URL: Default_Config.Sexy_Github_URL,
        SepositoryBranch: Default_Config.SepositoryBranch,
        cronUpdate: configData.cronUpdate ?? Default_Config.cronUpdate,
      };

      if (
        ![
          Purify_Level.NONE,
          Purify_Level.RX18_ONLY,
          Purify_Level.PX18_PLUS,
        ].includes(loadedConfig.PFL)
      ) {
        logger.warn(
          `${logPrefix} [Âä†ËΩΩÈÖçÁΩÆ] Ê£ÄÊµãÂà∞Êó†ÊïàÁöÑÂáÄÂåñÁ≠âÁ∫ßÈÖçÁΩÆ (${loadedConfig.PFL})ÔºåÂ∑≤ÈáçÁΩÆ‰∏∫ÈªòËÆ§ÂÄº (${Default_Config.defaultPfl})„ÄÇ`
        );
        loadedConfig.PFL = Default_Config.defaultPfl;
      }

      MiaoPluginMBT.MBTConfig = loadedConfig;
      logger.info(
        `${logPrefix} [Âä†ËΩΩÈÖçÁΩÆ] ÂÆåÊàê: ÂõæÂ∫ì=${
          loadedConfig.TuKuOP ? "ÂºÄ" : "ÂÖ≥"
        }, PFL=${loadedConfig.PFL},  Ai=${loadedConfig.Ai}, ÂΩ©Ëõã=${loadedConfig.EasterEgg}, Ê®™Â±è=${loadedConfig.layout}, PM18=${loadedConfig.PM18}`);
      return MiaoPluginMBT.MBTConfig;
    } finally {
      // Êó†ÈîÅÊìç‰Ωú
    }
  }

  /**
   * @description ‰øùÂ≠òÂõæÂ∫ìÈÖçÁΩÆÂà∞Êñá‰ª∂„ÄÇ
   *              Â¢ûÂä†Êñá‰ª∂ÂÜôÂÖ•ËØäÊñ≠Êó•ÂøóÔºåÁ°ÆËÆ§ÂÜôÂÖ•Êìç‰Ωú„ÄÇ
   */
  static async SaveTuKuConfig(configData, logger = global.logger || console) {
    const logPrefix = Default_Config.logPrefix;
    const configFilePath = MiaoPluginMBT.paths.configFilePath;

    try {
      const dataToSave = {
        TuKuOP: configData.TuKuOP ? 1 : 0,
        PFL: configData.PFL,
        Ai: configData.Ai ? 1 : 0,
        EasterEgg: configData.EasterEgg ? 1 : 0,
        layout: configData.layout ? 1 : 0,
        PM18: configData.PM18 ? 1 : 0,
        cronUpdate: configData.cronUpdate,
      };
      // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] ÂáÜÂ§á‰øùÂ≠òÁöÑÊï∞ÊçÆ:`, dataToSave); //Ë∞ÉËØïÊó•Âøó

      const dirPath = path.dirname(configFilePath);
      // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] ÂáÜÂ§áÂàõÂª∫ÁõÆÂΩï: ${dirPath}`); //Ë∞ÉËØïÊó•Âøó
      try {
        await fsPromises.mkdir(dirPath, { recursive: true });
        // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] ÁõÆÂΩïÂàõÂª∫ÂÆåÊàê/Â∑≤Â≠òÂú®„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
      } catch (mkdirError) {
        logger.error(
          `${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] ÂàõÂª∫ÁõÆÂΩï ${dirPath} Â§±Ë¥•:`,
          mkdirError
        );
        return false;
      }

      // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] ÂáÜÂ§áÂ∫èÂàóÂåñ YAML...`); //Ë∞ÉËØïÊó•Âøó
      const yamlString = yaml.stringify(dataToSave);
      // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] YAML Â∫èÂàóÂåñÂÆåÊàê„ÄÇÂáÜÂ§áÂÜôÂÖ•Êñá‰ª∂: ${configFilePath}`); //Ë∞ÉËØïÊó•Âøó
      // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] Âç≥Â∞ÜÊâßË°å await fsPromises.writeFile...`); //Ë∞ÉËØïÊó•Âøó

      await fsPromises.writeFile(configFilePath, yamlString, "utf8");
      // logger.info(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] fsPromises.writeFile Ë∞ÉÁî®ÂÆåÊàê„ÄÇ`); //Ë∞ÉËØïÊó•Âøó

      logger.info(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] ÊàêÂäü‰øùÂ≠òÈÖçÁΩÆÂà∞ ${configFilePath}`);

      MiaoPluginMBT.MBTConfig = { ...MiaoPluginMBT.MBTConfig, ...configData };
      // logger.debug(`${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] [ËØäÊñ≠ V1.21] ÂÜÖÂ≠òÈÖçÁΩÆÂ∑≤Êõ¥Êñ∞„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
      return true;
    } catch (error) {
      logger.error(
        `${logPrefix} [‰øùÂ≠òÈÖçÁΩÆ] ÂÜôÂÖ•ÈÖçÁΩÆÊñá‰ª∂ ${configFilePath} Â§±Ë¥•:`,
        error
      );
      return false;
    }
  }

  /**
   * @description Âä†ËΩΩÂõæÁâáÂÖÉÊï∞ÊçÆ (imagedata.json)ÔºåÊîØÊåÅÂõûÈÄÄ„ÄÇ
   */
  static async LoadImageData(
    forceReload = false,
    logger = global.logger || console
  ) {
    if (MiaoPluginMBT._imgDataCache?.length > 0 && !forceReload) {
      return MiaoPluginMBT._imgDataCache;
    }
    let data = null;
    let success = false;
    const primaryPath = MiaoPluginMBT.paths.imageDataPath;
    const secondaryPath = path.join(
      MiaoPluginMBT.paths.LocalTuKuPath,
      MiaoPluginMBT.paths.sourceFolders.gallery,
      path.basename(MiaoPluginMBT.paths.imageDataPath)
    );
    try {
      const content = await fsPromises.readFile(primaryPath, "utf8");
      data = JSON.parse(content);
      success = true;
    } catch (error) {
      if (error.code === ERROR_CODES.NotFound) {
        try {
          await fsPromises.access(secondaryPath);
          const sourceContent = await fsPromises.readFile(
            secondaryPath,
            "utf8"
          );
          data = JSON.parse(sourceContent);
          logger.info(
            `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] ‰ªé‰ªìÂ∫ìÊ∫êÂä†ËΩΩÊàêÂäü: ${secondaryPath}`
          );
          success = true;
        } catch (srcError) {
          if (srcError.code === ERROR_CODES.NotFound) {
            data = null;
            success = false;
          } else {
            logger.error(
              `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Âä†ËΩΩÊàñËß£Êûê‰ªìÂ∫ìÊ∫êÊñá‰ª∂Â§±Ë¥• (${secondaryPath}):`,
              srcError
            );
            data = null;
            success = false;
          }
        }
      } else {
        logger.error(
          `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] ËØªÂèñÊàñËß£Êûê‰∏ªË∑ØÂæÑÊñá‰ª∂Â§±Ë¥• (${primaryPath}):`,
          error
        );
        data = null;
        success = false;
      }
    }
    let finalData = [];
    if (!success || !Array.isArray(data) || data.length === 0) {
      if (!success)
        logger.warn(
          `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Êó†Ê≥ï‰ªéÊñá‰ª∂Âä†ËΩΩÂÖÉÊï∞ÊçÆÔºåÊâßË°åÊâ´ÊèèÂõûÈÄÄ...`
        );
      else
        logger.warn(
          `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Âä†ËΩΩÁöÑÂÖÉÊï∞ÊçÆ‰∏∫Á©∫ÊàñÊ†ºÂºèÈîôËØØÔºåÊâßË°åÊâ´ÊèèÂõûÈÄÄ...`
        );
      try {
        finalData = await MiaoPluginMBT.ScanLocalImagesToBuildCache(logger);
        logger.info(
          `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Êâ´ÊèèÂõûÈÄÄÂÆåÊàêÔºåÊâæÂà∞ ${finalData.length} ‰∏™ÂõæÁâáÊñá‰ª∂„ÄÇ`
        );
      } catch (scanError) {
        logger.error(
          `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Êâ´ÊèèÂõûÈÄÄËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:`,
          scanError
        );
        finalData = [];
      }
    } else {
      finalData = data;
    }
    if (Array.isArray(finalData)) {
      const originalCount = finalData.length;
      const validData = finalData
        .filter((item) => {
          const isBasicValid =
            item &&
            typeof item.path === "string" &&
            item.path.trim() !== "" &&
            typeof item.characterName === "string" &&
            item.characterName.trim() !== "" &&
            typeof item.attributes === "object" &&
            typeof item.storagebox === "string" &&
            item.storagebox.trim() !== "";
          if (!isBasicValid) {
            // logger.warn(`${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] ËøáÊª§ÊéâÊó†ÊïàÊàñÁº∫Â∞ë storagebox ÁöÑÂÖÉÊï∞ÊçÆÈ°π:`, item); //ÁßªÈô§Âà∑Â±èÊó•Âøó
            return false;
          }
          const pathRegex = /^[a-z]+-character\/[^/]+\/[^/]+Gu\d+\.webp$/i;
          const normalizedPath = item.path.replace(/\\/g, "/");
          const pathIsValid = pathRegex.test(normalizedPath);
          if (!pathIsValid)
            logger.warn(
              `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] ËøáÊª§ÊéâÊ†ºÂºèÈîôËØØÁöÑÂõæÁâáË∑ØÂæÑ: ${item.path}`
            );
          return pathIsValid;
        })
        .map((item) => ({ ...item, path: item.path.replace(/\\/g, "/") }));
      const validCount = validData.length;
      const invalidCount = originalCount - validCount;
      if (invalidCount > 0)
        logger.warn(
          `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Âú®Â§ÑÁêÜËøáÁ®ã‰∏≠ÂøΩÁï•‰∫Ü ${invalidCount} Êù°Êó†ÊïàÊàñÊ†ºÂºèÈîôËØØÁöÑÂÖÉÊï∞ÊçÆ„ÄÇ`
        );
      logger.info(
        `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] Â§ÑÁêÜÂÆåÊàêÔºåÊúÄÁªàËé∑Âæó ${validCount} Êù°ÊúâÊïàÂõæÁâáÂÖÉÊï∞ÊçÆ„ÄÇ`
      );
      return validData;
    } else {
      logger.error(
        `${Default_Config.logPrefix} [Âä†ËΩΩÂÖÉÊï∞ÊçÆ] CRITICAL: ÊúÄÁªàÂÖÉÊï∞ÊçÆÁªìÊûú‰∏çÊòØ‰∏Ä‰∏™Êï∞ÁªÑÔºÅËøîÂõûÁ©∫Êï∞ÁªÑ„ÄÇ`
      );
      return [];
    }
  }

  /**
   * @description Êâ´ÊèèÊú¨Âú∞‰ªìÂ∫ìÁõÆÂΩïÔºåÊûÑÂª∫Âü∫Á°ÄÁöÑÂõæÁâáÂÖÉÊï∞ÊçÆÁºìÂ≠ò (Áî®‰∫éÂõûÈÄÄ)„ÄÇ
   */
  static async ScanLocalImagesToBuildCache(logger = global.logger || console) {
    const fallbackCache = [];
    const ReposToScan = [];

    const repoPaths = {
      "Miao-Plugin-MBT": MiaoPluginMBT.paths.LocalTuKuPath,
      "Miao-Plugin-MBT-2": MiaoPluginMBT.paths.LocalTuKuPath2,
      "Miao-Plugin-MBT-3": MiaoPluginMBT.paths.LocalTuKuPath3,
    };

    for (const storageBoxName in repoPaths) {
      const repoPath = repoPaths[storageBoxName];
      if (!repoPath) continue;

      let repoNum = 0; // Á°ÆÂÆö‰ªìÂ∫ìÁºñÂè∑
      if (storageBoxName === "Miao-Plugin-MBT") repoNum = 1;
      else if (storageBoxName === "Miao-Plugin-MBT-2") repoNum = 2;
      else if (storageBoxName === "Miao-Plugin-MBT-3") repoNum = 3;

      if (repoNum > 0 && (await MiaoPluginMBT.IsTuKuDownloaded(repoNum))) {
        ReposToScan.push({ path: repoPath, name: storageBoxName });
      }
    }

    if (ReposToScan.length === 0) {
      logger.warn(
        `${Default_Config.logPrefix} [Êâ´ÊèèÂõûÈÄÄ] Ê≤°ÊúâÊâæÂà∞Êú¨Âú∞ÂõæÂ∫ì‰ªìÂ∫ìÁõÆÂΩïÔºåÊó†Ê≥ïÊâ´Êèè„ÄÇ`
      );
      return [];
    }

    logger.info(
      `${
        Default_Config.logPrefix
      } [Êâ´ÊèèÂõûÈÄÄ] ÂºÄÂßãÊâ´ÊèèÊú¨Âú∞‰ªìÂ∫ì: ${ReposToScan.map((r) => r.name).join(
        ", "
      )}...`
    );
    const imagePathsFound = new Set();

    for (const Repo of ReposToScan) {
      for (const gameFolderKey of Object.keys(
        MiaoPluginMBT.paths.sourceFolders
      )) {
        if (gameFolderKey === "gallery") continue;
        const sourceFolderName =
          MiaoPluginMBT.paths.sourceFolders[gameFolderKey];
        if (!sourceFolderName) continue;

        const gameFolderPath = path.join(Repo.path, sourceFolderName);
        try {
          await fsPromises.access(gameFolderPath);
          const characterDirs = await fsPromises.readdir(gameFolderPath, {
            withFileTypes: true,
          });

          for (const charDir of characterDirs) {
            if (charDir.isDirectory()) {
              const characterName = charDir.name;
              const charFolderPath = path.join(gameFolderPath, characterName);

              try {
                const imageFiles = await fsPromises.readdir(charFolderPath);
                for (const imageFile of imageFiles) {
                  if (imageFile.toLowerCase().endsWith(".webp")) {
                    const relativePath = path
                      .join(sourceFolderName, characterName, imageFile)
                      .replace(/\\/g, "/");
                    if (!imagePathsFound.has(relativePath)) {
                      fallbackCache.push({
                        storagebox: Repo.name,
                        path: relativePath,
                        characterName: characterName,
                        attributes: {},
                      });
                      imagePathsFound.add(relativePath);
                    }
                  }
                }
              } catch (readCharErr) {
                if (
                  readCharErr.code !== ERROR_CODES.NotFound &&
                  readCharErr.code !== ERROR_CODES.Access
                )
                  logger.warn(
                    `${Default_Config.logPrefix} [Êâ´ÊèèÂõûÈÄÄ] ËØªÂèñËßíËâ≤ÁõÆÂΩï ${charFolderPath} Â§±Ë¥•:`,
                    readCharErr.code
                  );
              }
            }
          }
        } catch (readGameErr) {
          if (
            readGameErr.code !== ERROR_CODES.NotFound &&
            readGameErr.code !== ERROR_CODES.Access
          )
            logger.warn(
              `${Default_Config.logPrefix} [Êâ´ÊèèÂõûÈÄÄ] ËØªÂèñÊ∏∏ÊàèÁõÆÂΩï ${gameFolderPath} Â§±Ë¥•:`,
              readGameErr.code
            );
        }
      }
    }
    logger.info(
      `${Default_Config.logPrefix} [Êâ´ÊèèÂõûÈÄÄ] Êâ´ÊèèÂÆåÊàêÔºåÂÖ±ÊâæÂà∞ ${fallbackCache.length} ‰∏™Áã¨Á´ãÁöÑ .webp ÂõæÁâáÊñá‰ª∂„ÄÇ`
    );
    return fallbackCache;
  }

  /**
   * @description ÁîüÊàêÂπ∂Â∫îÁî®ÂΩìÂâçÁöÑÁîüÊïàÂ∞ÅÁ¶ÅÂàóË°®ÔºàÂêàÂπ∂Áî®Êà∑Â∞ÅÁ¶ÅÂíåÂáÄÂåñËßÑÂàôÔºâ„ÄÇ
   */
  static async GenerateAndApplyBanList(
    imageData,
    logger = global.logger || console
  ) {
    const effectiveBanSet = MiaoPluginMBT.GenerateBanList(imageData, logger);
    await MiaoPluginMBT.ApplyBanList(effectiveBanSet, logger);
  }

  /**
   * @description Ê†πÊçÆÂáÄÂåñÁ≠âÁ∫ß„ÄÅÂÖ®Â±ÄÂºÄÂÖ≥ÂíåÁî®Êà∑Â∞ÅÁ¶ÅÁîüÊàêÊúÄÁªàÁîüÊïàÁöÑÂ∞ÅÁ¶Å Set„ÄÇ
   */
  static GenerateBanList(imageData, logger = global.logger || console) {
    const effectiveBans = new Set(MiaoPluginMBT._userBanSet);
    const initialUserBansCount = effectiveBans.size;

    const pflLevel = MiaoPluginMBT.MBTConfig?.PFL ?? Default_Config.defaultPfl;
    let pflPurifiedCount = 0;
    if (
      pflLevel > Purify_Level.NONE &&
      Array.isArray(imageData) &&
      imageData.length > 0
    ) {
      imageData.forEach((d) => {
        if (MiaoPluginMBT.CheckIfPurifiedByLevel(d, pflLevel)) {
          const normalizedPath = d.path?.replace(/\\/g, "/");
          if (normalizedPath && !effectiveBans.has(normalizedPath)) {
            effectiveBans.add(normalizedPath);
            pflPurifiedCount++;
          }
        }
      });
    } else if (pflLevel > Purify_Level.NONE) {
      logger.warn(
        `${Default_Config.logPrefix} [ÁîüÊàêÂ∞ÅÁ¶Å] PFL=${pflLevel} ‰ΩÜÂÖÉÊï∞ÊçÆÊó†ÊïàÊàñ‰∏∫Á©∫ÔºåÊó†Ê≥ïÊâßË°å PFL ÂáÄÂåñ„ÄÇ`
      );
    }

    const config = MiaoPluginMBT.MBTConfig;
    const filterAi = config?.Ai === false;
    const filterEasterEgg = config?.EasterEgg === false;
    const filterLayout = config?.layout === false;
    let switchPurifiedCount = 0;

    if (
      (filterAi || filterEasterEgg || filterLayout) &&
      Array.isArray(imageData) &&
      imageData.length > 0
    ) {
      imageData.forEach((item) => {
        const attrs = item?.attributes;
        if (!attrs) return;
        const normalizedPath = item.path?.replace(/\\/g, "/");
        if (!normalizedPath) return;

        let shouldBanBySwitch = false;
        if (filterAi && attrs.isAiImage === true) shouldBanBySwitch = true;
        if (filterEasterEgg && attrs.isEasterEgg === true)
          shouldBanBySwitch = true;
        if (filterLayout && attrs.layout === "fullscreen")
          shouldBanBySwitch = true;

        if (shouldBanBySwitch && !effectiveBans.has(normalizedPath)) {
          effectiveBans.add(normalizedPath);
          switchPurifiedCount++;
        }
      });
    }

    logger.info(
      `${
        Default_Config.logPrefix
      } [ÁîüÊàêÂ∞ÅÁ¶Å] Á≠âÁ∫ßPFL=${pflLevel} (${Purify_Level.getDescription(
        pflLevel
      )}), ÂºÄÂÖ≥(Ai:${!filterAi},ÂΩ©Ëõã:${!filterEasterEgg},Ê®™Â±è:${!filterLayout})`
    );
    logger.info(
      `${Default_Config.logPrefix} [ÁîüÊàêÂ∞ÅÁ¶Å] ÁªìÊûú: ÊâãÂä®=${initialUserBansCount}, PFLÂ±èËîΩ=${pflPurifiedCount}, ÂºÄÂÖ≥Â±èËîΩ=${switchPurifiedCount}, ÊÄªÁîüÊïà=${effectiveBans.size}`
    );

    MiaoPluginMBT._activeBanSet = effectiveBans;
    return MiaoPluginMBT._activeBanSet;
  }
  /**
   * @description Ê†πÊçÆÈÖçÁΩÆÂºÄÂÖ≥ËøáÊª§ÂõæÁâáÂàóË°® (‰∏ç‰øÆÊîπÂéüÊï∞ÁªÑ)
   */
  static FilterImagesBySwitches(images, config) {
    if (!Array.isArray(images)) return [];
    if (!config) return [...images];

    const filterAi = config.Ai === false;
    const filterEasterEgg = config.EasterEgg === false;
    const filterLayout = config.layout === false;

    if (!filterAi && !filterEasterEgg && !filterLayout) {
      return [...images];
    }

    return images.filter((item) => {
      const attrs = item?.attributes;
      if (!attrs) return true;

      if (filterAi && attrs.isAiImage === true) return false;
      if (filterEasterEgg && attrs.isEasterEgg === true) return false;
      if (filterLayout && attrs.layout === "fullscreen") return false;

      return true;
    });
  }

  /**
   * @description Ê£ÄÊü•Âçï‰∏™ÂõæÁâáÊï∞ÊçÆÈ°πÊòØÂê¶Â∫îÊ†πÊçÆÊåáÂÆöÂáÄÂåñÁ≠âÁ∫ßË¢´Â±èËîΩ„ÄÇ
   */
  static CheckIfPurifiedByLevel(imgDataItem, purifyLevel) {
    if (!imgDataItem?.attributes) return false;
    const attrs = imgDataItem.attributes;
    const isRx18 =
      attrs.isRx18 === true || String(attrs.isRx18).toLowerCase() === "true";
    const isPx18 =
      attrs.isPx18 === true || String(attrs.isPx18).toLowerCase() === "true";
    if (purifyLevel === Purify_Level.RX18_ONLY) {
      return isRx18;
    } else if (purifyLevel === Purify_Level.PX18_PLUS) {
      return isRx18 || isPx18;
    }
    return false;
  }

  /**
   * @description Ëé∑ÂèñÈöèÊú∫ËÉåÊôØÂõæÁâáÁöÑ file:// URI
   */
  static getRandomBgImageUrl() {
    if (
      !MiaoPluginMBT._backgroundImages ||
      MiaoPluginMBT._backgroundImages.length === 0
    ) {
      return "";
    }
    const randomIndex = Math.floor(
      Math.random() * MiaoPluginMBT._backgroundImages.length
    );
    const randomFileName = MiaoPluginMBT._backgroundImages[randomIndex];
    const absolutePath = path.join(
      MiaoPluginMBT.paths.backgroundImgPath,
      randomFileName
    );
    return `file://${absolutePath.replace(/\\/g, "/")}`;
  }

  /**
   * @description Ê£ÄÊü•ÁªôÂÆöÁõ∏ÂØπË∑ØÂæÑÁöÑÂõæÁâáÊòØÂê¶Ë¢´ÂΩìÂâçÁîüÊïàÁöÑÂ∞ÅÁ¶ÅÂàóË°®ÔºàÊâãÂä®ÊàñÂáÄÂåñÔºâÂ±èËîΩ„ÄÇ
   */
  static async CheckIfPurified(
    relativePath,
    logger = global.logger || console
  ) {
    const normalizedPath = relativePath?.replace(/\\/g, "/");
    if (!normalizedPath) return false;
    if (MiaoPluginMBT._activeBanSet.has(normalizedPath)) return true;
    const imgData = MiaoPluginMBT._imgDataCache.find(
      (img) => img.path === normalizedPath
    );
    if (imgData) {
      const level = MiaoPluginMBT.MBTConfig?.PFL ?? Default_Config.defaultPfl;
      return MiaoPluginMBT.CheckIfPurifiedByLevel(imgData, level);
    }
    return false;
  }

  /**
   * @description ÂêëÁî®Êà∑Êä•ÂëäÈîôËØØÔºå‰ºòÂÖà‰ΩøÁî®ÂêàÂπ∂ËΩ¨ÂèëÊ∂àÊÅØÔºåÂ§±Ë¥•ÂàôÂõûÈÄÄÊñáÊú¨„ÄÇ
   */
  static async ReportError(
    e,
    operationName,
    error,
    context = "",
    logger = global.logger || console
  ) {
    const Report = MiaoPluginMBT.FormatError(operationName, error, context);
    logger.error(
      `${Default_Config.logPrefix} [${operationName}] Êìç‰ΩúÂ§±Ë¥•:`,
      error?.message || error,
      error?.stack ? `\nStack(ÈÉ®ÂàÜ): ${error.stack.substring(0, 500)}...` : "",
      context ? `\nContext: ${context}` : ""
    );
    const messagesToSend = [];
    if (Report.summary) messagesToSend.push(Report.summary);
    if (Report.suggestions)
      messagesToSend.push(`„Äêü§î ÂèØËÉΩÂéüÂõ†‰∏éÂª∫ËÆÆ„Äë\n${Report.suggestions}`);
    if (Report.contextInfo)
      messagesToSend.push(`„Äê‚ÑπÔ∏è ‰∏ä‰∏ãÊñá‰ø°ÊÅØ„Äë\n${Report.contextInfo}`);
    if (Report.stack) {
      const maxStackLength = 1000;
      const stackInfo =
        Report.stack.length > maxStackLength
          ? Report.stack.substring(0, maxStackLength) + "... (ÂêéÈù¢ÁúÅÁï•‰∫Ü)"
          : Report.stack;
      messagesToSend.push(`„Äêüõ†Ô∏è ÊäÄÊúØÁªÜËäÇ - Ë∞ÉÁî®Ê†à(ÈÉ®ÂàÜ)„Äë\n${stackInfo}`);
    }
    try {
      const shortMessage = `${
        Default_Config.logPrefix
      } ÊâßË°å ${operationName} Êìç‰ΩúÊó∂ÈÅáÂà∞ÁÇπÈóÆÈ¢òÔºÅ(ÈîôËØØÁ†Å: ${
        error?.code || "Êú™Áü•"
      })`;
      await e.reply(shortMessage, true);
      if (messagesToSend.length > 0 && common?.makeForwardMsg) {
        try {
          const forwardMsg = await common.makeForwardMsg(
            e,
            messagesToSend,
            `${Default_Config.logPrefix} ${operationName} Â§±Ë¥•Êó•Âøó`
          );
          if (forwardMsg) {
            await e.reply(forwardMsg);
          } else {
            throw new Error("makeForwardMsg returned nullish");
          }
        } catch (forwardError) {
          logger.warn(
            `${Default_Config.logPrefix} [ÈîôËØØÊä•Âëä] ÂàõÂª∫/ÂèëÈÄÅÂêàÂπ∂Ê∂àÊÅØÂ§±Ë¥• (${forwardError.message})ÔºåÂ∞ùËØïÂèëÈÄÅÊñáÊú¨...`
          );
          if (Report.summary)
            await e.reply(
              Report.summary.substring(0, 300) +
                (Report.summary.length > 300 ? "..." : "")
            );
          if (Report.suggestions)
            await e.reply(
              `„Äêü§î Âª∫ËÆÆ„Äë\n${
                Report.suggestions.substring(0, 300) +
                (Report.suggestions.length > 300 ? "..." : "")
              }`
            );
          await e.reply("(ËØ¶ÁªÜ‰ø°ÊÅØËØ∑Â∫∑Â∫∑ÊéßÂà∂Âè∞Êó•ÂøóÂì¶)");
        }
      } else {
        logger.warn(
          `${Default_Config.logPrefix} [ÈîôËØØÊä•Âëä] Êó†Ê≥ïÂàõÂª∫ÂêàÂπ∂Ê∂àÊÅØ (common.makeForwardMsg ‰∏çÂèØÁî®ÊàñÊ∂àÊÅØ‰∏∫Á©∫)„ÄÇ`
        );
        await e.reply("(ËØ¶ÁªÜÈîôËØØ‰ø°ÊÅØËØ∑Â∫∑Â∫∑ÊéßÂà∂Âè∞Êó•ÂøóÂìà)");
      }
    } catch (reportError) {
      logger.error(
        `${Default_Config.logPrefix} [ÈîôËØØÊä•Âëä] CRITICAL: Êä•ÂëäÈîôËØØÊó∂‰πüÂèëÁîüÈîôËØØ:`,
        reportError
      );
      logger.error(
        `${Default_Config.logPrefix} === ÂéüÂßãÈîôËØØ (${operationName}) ===`,
        error
      );
    }
  }

  /**
   * @description Ê†ºÂºèÂåñÈîôËØØ‰ø°ÊÅØÔºåÁîüÊàêÂåÖÂê´ÊëòË¶Å„ÄÅÂª∫ËÆÆ„ÄÅ‰∏ä‰∏ãÊñáÂíåÂ†ÜÊ†àÁöÑÊä•ÂëäÂØπË±°„ÄÇ
   */
  static FormatError(operationName, error, context = "") {
    const Report = {
      summary: `${Default_Config.logPrefix} Êìç‰Ωú [${operationName}] Â§±Ë¥•‰∫ÜÔºÅ`,
      contextInfo: context || "ÔºàÊ≤°Âï•È¢ùÂ§ñ‰ø°ÊÅØÔºâ",
      suggestions: "",
      stack: error?.stack || "ÔºàË∞ÉÁî®Ê†à‰ø°ÊÅØ‰∏¢Â§±‰∫ÜÔºâ",
    };
    if (error?.message) Report.summary += `\nÈîôËØØ‰ø°ÊÅØ: ${error.message}`;
    if (error?.code) Report.summary += ` (Code: ${error.code})`;
    if (error?.signal) Report.summary += ` (Signal: ${error.signal})`;
    const stderr = error?.stderr || "";
    const stdout = error?.stdout || "";
    const errorString = `${error?.message || ""} ${stderr} ${
      String(error?.code) || ""
    } ${context || ""}`.toLowerCase();
    const suggestionsMap = {
      "could not resolve host":
        "ÁΩëÁªúÈóÆÈ¢ò: ÊòØ‰∏çÊòØ DNS Ëß£Êûê‰∏ç‰∫Ü‰∏ªÊú∫ÔºüÊ£ÄÊü•‰∏ãÁΩëÁªúÂíå DNS ËÆæÁΩÆ„ÄÇ",
      "connection timed out":
        "ÁΩëÁªúÈóÆÈ¢ò: ËøûÊé•Ë∂ÖÊó∂‰∫ÜÔºåÁΩë‰∏çÂ•ΩÊàñËÄÖÂØπÈù¢ÊúçÂä°Âô®ÊåÇ‰∫ÜÔºü",
      "connection refused":
        "ÁΩëÁªúÈóÆÈ¢ò: ÂØπÈù¢ÊúçÂä°Âô®ÊãíÁªùËøûÊé•ÔºåÁ´ØÂè£ÂØπÂêóÔºüÈò≤ÁÅ´Â¢ôÂºÄ‰∫ÜÔºü",
      "ssl certificate problem":
        "ÁΩëÁªúÈóÆÈ¢ò: SSL ËØÅ‰π¶ÊúâÈóÆÈ¢òÔºåÁ≥ªÁªüÊó∂Èó¥ÂØπ‰∏çÂØπÔºüÊàñËÄÖÈúÄË¶ÅÊõ¥Êñ∞ËØÅ‰π¶Ôºü",
      "403 forbidden": "ËÆøÈóÆË¢´Êãí (403): Ê≤°ÊùÉÈôêËÆøÈóÆËøô‰∏™Âú∞ÂùÄÂì¶„ÄÇ",
      "404 not found": "ËµÑÊ∫êÊú™ÊâæÂà∞ (404): URL ÂÜôÈîô‰∫ÜÊàñËÄÖÊñá‰ª∂ÁúüÁöÑÊ≤°‰∫Ü„ÄÇ",
      "unable to access":
        "Git ËÆøÈóÆÂ§±Ë¥•: Ê£ÄÊü•ÁΩëÁªú„ÄÅURL„ÄÅ‰ª£ÁêÜËÆæÁΩÆÂØπ‰∏çÂØπÔºåÊàñËÄÖ‰ªìÂ∫ìÊòØ‰∏çÊòØÁßÅÊúâÁöÑÔºü",
      "authentication failed": "Git ËÆ§ËØÅÂ§±Ë¥•: Áî®Êà∑ÂêçÂØÜÁ†ÅÊàñËÄÖ Token ‰∏çÂØπÂêßÔºü",
      "permission denied":
        "ÊùÉÈôêÈóÆÈ¢ò: Yunzai Ê≤°ÊùÉÈôêËØªÂÜôÊñá‰ª∂ÊàñÁõÆÂΩïÔºåÊ£ÄÊü•‰∏ãÊñá‰ª∂Â§πÊùÉÈôê„ÄÇ",
      "index file corrupt":
        "Git ‰ªìÂ∫ìÂèØËÉΩÂùè‰∫Ü: ËØïËØïÊ∏ÖÁêÜ `.git/index` Êñá‰ª∂Ôºü‰∏çË°åÂ∞±Âæó #ÈáçÁΩÆÂíïÂíïÁâõ ‰∫Ü„ÄÇ",
      "lock file|index.lock":
        "Git Ê≠£ÂøôÁùÄÂë¢: Á≠â‰∏Ä‰∏ã‰∏ãÔºåÊàñËÄÖÊâãÂä®Ê∏ÖÁêÜ `.git/index.lock` Êñá‰ª∂ÔºàÂ∞èÂøÉÁÇπÔºÅÔºâ",
      "commit your changes or stash them":
        "Git ÂÜ≤Á™Å: Êú¨Âú∞Êñá‰ª∂ÊîπÂä®‰∫ÜÂíåËøúÁ®ãÂØπ‰∏ç‰∏äÔºåËØïËØï #Êõ¥Êñ∞ÂíïÂíïÁâõ Âº∫Âà∂Ë¶ÜÁõñÔºü",
      "not a git repository": "Git: ËøôÂú∞Êñπ‰∏çÊòØ‰∏™ Git ‰ªìÂ∫ìÂïä„ÄÇ",
      "unrelated histories": "Git ÂéÜÂè≤ÂÜ≤Á™Å: Ëøô‰∏™Âæó #ÈáçÁΩÆÂíïÂíïÁâõ ÊâçËÉΩËß£ÂÜ≥‰∫Ü„ÄÇ",
      "not possible to fast-forward":
        "Git: Êó†Ê≥ïÂø´ËøõÂêàÂπ∂Ôºå#Êõ¥Êñ∞ÂíïÂíïÁâõ Âº∫Âà∂Ë¶ÜÁõñËØïËØï„ÄÇ",
      [ERROR_CODES.NotFound]: "Êñá‰ª∂Á≥ªÁªü: Êâæ‰∏çÂà∞Êñá‰ª∂ÊàñÁõÆÂΩïÔºåË∑ØÂæÑÂØπÂêóÔºü",
      [ERROR_CODES.Access]: "Êñá‰ª∂Á≥ªÁªü: Ê≤°ÊùÉÈôêËÆøÈóÆËøô‰∏™Êñá‰ª∂ÊàñÁõÆÂΩï„ÄÇ",
      [ERROR_CODES.Busy]: "Êñá‰ª∂Á≥ªÁªü: Êñá‰ª∂ÊàñÁõÆÂΩïÊ≠£Ë¢´Âç†Áî®ÔºåÁ®çÂêéÂÜçËØïËØïÔºü",
      [ERROR_CODES.NotEmpty]: "Êñá‰ª∂Á≥ªÁªü: Êñá‰ª∂Â§πÈáåËøòÊúâ‰∏úË•øÔºåÂà†‰∏çÊéâ„ÄÇ",
      [ERROR_CODES.ConnReset]: "ÁΩëÁªú: ËøûÊé•Á™ÅÁÑ∂Êñ≠‰∫Ü„ÄÇ",
      [ERROR_CODES.Timeout]: "Êìç‰ΩúË∂ÖÊó∂‰∫ÜÔºåÁ≠âÂ§™‰πÖ‰∫Ü...",
      "json.parse":
        "Êï∞ÊçÆÈóÆÈ¢ò: JSON Êñá‰ª∂Ê†ºÂºè‰∏çÂØπÔºåÊ£ÄÊü•‰∏ã `imagedata.json` Êàñ `banlist.json`„ÄÇ",
      "yaml.parse":
        "ÈÖçÁΩÆÈóÆÈ¢ò: YAML Êñá‰ª∂Ê†ºÂºè‰∏çÂØπÔºåÊ£ÄÊü•‰∏ã `GalleryConfig.yaml`„ÄÇ",
    };
    let matchedSuggestion = null;
    if (
      error instanceof ReferenceError &&
      error.message.includes("is not defined")
    ) {
      matchedSuggestion =
        "‰ª£Á†ÅÂá∫Èîô‰∫Ü: ÂºïÁî®‰∫Ü‰∏çÂ≠òÂú®ÁöÑÂèòÈáèÊàñÂáΩÊï∞„ÄÇÂ¶ÇÊûúÊ≤°ÊîπËøá‰ª£Á†ÅÔºåÂèØËÉΩÊòØÊèí‰ª∂BugÔºåÂø´ÂéªÂèçÈ¶àÔºÅ";
    } else {
      for (const keyword in suggestionsMap) {
        const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const regex = new RegExp(escapedKeyword, "i");
        if (regex.test(errorString)) {
          matchedSuggestion = suggestionsMap[keyword];
          break;
        }
      }
    }
    let finalSuggestions = [];
    if (matchedSuggestion) {
      finalSuggestions.push(`- ${matchedSuggestion}`);
    } else {
      finalSuggestions.push("- ÊöÇÊó∂Ê≤°Â§¥Áª™ÔºåÁúãÁúã‰∏ãÈù¢ÁöÑÈÄöÁî®Âª∫ËÆÆÔºü");
    }
    finalSuggestions.push(
      "- Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊòØ‰∏çÊòØÈÄöÁïÖ„ÄÇ",
      "- Ê£ÄÊü• Yunzai ÁõÆÂΩïÂíåÊèí‰ª∂ÁõÆÂΩïÁöÑÊùÉÈôêËÆæÁΩÆ„ÄÇ",
      "- ‰ªîÁªÜÁúãÁúãÊéßÂà∂Âè∞ËæìÂá∫ÁöÑËØ¶ÁªÜÈîôËØØÊó•Âøó„ÄÇ"
    );
    if (operationName.includes("‰∏ãËΩΩ") || operationName.includes("Êõ¥Êñ∞")) {
      finalSuggestions.push(
        "- Á°Æ‰øùÁîµËÑë‰∏äÊ≠£Á°ÆÂÆâË£Ö‰∫Ü Git„ÄÇ",
        "- ËØïËØï `#ÂíïÂíïÁâõÊµãÈÄü` ÁúãÁúãÁΩëÁªúËäÇÁÇπÊÉÖÂÜµ„ÄÇ"
      );
    }
    finalSuggestions.push(
      "- ‰∏áËÉΩÂ§ßÊ≥ïÔºöÈáçÂêØ Yunzai-Bot ËØïËØïÔºü",
      "- Â¶ÇÊûú‰∏ÄÁõ¥‰∏çË°åÔºåÁªàÊûÅÂ§ßÊ≥ïÔºö`#ÈáçÁΩÆÂíïÂíïÁâõ` ÁÑ∂ÂêéÈáçÊñ∞ `#‰∏ãËΩΩÂíïÂíïÁâõ`„ÄÇ"
    );
    Report.suggestions = finalSuggestions.join("\n");
    if (stdout || stderr) {
      Report.contextInfo += "\n--- Git ËæìÂá∫‰ø°ÊÅØ ---";
      const maxLen = 500;
      if (stdout)
        Report.contextInfo += `\n[stdout]:\n${stdout.substring(0, maxLen)}${
          stdout.length > maxLen ? "...(ÂêéÈù¢ÁúÅÁï•)" : ""
        }`;
      if (stderr)
        Report.contextInfo += `\n[stderr]:\n${stderr.substring(0, maxLen)}${
          stderr.length > maxLen ? "...(ÂêéÈù¢ÁúÅÁï•)" : ""
        }`;
    }
    return Report;
  }

  /**
   * @description Ê£ÄÊü•ÊåáÂÆö‰ªìÂ∫ìÊòØÂê¶Â∑≤‰∏ãËΩΩ„ÄÇ
   */
  static async IsTuKuDownloaded(RepoNum = 1) {
    let gitPath = "";
    if (RepoNum === 1) gitPath = MiaoPluginMBT.paths.gitFolderPath;
    else if (RepoNum === 2) gitPath = MiaoPluginMBT.paths.gitFolderPath2;
    else if (RepoNum === 3) gitPath = MiaoPluginMBT.paths.gitFolderPath3;
    else return false; // Êó†Êïà‰ªìÂ∫ìÂè∑

    if (!gitPath) return false; // Ë∑ØÂæÑÊú™ÂÆö‰πâ

    try {
      await fsPromises.access(gitPath);
      const stats = await fsPromises.stat(gitPath);
      return stats.isDirectory();
    } catch {
      return false;
    }
  }

  /**
   * @description Âä†ËΩΩÁî®Êà∑ÊâãÂä®Â∞ÅÁ¶ÅÂàóË°® (banlist.json)„ÄÇ
   */
  static async LoadUserBans(
    forceReload = false,
    logger = global.logger || console
  ) {
    if (
      MiaoPluginMBT._userBanSet instanceof Set &&
      MiaoPluginMBT._userBanSet.size > 0 &&
      !forceReload
    ) {
      return true;
    }
    let data = [];
    let success = false;
    try {
      const content = await fsPromises.readFile(
        MiaoPluginMBT.paths.banListPath,
        "utf8"
      );
      data = JSON.parse(content);
      success = true;
    } catch (error) {
      if (error.code === ERROR_CODES.NotFound) {
        logger.info(
          `${Default_Config.logPrefix} [Âä†ËΩΩÁî®Êà∑Â∞ÅÁ¶Å] banlist.json Êú™ÊâæÂà∞„ÄÇ`
        );
        data = [];
        success = true;
      } else {
        logger.error(
          `${Default_Config.logPrefix} [Âä†ËΩΩÁî®Êà∑Â∞ÅÁ¶Å] ËØªÂèñÊàñËß£ÊûêÂ§±Ë¥•:`,
          error
        );
        data = [];
        success = false;
      }
    }
    if (success && Array.isArray(data)) {
      const originalCount = data.length;
      const validBans = data
        .filter((item) => typeof item === "string" && item.trim() !== "")
        .map((p) => p.replace(/\\/g, "/"));
      MiaoPluginMBT._userBanSet = new Set(validBans);
      const validCount = MiaoPluginMBT._userBanSet.size;
      const invalidOrDuplicateCount = originalCount - validCount;
      if (invalidOrDuplicateCount > 0)
        logger.warn(
          `${Default_Config.logPrefix} [Âä†ËΩΩÁî®Êà∑Â∞ÅÁ¶Å] ÂøΩÁï• ${invalidOrDuplicateCount} Êù°Êó†Êïà/ÈáçÂ§ç„ÄÇ`
        );
      logger.info(
        `${Default_Config.logPrefix} [Âä†ËΩΩÁî®Êà∑Â∞ÅÁ¶Å] ÂÆåÊàê: ${validCount} Êù°„ÄÇ`
      );
      return true;
    } else {
      if (success && !Array.isArray(data)) {
        logger.error(
          `${Default_Config.logPrefix} [Âä†ËΩΩÁî®Êà∑Â∞ÅÁ¶Å] banlist.json Êñá‰ª∂ÂÜÖÂÆπÊ†ºÂºèÈîôËØØÔºå‰∏çÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑÊï∞ÁªÑÔºÅ`
        );
      }
      MiaoPluginMBT._userBanSet = new Set();
      return false;
    }
  }

  /**
   * @description ‰øùÂ≠òÂΩìÂâçÁî®Êà∑ÊâãÂä®Â∞ÅÁ¶ÅÂàóË°®Âà∞Êñá‰ª∂„ÄÇ
   *             ÁßªÈô§ banMutex ÈîÅ„ÄÇ
   */
  static async SaveUserBans(logger = global.logger || console) {
    const logPrefix = Default_Config.logPrefix;
    const banListPath = MiaoPluginMBT.paths.banListPath;

    try {
      const sortedBans = Array.from(MiaoPluginMBT._userBanSet).sort();
      const jsonString = JSON.stringify(sortedBans, null, 2);

      const dirPath = path.dirname(banListPath);
      try {
        await fsPromises.mkdir(dirPath, { recursive: true });
      } catch (mkdirError) {
        logger.error(
          `${logPrefix} [‰øùÂ≠òÁî®Êà∑Â∞ÅÁ¶Å] ÂàõÂª∫ÁõÆÂΩï ${dirPath} Â§±Ë¥•:`,
          mkdirError
        );
        return false;
      }

      await fsPromises.writeFile(banListPath, jsonString, "utf8");
      logger.info(
        `${logPrefix} [‰øùÂ≠òÁî®Êà∑Â∞ÅÁ¶Å] ÊàêÂäü‰øùÂ≠ò ${sortedBans.length} Êù°ËÆ∞ÂΩïÂà∞ ${banListPath}`
      );
      return true;
    } catch (error) {
      logger.error(
        `${logPrefix} [‰øùÂ≠òÁî®Êà∑Â∞ÅÁ¶Å] ÂÜôÂÖ•ÈÖçÁΩÆÊñá‰ª∂ ${banListPath} ÊàñÂÖ∂‰ªñÊìç‰ΩúÂ§±Ë¥•!`,
        error
      );
      return false;
    }
  }
  /**
   * @description Âä†ËΩΩÊâÄÊúâÊù•Ê∫êÁöÑËßíËâ≤Âà´ÂêçÊï∞ÊçÆ„ÄÇ
   */
  static async LoadAliasData(
    forceReload = false,
    logger = global.logger || console
  ) {
    if (MiaoPluginMBT._aliasData && !forceReload) return true;
    const aliasSources = [
      {
        key: "gsAlias",
        path: path.join(MiaoPluginMBT.paths.target.miaoGsAliasDir, "alias.js"),
        type: "js",
      },
      {
        key: "srAlias",
        path: path.join(MiaoPluginMBT.paths.target.miaoSrAliasDir, "alias.js"),
        type: "js",
      },
      {
        key: "zzzAlias",
        path: path.join(MiaoPluginMBT.paths.target.zzzAliasDir, "alias.yaml"),
        type: "yaml",
      },
      {
        key: "wavesAlias",
        path: path.join(MiaoPluginMBT.paths.target.wavesAliasDir, "role.yaml"),
        type: "yaml",
      },
    ];
    const loadedAliases = {};
    const combined = {};
    let overallSuccess = true;
    const parseFile = async (filePath, fileType) => {
      let data = {};
      try {
        await fsPromises.access(filePath);
        if (fileType === "js") {
          const fileUrl = `file://${filePath.replace(
            /\\/g,
            "/"
          )}?t=${Date.now()}`;
          try {
            const module = await import(fileUrl);
            if (module?.alias && typeof module.alias === "object")
              data = module.alias;
            else {
              overallSuccess = false;
            }
          } catch (importErr) {
            if (importErr.code !== "ERR_MODULE_NOT_FOUND") {
              logger.error(
                `${Default_Config.logPrefix} [Âä†ËΩΩÂà´Âêç] ÂØºÂÖ• JS Â§±Ë¥• (${filePath}):`,
                importErr
              );
              overallSuccess = false;
            }
          }
        } else if (fileType === "yaml") {
          try {
            const content = await fsPromises.readFile(filePath, "utf8");
            data = yaml.parse(content) || {};
          } catch (yamlErr) {
            logger.error(
              `${Default_Config.logPrefix} [Âä†ËΩΩÂà´Âêç] Ëß£Êûê YAML Â§±Ë¥• (${filePath}):`,
              yamlErr
            );
            overallSuccess = false;
          }
        }
      } catch (err) {
        if (err.code !== ERROR_CODES.NotFound) {
          logger.warn(
            `${Default_Config.logPrefix} [Âä†ËΩΩÂà´Âêç] ËØªÂèñ ${fileType} Êñá‰ª∂Â§±Ë¥•: ${filePath}`,
            err.code
          );
          overallSuccess = false;
        }
      }
      return data;
    };
    await Promise.all(
      aliasSources.map(async ({ key, path: filePath, type }) => {
        const data = await parseFile(filePath, type);
        loadedAliases[key] = data;
        Object.assign(combined, data);
      })
    );
    MiaoPluginMBT._aliasData = { ...loadedAliases, combined };
    const combinedCount = Object.keys(combined).length;
    logger.info(
      `${Default_Config.logPrefix} [Âä†ËΩΩÂà´Âêç] ÂÆåÊàê: ${combinedCount}‰∏ªÂêç„ÄÇÊàêÂäü: ${overallSuccess}`
    );
    return overallSuccess;
  }

  /**
   * @description Â∞ÜÁîüÊïàÁöÑÂ∞ÅÁ¶ÅÂàóË°®Â∫îÁî®Âà∞ÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩïÔºåÂà†Èô§ÂØπÂ∫îÂõæÁâáÊñá‰ª∂„ÄÇ
   */
  static async ApplyBanList(
    effectiveBanSet = MiaoPluginMBT._activeBanSet,
    logger = global.logger || console
  ) {
    if (!(effectiveBanSet instanceof Set) || effectiveBanSet.size === 0) {
      return;
    }
    let deletedCount = 0;
    const deletePromises = [];
    for (const relativePath of effectiveBanSet) {
      const targetPath = await MiaoPluginMBT.DetermineTargetPath(relativePath);
      if (targetPath) {
        deletePromises.push(
          fsPromises
            .unlink(targetPath)
            .then(() => {
              deletedCount++;
            })
            .catch((unlinkErr) => {
              if (unlinkErr.code !== ERROR_CODES.NotFound)
                logger.warn(
                  `${Default_Config.logPrefix} [Â∫îÁî®Â∞ÅÁ¶Å] Âà†Èô§ ${targetPath} Â§±Ë¥•:`,
                  unlinkErr.code
                );
            })
        );
      }
    }
    await Promise.all(deletePromises);
    logger.info(
      `${Default_Config.logPrefix} [Â∫îÁî®Â∞ÅÁ¶Å] ÂÆåÊàê: Â§ÑÁêÜ ${deletePromises.length} È°π, Âà†Èô§ ${deletedCount} Êñá‰ª∂„ÄÇ`
    );
  }

  /**
   * @description Ê†πÊçÆÂõæÁâáÁõ∏ÂØπË∑ØÂæÑÔºåÊé®Êñ≠ÂÖ∂Âú®ÁõÆÊ†áÊèí‰ª∂‰∏≠ÁöÑÁªùÂØπË∑ØÂæÑ„ÄÇ
   */
  static async DetermineTargetPath(relativePath) {
    if (!relativePath) return null;
    const logger = global.logger || console;
    const normalizedRelativePath = relativePath.replace(/\\/g, "/");
    for (const fileSync of MiaoPluginMBT.paths.filesToSyncToCommonRes) {
      if (normalizedRelativePath === fileSync.sourceSubPath.replace(/\\/g, "/"))
        return path.join(
          MiaoPluginMBT.paths.commonResPath,
          fileSync.destFileName
        );
    }
    for (const fileSync of MiaoPluginMBT.paths.filesToSyncSpecific) {
      if (normalizedRelativePath === fileSync.sourceSubPath.replace(/\\/g, "/"))
        return path.join(fileSync.destDir, fileSync.destFileName);
    }
    const parts = normalizedRelativePath.split("/");
    if (parts.length >= 3) {
      const sourceFolder = parts[0];
      const characterNameInRepo = parts[1];
      const fileName = parts.slice(2).join("/");
      let targetBaseDir = null,
        GameKey = null;
      if (sourceFolder === MiaoPluginMBT.paths.sourceFolders.gs) {
        targetBaseDir = MiaoPluginMBT.paths.target.miaoChar;
        GameKey = "gs";
      } else if (sourceFolder === MiaoPluginMBT.paths.sourceFolders.sr) {
        targetBaseDir = MiaoPluginMBT.paths.target.miaoChar;
        GameKey = "sr";
      } else if (sourceFolder === MiaoPluginMBT.paths.sourceFolders.zzz) {
        targetBaseDir = MiaoPluginMBT.paths.target.zzzChar;
        GameKey = "zzz";
      } else if (sourceFolder === MiaoPluginMBT.paths.sourceFolders.waves) {
        targetBaseDir = MiaoPluginMBT.paths.target.wavesChar;
        GameKey = "waves";
      }
      if (targetBaseDir && GameKey) {
        const aliasResult = await MiaoPluginMBT.FindRoleAlias(
          characterNameInRepo
        );
        const targetCharacterName = aliasResult.exists
          ? aliasResult.mainName
          : characterNameInRepo;
        return path.join(targetBaseDir, targetCharacterName, fileName);
      }
    }
    return null;
  }

  /**
   * @description Êô∫ËÉΩÊü•ÊâæÂõæÁâáÁöÑÁªùÂØπË∑ØÂæÑÔºå‰ºòÂÖàÊü•ÊâæÊúÄÊñ∞‰ªìÂ∫ì„ÄÇ
   */
  static async FindImageAbsolutePath(relativePath) {
    if (!relativePath) return null;
    const normalizedPath = relativePath.replace(/\\/g, "/");
    const logger = global.logger || console;
    //  ‰øÆÊîπÊü•ÊâæÈ°∫Â∫èÔºö3 -> 2 -> 1 
    const reposToSearch = [
      {
        name: "Miao-Plugin-MBT-3",
        path: MiaoPluginMBT.paths.LocalTuKuPath3,
        num: 3,
      },
      {
        name: "Miao-Plugin-MBT-2",
        path: MiaoPluginMBT.paths.LocalTuKuPath2,
        num: 2,
      },
      {
        name: "Miao-Plugin-MBT",
        path: MiaoPluginMBT.paths.LocalTuKuPath,
        num: 1,
      },
    ];

    for (const repo of reposToSearch) {
      if (!repo.path) continue;

      const repoExists = await MiaoPluginMBT.IsTuKuDownloaded(repo.num);
      if (repoExists) {
        const absPath = path.join(repo.path, normalizedPath);
        try {
          await fsPromises.access(absPath, fs.constants.R_OK);
          return absPath; // ÊâæÂà∞Âç≥ËøîÂõû
        } catch (err) {
          if (err.code !== ERROR_CODES.NotFound) {
            logger.warn(
              `${Default_Config.logPrefix} [Êü•ÊâæË∑ØÂæÑ] ËÆøÈóÆ‰ªìÂ∫ì ${repo.name} (${absPath}) Âá∫Èîô:`,
              err.code
            );
          }
        }
      }
    }
    // Â¶ÇÊûúÊâÄÊúâ‰ªìÂ∫ìÈÉΩÊ≤°ÊâæÂà∞
    logger.warn(
      `${Default_Config.logPrefix} [Êü•ÊâæË∑ØÂæÑ] Âú®ÊâÄÊúâÂ∑≤‰∏ãËΩΩ‰ªìÂ∫ì‰∏≠ÂùáÊú™ÊâæÂà∞: ${normalizedPath}`
    );
    return null;
  }

  /**
   * @description Ê†πÊçÆËæìÂÖ•ÂêçÁß∞Êü•ÊâæÊ†áÂáÜËßíËâ≤ÂêçÂíåÊòØÂê¶Â≠òÂú®„ÄÇ
   */
  static async FindRoleAlias(inputName, logger = global.logger || console) {
    const cleanInput = inputName?.trim();
    if (!cleanInput) return { mainName: null, exists: false };
    if (!MiaoPluginMBT._aliasData) {
      await MiaoPluginMBT.LoadAliasData(false, logger);
      if (!MiaoPluginMBT._aliasData?.combined) {
        logger.error(`${Default_Config.logPrefix} [Êü•ÊâæÂà´Âêç] Êó†Ê≥ïÂä†ËΩΩ„ÄÇ`);
        const dirExistsFallback = await MiaoPluginMBT.CheckRoleDirExists(
          cleanInput
        );
        return { mainName: cleanInput, exists: dirExistsFallback };
      }
    }
    const combinedAliases = MiaoPluginMBT._aliasData.combined || {};
    const lowerInput = cleanInput.toLowerCase();
    if (combinedAliases.hasOwnProperty(cleanInput))
      return { mainName: cleanInput, exists: true };
    for (const mainNameKey in combinedAliases) {
      if (mainNameKey.toLowerCase() === lowerInput)
        return { mainName: mainNameKey, exists: true };
    }
    for (const [mainName, aliases] of Object.entries(combinedAliases)) {
      let aliasArray = [];
      if (typeof aliases === "string")
        aliasArray = aliases.split(",").map((a) => a.trim().toLowerCase());
      else if (Array.isArray(aliases))
        aliasArray = aliases.map((a) => String(a).trim().toLowerCase());
      if (aliasArray.includes(lowerInput))
        return { mainName: mainName, exists: true };
    }
    const dirExists = await MiaoPluginMBT.CheckRoleDirExists(cleanInput);
    return { mainName: cleanInput, exists: dirExists };
  }

  /**
   * @description Ê£ÄÊü•ÊåáÂÆöËßíËâ≤ÂêçÊòØÂê¶Â≠òÂú®ÂØπÂ∫îÁöÑÊú¨Âú∞ÂõæÂ∫ìÁõÆÂΩï„ÄÇ
   */
  static async CheckRoleDirExists(roleName) {
    if (!roleName) return false;
    const gameFolders = Object.values(MiaoPluginMBT.paths.sourceFolders).filter(
      (f) => f !== MiaoPluginMBT.paths.sourceFolders.gallery
    );
    const ReposToCheck = [];
    if (await MiaoPluginMBT.IsTuKuDownloaded(1))
      ReposToCheck.push(MiaoPluginMBT.paths.LocalTuKuPath);
    if (await MiaoPluginMBT.IsTuKuDownloaded(2))
      ReposToCheck.push(MiaoPluginMBT.paths.LocalTuKuPath2);
    if (await MiaoPluginMBT.IsTuKuDownloaded(3))
      ReposToCheck.push(MiaoPluginMBT.paths.LocalTuKuPath3);
    if (ReposToCheck.length === 0) return false;
    for (const RepoPath of ReposToCheck) {
      for (const gameFolder of gameFolders) {
        const rolePath = path.join(RepoPath, gameFolder, roleName);
        try {
          await fsPromises.access(rolePath);
          const stats = await fsPromises.stat(rolePath);
          if (stats.isDirectory()) return true;
        } catch {}
      }
    }
    return false;
  }

  /**
   * @description Ëß£ÊûêËßíËâ≤Ê†áËØÜÁ¨¶ (Â¶Ç "Ëä±ÁÅ´1", "Ëä±ÁÅ´Gu1") ‰∏∫ËßíËâ≤ÂêçÂíåÁºñÂè∑„ÄÇ
   */
  static ParseRoleIdentifier(identifier) {
    if (!identifier) return null;
    const match = identifier.trim().match(/^(.*?)(?:Gu)?(\d+)$/i);
    if (match && match[1] && match[2]) {
      const mainName = match[1].trim();
      if (mainName) return { mainName: mainName, imageNumber: match[2] };
    }
    return null;
  }

  /**
   * @description Ëé∑ÂèñÊåáÂÆö‰ªìÂ∫ìÁöÑ Git Êèê‰∫§Êó•Âøó„ÄÇ
   */
  static async GetTuKuLog(
    count = 5,
    RepoPath = MiaoPluginMBT.paths.LocalTuKuPath,
    logger = global.logger || console
  ) {
    if (!RepoPath) {
      return null;
    }
    const gitDir = path.join(RepoPath, ".git");
    try {
      await fsPromises.access(gitDir);
      const stats = await fsPromises.stat(gitDir);
      if (!stats.isDirectory()) throw new Error(".git is not a directory");
    } catch (err) {
      return null;
    }
    const format = Default_Config.gitLogFormat;
    const dateformat = Default_Config.gitLogDateFormat;
    const args = [
      "log",
      `-n ${Math.max(1, count)}`,
      `--date=${dateformat}`,
      `--pretty=format:${format}`,
    ];
    const gitOptions = { cwd: RepoPath };
    try {
      const result = await ExecuteCommand("git", args, gitOptions, 5000);
      return result.stdout.trim();
    } catch (error) {
      logger.warn(
        `${Default_Config.logPrefix} [Ëé∑ÂèñÊó•Âøó] Git log Â§±Ë¥• (${RepoPath})`
      );
      return null;
    }
  }

  /**
   * @description ‰∏ãËΩΩÂçï‰∏™‰ªìÂ∫ìÔºåÂåÖÂê´‰ª£ÁêÜÈÄâÊã©„ÄÅGitHub Áõ¥Ëøû‰ºòÂÖàÂà§Êñ≠Âíå Fallback ÈáçËØïÈÄªËæë„ÄÇ
   *              È¢ÑÊ∏≤Êüì HTML Âà∞Êñá‰ª∂ÂÜçÊà™ÂõæÔºåÊÅ¢Â§çÁî®Êà∑ËøõÂ∫¶ÊèêÁ§∫„ÄÇ
   *              ‰øùÊåÅÊ†∏ÂøÉÁöÑÈîÅËåÉÂõ¥‰ºòÂåñ„ÄÇÁßªÈô§Â§ö‰ΩôÁî®Êà∑ÊèêÁ§∫„ÄÇ
   */
  static async DownloadRepoWithFallback(
    repoNum,
    repoUrl,
    branch,
    localPath,
    eForProgress,
    loggerInstance
  ) {
    const logPrefix = Default_Config.logPrefix;
    const repoTypeName = repoNum === 1 ? "Ê†∏ÂøÉ‰ªìÂ∫ì" : "ÈôÑÂ±û‰ªìÂ∫ì";
    const baseRawUrl = RAW_URL_Repo1;
    const functionStartTime = Date.now();
    // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ËøõÂÖ•ÂáΩÊï∞ @ ${functionStartTime}`); //Ë∞ÉËØïÊó•Âøó

    const SPEEDTEST_HTML_TEMPLATE_LOCAL = `
    <!DOCTYPE html>
    <html lang="zh-CN">
      <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>ÂíïÂíïÁâõÊµãÈÄüÊä•Âëä (‰∏ãËΩΩÂÜÖÁΩÆ)</title>
       <style>
        body{font-family:"Microsoft YaHei","PingFang SC",sans-serif;margin:0;padding:20px;background:linear-gradient(to bottom,#e0f2f7,#ffffff);color:#333;font-size:14px;line-height:1.6;width:500px;box-sizing:border-box;}
        .container{padding:15px;background-color:rgba(255,255,255,0.8);border-radius:10px;border:1px rgba(0,255,85,0.8) solid;box-shadow:5px 5px 0 0 rgba(0,255,85,0.3);}
        h1{text-align:center;color:rgba(7,131,48,0.8);margin:0 0 15px 0;font-size:20px;border-bottom:1px solid #eee;padding-bottom:10px;}
        h2{font-size:16px;color:#333;margin:15px 0 10px 0;border-left:4px solid #0077cc;padding-left:8px;}
        ul{list-style:none;padding:0;margin:0;}
        li{display:flex;justify-content:space-between;align-items:center;padding:8px 5px;}
        li:last-child{border-bottom:none;}
        .node-name{font-weight:bold;color:#555;flex-basis:120px;flex-shrink:0;}
        .node-status{text-align:right;flex-grow:1;}
        .status-ok{color:#28a745;font-weight:bold;}
        .status-timeout{color:#dc3545;font-weight:bold;}
        .status-na{color:#aaa;}
        .priority{color:#777;font-size:0.9em;margin-left:5px;}
        .best-choice{margin-top:20px;text-align:center;font-weight:600;color:#00cc55;font-size:1.05em;padding:8px;background-color:rgba(0,255,64,0.05);border-radius:6px;}
        .footer{text-align:center;margin-top:20px;font-size:11px;color:#999;}
        </style>
      </head>
      <body style="{{scaleStyleValue}}">
        <div class="container">
          <h1>ÂíïÂíïÁâõÁΩëÁªúÊµãÈÄüÊä•Âëä (‰∏ãËΩΩÂÜÖÁΩÆ)</h1>
          {{ if speeds1 && speeds1.length > 0 }}
          <h2>ËÅöÂêà‰ªìÂ∫ìÂü∫ÂáÜ ({{ speeds1.length }} ËäÇÁÇπ)</h2>
          <ul>
            {{ each speeds1 s }}
            <li>
              <span class="node-name">{{ s.name }}</span>
              <span class="node-status">
                {{ if s.statusText === 'ok' }}
                <span class="status-ok">{{ s.speed }}ms ‚úÖ</span>
                {{ else if s.statusText === 'na' }}
                <span class="status-na">N/A ‚ö†Ô∏è</span>
                {{ else }}
                <span class="status-timeout">Ë∂ÖÊó∂ ‚ùå</span>
                {{ /if }}
                <span class="priority">(‰ºòÂÖàÁ∫ß:{{ s.priority ?? 'N' }})</span>
              </span>
            </li>
            {{ /each }}
          </ul>
             <div class="best-choice">
                ‚úÖ ‰ºòÈÄâ: {{ best1Display }}
              </div>
          {{ /if }}
          <div class="footer">ÊµãÈÄüËÄóÊó∂: {{ duration }}s | By ÂíïÂíïÁâõ</div>
        </div>
      </body>
    </html>
    `;

    let sourcesToTry = [];
    let allTestResults = [];
    let tempHtmlFilePath = "";
    let tempImgFilePath = "";
    let canGenerateReport = true;
    let lastError = null;
    const testStartTime = Date.now();

    try {
      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂºÄÂßãÊµãÈÄü @ ${testStartTime}`); //Ë∞ÉËØïÊó•Âøó
      allTestResults = await MiaoPluginMBT.TestProxies(
        baseRawUrl,
        loggerInstance
      );
      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÊµãÈÄüÁªìÊùü @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
    } catch (testError) {
      loggerInstance.error(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ‰ª£ÁêÜÊµãÈÄüÂ§±Ë¥•:`,
        testError
      );
      const githubSource = Default_Config.proxies.find(
        (p) => p.name === "GitHub"
      );
      if (githubSource) {
        allTestResults = [{ ...githubSource, speed: Infinity }];
      }
    }

    if (eForProgress && repoNum === 1 && allTestResults.length > 0) {
      let renderData = {};
      let htmlContent = "";
      try {
        const reportSources = MiaoPluginMBT.GetSortedAvailableSources(
          allTestResults,
          true,
          loggerInstance
        );
        const bestSourceForReport = reportSources[0] || null;
        const duration = ((Date.now() - testStartTime) / 1000).toFixed(1);
        const processSpeeds = (speeds) => {
          return speeds
            .map((s) => ({
              ...s,
              statusText:
                s.testUrlPrefix === null
                  ? "na"
                  : Number.isFinite(s.speed) && s.speed >= 0
                  ? "ok"
                  : "timeout",
            }))
            .sort(
              (a, b) =>
                (a.priority ?? 999) - (b.priority ?? 999) ||
                (a.speed === Infinity || a.statusText === "na"
                  ? 1
                  : b.speed === Infinity || b.statusText === "na"
                  ? -1
                  : a.speed - b.speed)
            );
        };
        const processedSpeedsResult = processSpeeds(allTestResults);
        const scaleStyleValue = MiaoPluginMBT.getScaleStyleValue();
        let best1Display = "Êó†ÂèØÁî®Ê∫ê";
        if (bestSourceForReport) {
          let speedInfo = "N/A";
          if (bestSourceForReport.testUrlPrefix !== null) {
            speedInfo =
              Number.isFinite(bestSourceForReport.speed) &&
              bestSourceForReport.speed >= 0
                ? `${bestSourceForReport.speed}ms`
                : "Ë∂ÖÊó∂";
          }
          best1Display = `${bestSourceForReport.name}(${speedInfo})`;
        }
        renderData = {
          speeds1: processedSpeedsResult,
          best1: bestSourceForReport,
          duration: duration,
          scaleStyleValue: scaleStyleValue,
          best1Display: best1Display,
        };

        htmlContent = template.render(
          SPEEDTEST_HTML_TEMPLATE_LOCAL,
          renderData
        );
        // loggerInstance.debug(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËØäÊñ≠] È¢ÑÊ∏≤Êüì HTML ÂÜÖÂÆπÁ±ªÂûã: ${typeof htmlContent}, ÊòØÂê¶‰∏∫Á©∫: ${!htmlContent}`); //Ë∞ÉËØïÊó•Âøó
        if (typeof htmlContent !== "string" || htmlContent.length === 0) {
          throw new Error("template.render ËøîÂõû‰∫ÜÊó†ÊïàÂÜÖÂÆπ!");
        }

        await fsPromises.mkdir(MiaoPluginMBT.paths.tempHtmlPath, {
          recursive: true,
        });
        tempHtmlFilePath = path.join(
          MiaoPluginMBT.paths.tempHtmlPath,
          `dl-speedtest-rendered-${Date.now()}-${Math.random()
            .toString(16)
            .slice(2)}.html`
        );
        await fsPromises.writeFile(tempHtmlFilePath, htmlContent, "utf8");
        // loggerInstance.debug(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Â∑≤Â∞ÜÊ∏≤ÊüìÂ•ΩÁöÑ HTML ÂÜôÂÖ•‰∏¥Êó∂Êñá‰ª∂: ${tempHtmlFilePath}`); //Ë∞ÉËØïÊó•Âøó
        canGenerateReport = true;
      } catch (prepOrRenderError) {
        loggerInstance.error(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ÂáÜÂ§áÊàñÊ∏≤ÊüìÊµãÈÄüÊä•ÂëäÂ§±Ë¥•:`,
          prepOrRenderError
        );
        await eForProgress
          .reply(
            `${logPrefix} ÂáÜÂ§áÊàñÊ∏≤ÊüìÊµãÈÄüÊä•ÂëäÂá∫Èîô (${prepOrRenderError.message?.substring(
              0,
              50
            )}...)ÔºåÁªßÁª≠‰∏ãËΩΩ...`
          )
          .catch(() => {});
        canGenerateReport = false;
      }

      if (canGenerateReport) {
        try {
          await fsPromises.mkdir(MiaoPluginMBT.paths.tempImgPath, {
            recursive: true,
          });
          tempImgFilePath = path.join(
            MiaoPluginMBT.paths.tempImgPath,
            `dl-speedtest-${Date.now()}.png`
          );

          // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËØäÊñ≠] ÂáÜÂ§áË∞ÉÁî® puppeteer.screenshot (È¢ÑÊ∏≤Êüì tplFile ÊñπÂºè)...`); //Ë∞ÉËØïÊó•Âøó
          // loggerInstance.debug(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËØäÊñ≠] tplFile: ${tempHtmlFilePath}`); //Ë∞ÉËØïÊó•Âøó

          const img = await puppeteer.screenshot("guguniu-dl-speedtest", {
            tplFile: tempHtmlFilePath,
            savePath: tempImgFilePath,
            imgType: "png",
            pageGotoParams: { waitUntil: "networkidle0" },
            screenshotOptions: { fullPage: false },
            pageBoundingRect: { selector: "body", padding: 0 },
            width: 540,
          });
          // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËØäÊñ≠] puppeteer.screenshot Ë∞ÉÁî®ÂÆåÊàêÔºåËøîÂõûÁ±ªÂûã: ${typeof img}`); //Ë∞ÉËØïÊó•Âøó

          if (img) {
            await eForProgress.reply(img);
            await common.sleep(500);
          } else {
            loggerInstance.warn(
              `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ÁîüÊàêÊµãÈÄüÊà™ÂõæÊàêÂäüÔºå‰ΩÜ Puppeteer ËøîÂõûÁ©∫ (ÂèØËÉΩ‰∏∫Á©∫ÁôΩÂõæÁâá)„ÄÇ`
            );
            await eForProgress
              .reply(`${logPrefix} ÁîüÊàêÊµãÈÄüÊä•ÂëäÂõæÁâáÊó∂ÂÜÖÂÆπÂèØËÉΩ‰∏∫Á©∫ÔºåÁªßÁª≠‰∏ãËΩΩ...`)
              .catch(() => {});
          }
        } catch (screenshotError) {
          loggerInstance.error(
            `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Puppeteer ÁîüÊàêÊµãÈÄüÊà™ÂõæÂ§±Ë¥•:`,
            screenshotError
          );
          if (screenshotError.message?.includes("Âä†ËΩΩhtmlÈîôËØØÔºöundefined")) {
            loggerInstance.error(
              `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËØäÊñ≠] Âç≥‰Ωø‰ΩøÁî®È¢ÑÊ∏≤Êüì tplFile ÊñπÂºè‰ªçÁÑ∂Êä•Èîô 'Âä†ËΩΩhtmlÈîôËØØÔºöundefined'ÔºåÈóÆÈ¢òÂèØËÉΩÂú®Êà™ÂõæÁªÑ‰ª∂ÊàñÁéØÂ¢É„ÄÇ`
            );
          }
          await eForProgress
            .reply(
              `${logPrefix} ÁîüÊàêÊµãÈÄüÊä•ÂëäÊà™ÂõæÂá∫Èîô (${screenshotError.message?.substring(
                0,
                50
              )}...)ÔºåÁªßÁª≠‰∏ãËΩΩ...`
            )
            .catch(() => {});
        } finally {
          if (tempHtmlFilePath && fs.existsSync(tempHtmlFilePath)) {
            try {
              await fsPromises.unlink(tempHtmlFilePath);
            } catch (unlinkErr) {}
          }
          if (tempImgFilePath && fs.existsSync(tempImgFilePath)) {
            try {
              await fsPromises.unlink(tempImgFilePath);
            } catch (unlinkErr) {}
          }
          const possiblePuppeteerTempDir = path.join(
            MiaoPluginMBT.paths.tempPath,
            "..",
            "guguniu-dl-speedtest"
          );
          if (fs.existsSync(possiblePuppeteerTempDir)) {
            try {
              await safeDelete(possiblePuppeteerTempDir);
            } catch (deleteErr) {}
          }
        }
      }
    }

    const githubResult = allTestResults.find((r) => r.name === "GitHub");
    let githubDirectAttempted = false;

    if (
      githubResult &&
      githubResult.speed !== Infinity &&
      githubResult.speed <= 300
    ) {
      githubDirectAttempted = true;
      const nodeName = "GitHub(Áõ¥Ëøû-‰ºòÂÖà)";
      loggerInstance.info(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Ê£ÄÊµãÂà∞ GitHub Áõ¥ËøûÂª∂Ëøü (${githubResult.speed}ms) <= 300msÔºå‰ºòÂÖàÂ∞ùËØïÁõ¥Ëøû...`
      );

      const cloneArgsDirect = [
        "clone",
        `--depth=${Default_Config.gitCloneDepth}`,
        "--progress",
        repoUrl,
        localPath,
      ];
      const gitOptionsDirect = {
        cwd: MiaoPluginMBT.paths.YunzaiPath,
        shell: false,
      };

      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] Â∞ùËØïËé∑Âèñ Git ÈîÅ (GitHub Áõ¥Ëøû) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      await MiaoPluginMBT.gitMutex.acquire();
      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] Â∑≤Ëé∑Âèñ Git ÈîÅ (GitHub Áõ¥Ëøû) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      try {
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂºÄÂßã ExecuteCommand (GitHub Áõ¥Ëøû) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        let progressReportedDirect = { 10: false, 90: false };
        await ExecuteCommand(
          "git",
          cloneArgsDirect,
          gitOptionsDirect,
          Default_Config.gitCloneTimeout,
          (stderrChunk) => {
            if (eForProgress && repoNum === 1) {
              const match = stderrChunk.match(/Receiving objects:\s*(\d+)%/);
              if (match?.[1]) {
                  const progress = parseInt(match[1], 10);
                  [10, 90].forEach(t => {
                      if (progress >= t && !progressReportedDirect[t]) {
                          progressReportedDirect[t] = true;
                          eForProgress.reply(`„ÄéÂíïÂíïÁâõ„Äè${repoTypeName} (${nodeName}) ‰∏ãËΩΩ: ${t}%...`).catch(() => {});
                      }
                  });
              }
          } else if (repoNum !== 1) { // ÈôÑÂ±û‰ªìÂ∫ìÂè™ËÆ∞ÂΩïÊó•Âøó
              const match = stderrChunk.match(/(Receiving objects|Resolving deltas):\s*(\d+)%/);
              if (match) loggerInstance.debug(`${logPrefix} [‰∏ãËΩΩËøõÂ∫¶ ${repoTypeName} (${repoNum}Âè∑)] (${nodeName}) ${match[1]}: ${match[2]}%`);
          }
        },
          undefined
        );
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ExecuteCommand ÊàêÂäü (GitHub Áõ¥Ëøû) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        loggerInstance.info(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ‰ΩøÁî® ${nodeName} ‰∏ãËΩΩÊàêÂäüÔºÅ`
        );
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂáΩÊï∞ÊàêÂäüËøîÂõû @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        return { success: true, nodeName: nodeName };
      } catch (error) {
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ExecuteCommand Â§±Ë¥• (GitHub Áõ¥Ëøû) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        loggerInstance.error(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ‰ºòÂÖàÂ∞ùËØï ${nodeName} ‰∏ãËΩΩÂ§±Ë¥•„ÄÇÂ∞ÜÁªßÁª≠Â∞ùËØïÂÖ∂‰ªñÊ∫ê...`
        );
        loggerInstance.error(error);
        lastError = error;
        loggerInstance.warn(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Â∞ùËØïÊ∏ÖÁêÜÁõ¥ËøûÂ§±Ë¥•‰∫ßÁîüÁöÑÁõÆÂΩï: ${localPath}`
        );
        await safeDelete(localPath);
        await common.sleep(1000);
      } finally {
        MiaoPluginMBT.gitMutex.release();
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÈáäÊîæ Git ÈîÅ (GitHub Áõ¥Ëøû) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      }
    } else if (githubResult) {
      loggerInstance.info(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] GitHub Áõ¥ËøûÂª∂Ëøü (${
          githubResult.speed === Infinity
            ? "Ë∂ÖÊó∂/Â§±Ë¥•"
            : githubResult.speed + "ms"
        }) > 300msÔºåÊåâ‰ºòÂÖàÁ∫ßÈÄâÊã©ËäÇÁÇπ„ÄÇ`
      );
    } else {
      loggerInstance.warn(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Êú™ÊâæÂà∞ GitHub ÊµãÈÄüÁªìÊûúÔºåÊåâ‰ºòÂÖàÁ∫ßÈÄâÊã©ËäÇÁÇπ„ÄÇ`
      );
    }

    sourcesToTry = MiaoPluginMBT.GetSortedAvailableSources(
      allTestResults,
      true,
      loggerInstance
    );

    if (sourcesToTry.length === 0) {
      loggerInstance.error(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Ê≤°Êúâ‰ªª‰ΩïÂèØÁî®ÁöÑ‰∏ãËΩΩÊ∫êÔºÅ(ÂåÖÊã¨ GitHub Áõ¥ËøûÂ∞ùËØïÂêé)`
      );
      if (repoNum === 1 && eForProgress) {
        await MiaoPluginMBT.ReportError(
          eForProgress,
          `‰∏ãËΩΩ${repoTypeName}`,
          lastError || new Error("Êó†ÂèØÁî®‰∏ãËΩΩÊ∫ê"),
          `ÊµãÈÄüÁªìÊûú: ${JSON.stringify(allTestResults)}`,
          loggerInstance
        );
      }
      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂáΩÊï∞Â§±Ë¥•ËøîÂõû @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      return {
        success: false,
        nodeName: "Êó†ÂèØÁî®Ê∫ê",
        error: lastError || new Error("Êó†ÂèØÁî®‰∏ãËΩΩÊ∫ê"),
      };
    }

    loggerInstance.info(
      `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ÂºÄÂßãÂ∞ùËØïÂàóË°®: ${sourcesToTry
        .map((s) => s.name)
        .join(", ")}`
    );

    for (const source of sourcesToTry) {
      if (source.name === "GitHub" && githubDirectAttempted) {
        // loggerInstance.debug(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Â∑≤‰ºòÂÖàÂ∞ùËØïËøá GitHub Áõ¥ËøûÔºåË∑≥ËøáÊú¨Ê¨°ÂàóË°®‰∏≠ÁöÑ GitHub Ê∫ê„ÄÇ`); //Ë∞ÉËØïÊó•Âøó
        continue;
      }

      const nodeName =
        source.name === "GitHub" ? "GitHub(Áõ¥Ëøû)" : `${source.name}(‰ª£ÁêÜ)`;
      loggerInstance.info(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Â∞ùËØï‰ΩøÁî®Ê∫ê: ${nodeName}`
      );

      let cloneUrl = "";
      let proxyForEnv = null;
      if (source.name === "GitHub") {
        cloneUrl = repoUrl;
      } else if (source.cloneUrlPrefix) {
        if (source.name === "GitClone") {
          cloneUrl = `${source.cloneUrlPrefix.replace(
            /\/$/,
            ""
          )}/${repoUrl.replace(/^https?:\/\//, "")}`;
        } else {
          cloneUrl = `${source.cloneUrlPrefix.replace(/\/$/, "")}/${repoUrl}`;
        }
        try {
          const proxyUrl = new URL(source.cloneUrlPrefix);
          if (["http:", "https:"].includes(proxyUrl.protocol))
            proxyForEnv = proxyUrl.origin;
        } catch (urlError) {
          loggerInstance.warn(
            `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Êó†Ê≥ïËß£Êûê‰ª£ÁêÜ ${source.name} ÁöÑ cloneUrlPrefix: ${urlError.message}`
          );
        }
      } else {
        loggerInstance.warn(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Ê∫ê ${source.name} Ê≤°Êúâ cloneUrlPrefixÔºåË∑≥Ëøá„ÄÇ`
        );
        continue;
      }
      const cloneArgs = [
        "clone",
        `--depth=${Default_Config.gitCloneDepth}`,
        "--progress",
        cloneUrl,
        localPath,
      ];
      const gitOptions = { cwd: MiaoPluginMBT.paths.YunzaiPath, shell: false };
      if (proxyForEnv) {
        gitOptions.env = {
          ...process.env,
          HTTP_PROXY: proxyForEnv,
          HTTPS_PROXY: proxyForEnv,
        };
        loggerInstance.info(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ‰∏∫ Git ÂëΩ‰ª§ËÆæÁΩÆ‰ª£ÁêÜ: ${proxyForEnv}`
        );
      }

      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] Â∞ùËØïËé∑Âèñ Git ÈîÅ (${nodeName}) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      await MiaoPluginMBT.gitMutex.acquire();
      // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] Â∑≤Ëé∑Âèñ Git ÈîÅ (${nodeName}) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      try {
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂºÄÂßã ExecuteCommand (${nodeName}) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        let progressReported = { 10: false, 90: false };
        await ExecuteCommand(
          "git",
          cloneArgs,
          gitOptions,
          Default_Config.gitCloneTimeout,
          (stderrChunk) => {
            if (eForProgress && repoNum === 1) {
              const match = stderrChunk.match(/Receiving objects:\s*(\d+)%/);
              if (match?.[1]) {
                  const progress = parseInt(match[1], 10);
                  [10, 90].forEach(t => {
                      if (progress >= t && !progressReported[t]) {
                          progressReported[t] = true;
                          eForProgress.reply(`„ÄéÂíïÂíïÁâõ„Äè${repoTypeName} (${nodeName}) ‰∏ãËΩΩ: ${t}%...`).catch(() => {});
                      }
                  });
              }
          } else if (repoNum !== 1) { // ÈôÑÂ±û‰ªìÂ∫ìÂè™ËÆ∞ÂΩïÊó•Âøó
               const match = stderrChunk.match(/(Receiving objects|Resolving deltas):\s*(\d+)%/);
               if (match) loggerInstance.debug(`${logPrefix} [‰∏ãËΩΩËøõÂ∫¶ ${repoTypeName} (${repoNum}Âè∑)] (${nodeName}) ${match[1]}: ${match[2]}%`);
          }
      },
          undefined
        );
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ExecuteCommand ÊàêÂäü (${nodeName}) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        loggerInstance.info(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ‰ΩøÁî®Ê∫ê ${nodeName} ‰∏ãËΩΩÊàêÂäüÔºÅ`
        );
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂáΩÊï∞ÊàêÂäüËøîÂõû @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        return { success: true, nodeName: nodeName };
      } catch (error) {
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ExecuteCommand Â§±Ë¥• (${nodeName}) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
        loggerInstance.error(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ‰ΩøÁî®Ê∫ê ${nodeName} ‰∏ãËΩΩÂ§±Ë¥•„ÄÇ`
        );
        loggerInstance.error(error);
        lastError = error;
        loggerInstance.warn(
          `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Â∞ùËØïÊ∏ÖÁêÜÂ§±Ë¥•‰∏ãËΩΩ‰∫ßÁîüÁöÑÁõÆÂΩï: ${localPath}`
        );
        await safeDelete(localPath);
        await common.sleep(1000);
        loggerInstance.warn(
          `${logPrefix} ‰ΩøÁî®Ê∫ê ${nodeName} ‰∏ãËΩΩ ${repoTypeName} (${repoNum}Âè∑) Â§±Ë¥•ÔºåÂ∞ùËØï‰∏ã‰∏Ä‰∏™Ê∫ê...`
        );
      } finally {
        MiaoPluginMBT.gitMutex.release();
        // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÈáäÊîæ Git ÈîÅ (${nodeName}) @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
      }
    }

    loggerInstance.error(
      `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] Â∞ùËØï‰∫ÜÊâÄÊúâÂèØÁî®Ê∫ê (${sourcesToTry
        .map((s) => s.name)
        .join(", ")})ÔºåÂùá‰∏ãËΩΩÂ§±Ë¥•ÔºÅ`
    );
    if (repoNum === 1 && eForProgress) {
      // Âè™ÊúâÊ†∏ÂøÉ‰ªìÂ∫ìÂ§±Ë¥•Êó∂ÊâçÂêëÁî®Êà∑Êä•Âëä
      await MiaoPluginMBT.ReportError(
        eForProgress,
        `‰∏ãËΩΩ${repoTypeName}`,
        lastError || new Error("ÊâÄÊúâÊ∫ê‰∏ãËΩΩÂ§±Ë¥•"),
        `Â∞ùËØïÊ∫ê: ${sourcesToTry.map((s) => s.name).join(", ")}`,
        loggerInstance
      );
    } else {
      loggerInstance.error(
        `${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] ÊúÄÁªàÈîôËØØ:`,
        lastError || "Êú™Áü•ÈîôËØØ"
      );
    }
    // loggerInstance.info(`${logPrefix} [‰∏ãËΩΩÊµÅÁ®ã ${repoTypeName} (${repoNum}Âè∑)] [ËÆ°Êó∂] ÂáΩÊï∞Â§±Ë¥•ËøîÂõû @ ${Date.now()}`); //Ë∞ÉËØïÊó•Âøó
    return { success: false, nodeName: "ÊâÄÊúâÊ∫êÂ§±Ë¥•", error: lastError };
  }

  /**
   * @description Êõ¥Êñ∞Âçï‰∏™‰ªìÂ∫ìÔºåÂåÖÂê´ÂÜ≤Á™ÅÊ£ÄÊµãÂíåÂº∫Âà∂ÈáçÁΩÆÈÄªËæë„ÄÇ
   */
  static async UpdateSingleRepo(
    e,
    RepoNum,
    localPath,
    RepoName,
    RepoUrl,
    branch,
    isScheduled,
    logger
  ) {
    const logPrefix = Default_Config.logPrefix;
    logger.info(`${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ÂºÄÂßãÊõ¥Êñ∞ ${RepoName} @ ${localPath}`);
    let success = false,
      hasChanges = false,
      latestLog = null,
      pullOutput = "",
      pullError = null;

    await MiaoPluginMBT.gitMutex.acquire();
    try {
      let oldCommit = "";
      try {
        oldCommit = (
          await ExecuteCommand(
            "git",
            ["rev-parse", "HEAD"],
            { cwd: localPath },
            5000
          )
        ).stdout.trim();
      } catch {}

      let needsReset = false;
      try {
        const pullResult = await ExecuteCommand(
          "git",
          ["pull", "--ff-only", "--progress"],
          { cwd: localPath },
          Default_Config.gitPullTimeout,
          undefined,
          (stderrChunk) => {
            const matchLog = stderrChunk.match(
              /(Receiving objects|Resolving deltas):\s*(\d+)%/
            );
            if (matchLog)
              logger.debug(
                `${logPrefix} [Êõ¥Êñ∞ËøõÂ∫¶ ${RepoName}] ${matchLog[1]}: ${matchLog[2]}%`
              );
          }
        );
        pullOutput = pullResult.stdout + pullResult.stderr;
        success = true;
        logger.info(
          `${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} 'git pull --ff-only' ÊàêÂäü„ÄÇ`
        );
      } catch (err) {
        pullError = err;
        pullOutput = err.stderr || err.stdout || err.message || String(err);
        logger.warn(
          `${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} 'git pull --ff-only' Â§±Ë¥•ÔºåÈîôËØØÁ†Å: ${err.code}`
        );
        logger.warn(
          `${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Git ËæìÂá∫:\n${pullOutput}`
        );
        if (
          err.code !== 0 &&
          (err.stderr?.includes("commit") ||
            err.stderr?.includes("unrelated") ||
            err.stderr?.includes("lock") ||
            err.stderr?.includes("fast-forward") ||
            err.message?.includes("failed"))
        ) {
          needsReset = true;
          logger.warn(
            `${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Ê£ÄÊµãÂà∞ÂÜ≤Á™ÅÊàñÁä∂ÊÄÅÂºÇÂ∏∏ÔºåÂáÜÂ§áÂ∞ùËØïÂº∫Âà∂ÈáçÁΩÆ...`
          );
        } else {
          throw err;
        }
      }

      if (needsReset) {
        logger.warn(
          `${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Ê≠£Âú®ÊâßË°åÂº∫Âà∂ÈáçÁΩÆ (git fetch & git reset --hard)...`
        );
        try {
          await ExecuteCommand(
            "git",
            ["fetch", "origin"],
            { cwd: localPath },
            Default_Config.gitPullTimeout
          );
          await ExecuteCommand("git", ["reset", "--hard", `origin/${branch}`], {
            cwd: localPath,
          });
          success = true;
          hasChanges = true;
          logger.info(`${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Âº∫Âà∂ÈáçÁΩÆÊàêÂäü„ÄÇ`);
          latestLog = await MiaoPluginMBT.GetTuKuLog(20, localPath, logger);
        } catch (resetError) {
          logger.error(`${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Âº∫Âà∂ÈáçÁΩÆÂ§±Ë¥•ÔºÅ`);
          success = false;
          throw resetError;
        }
      }

      if (success && !needsReset) {
        let newCommit = "";
        try {
          newCommit = (
            await ExecuteCommand(
              "git",
              ["rev-parse", "HEAD"],
              { cwd: localPath },
              5000
            )
          ).stdout.trim();
        } catch {}
        hasChanges = oldCommit && newCommit && oldCommit !== newCommit;
        if (hasChanges) {
          logger.info(
            `${Default_Config.logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Ê£ÄÊµãÂà∞Êñ∞ÁöÑÊèê‰∫§„ÄÇ`
          );
          latestLog = await MiaoPluginMBT.GetTuKuLog(20, localPath, logger);
        } else if (pullOutput.includes("Already up to date")) {
          logger.info(
            `${Default_Config.logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Â∑≤ÊòØÊúÄÊñ∞„ÄÇ`
          );
          latestLog = await MiaoPluginMBT.GetTuKuLog(1, localPath, logger);
        } else {
          logger.warn(
            `${Default_Config.logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} pull ÊàêÂäü‰ΩÜÊú™Ê£ÄÊµãÂà∞ÊòéÁ°ÆÊõ¥Êñ∞ÔºåËé∑ÂèñÊúÄÊñ∞Êó•Âøó...`
          );
          latestLog = await MiaoPluginMBT.GetTuKuLog(1, localPath, logger);
        }
      }
    } catch (error) {
      success = false;
      hasChanges = false;
      logger.error(`${logPrefix} [Êõ¥Êñ∞‰ªìÂ∫ì] ${RepoName} Êõ¥Êñ∞Êìç‰ΩúÂ§±Ë¥•„ÄÇ`);
      if (RepoNum === 1 && e && !isScheduled) {
        const errorToReport = error || pullError || new Error("Êú™Áü•Êõ¥Êñ∞ÈîôËØØ");
        await MiaoPluginMBT.ReportError(
          e,
          `Êõ¥Êñ∞${RepoName}`,
          errorToReport,
          `GitËæìÂá∫(ÈÉ®ÂàÜ):\n${pullOutput.substring(0, 500)}`,
          logger
        );
      } else {
        logger.error(error || pullError);
      }
    } finally {
      MiaoPluginMBT.gitMutex.release();
    }
    return { success, hasChanges, log: latestLog };
  }

  /**
   * @description ÊâßË°åÈ¶ñÊ¨°‰∏ãËΩΩÂêéÁöÑËÆæÁΩÆÊ≠•È™§„ÄÇ
   */
  static async RunPostDownloadSetup(e, logger = global.logger || console) {
    logger.info(
      `${Default_Config.logPrefix} [‰∏ãËΩΩÂêéËÆæÁΩÆ] ÂºÄÂßãÊâßË°å‰∏ãËΩΩÂêéÂàùÂßãÂåñÊ≠•È™§...`
    );
    try {
      await MiaoPluginMBT.LoadTuKuConfig(true, logger);
      await MiaoPluginMBT.SyncFilesToCommonRes(logger);
      const imageData = await MiaoPluginMBT.LoadImageData(true, logger);
      MiaoPluginMBT._imgDataCache = Object.freeze(imageData);
      await MiaoPluginMBT.LoadUserBans(true, logger);
      await MiaoPluginMBT.LoadAliasData(true, logger);
      await MiaoPluginMBT.SyncSpecificFiles(logger);
      logger.info(
        `${Default_Config.logPrefix} [‰∏ãËΩΩÂêéËÆæÁΩÆ] Â∫îÁî®ÂàùÂßãÂ∞ÅÁ¶ÅËßÑÂàô...`
      );
      await MiaoPluginMBT.GenerateAndApplyBanList(
        MiaoPluginMBT._imgDataCache,
        logger
      );
      if (MiaoPluginMBT.MBTConfig.TuKuOP) {
        logger.info(
          `${Default_Config.logPrefix} [‰∏ãËΩΩÂêéËÆæÁΩÆ] ÈÖçÁΩÆ‰∏∫ÈªòËÆ§ÂêØÁî®ÔºåÂºÄÂßãÂêåÊ≠•ËßíËâ≤ÂõæÁâá...`
        );
        await MiaoPluginMBT.SyncCharacterFolders(logger);
      } else {
        logger.info(
          `${Default_Config.logPrefix} [‰∏ãËΩΩÂêéËÆæÁΩÆ] ÂõæÂ∫ìÈÖçÁΩÆ‰∏∫ÈªòËÆ§Á¶ÅÁî®ÔºåË∑≥ËøáËßíËâ≤ÂõæÁâáÂêåÊ≠•„ÄÇ`
        );
      }
      logger.info(
        `${Default_Config.logPrefix} [‰∏ãËΩΩÂêéËÆæÁΩÆ] ÊâÄÊúâÊ≠•È™§ÊâßË°åÊàêÂäü„ÄÇ`
      );
    } catch (error) {
      logger.error(
        `${Default_Config.logPrefix} [‰∏ãËΩΩÂêéËÆæÁΩÆ] ÊâßË°åËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:`,
        error
      );
      if (e)
        await MiaoPluginMBT.ReportError(e, "ÂÆâË£ÖÂêéËÆæÁΩÆ", error, "", logger);
    }
  }

  /**
   * @description ÊâßË°åÊõ¥Êñ∞ÂêéÁöÑËÆæÁΩÆÊ≠•È™§„ÄÇ          
   */
  static async RunPostUpdateSetup(e, isScheduled = false, logger = global.logger || console) {
    try {
      await MiaoPluginMBT.LoadTuKuConfig(true, logger);
      await MiaoPluginMBT.SyncFilesToCommonRes(logger);
      const imageData = await MiaoPluginMBT.LoadImageData(true, logger);
      MiaoPluginMBT._imgDataCache = Object.freeze(imageData);
      await MiaoPluginMBT.LoadUserBans(true, logger);
      await MiaoPluginMBT.LoadAliasData(true, logger);
      logger.info(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] ÂêåÊ≠•ÁâπÂÆöÊñá‰ª∂...`);
      await MiaoPluginMBT.SyncSpecificFiles(logger);
      logger.info(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] ÈáçÊñ∞Â∫îÁî®Â∞ÅÁ¶ÅËßÑÂàô...`);
      await MiaoPluginMBT.GenerateAndApplyBanList(MiaoPluginMBT._imgDataCache, logger);
      if (MiaoPluginMBT.MBTConfig.TuKuOP) {
        logger.info(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] ÂõæÂ∫ìÂ∑≤ÂêØÁî®ÔºåÊ≠£Âú®ÂêåÊ≠•Êõ¥Êñ∞ÂêéÁöÑËßíËâ≤ÂõæÁâá...`);
        await MiaoPluginMBT.SyncCharacterFolders(logger);
      } else {
        logger.info(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] ÂõæÂ∫ìÂ∑≤Á¶ÅÁî®ÔºåË∑≥ËøáËßíËâ≤ÂõæÁâáÂêåÊ≠•„ÄÇ`);
      }

      if (MiaoPluginMBT.MBTConfig.PM18 === true) {
          logger.info(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] PM18 ÂäüËÉΩÂ∑≤ÂºÄÂêØÔºåÂ∞ÜÂú®ÂêéÂè∞Â∞ùËØïÈÉ®ÁΩ≤ PM18 ÂõæÁâá...`);
          setImmediate(async () => {
              await MiaoPluginMBT.deployPM18Files(logger);
          });
      } else {
          logger.info(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] PM18 ÂäüËÉΩÂ∑≤ÂÖ≥Èó≠ÔºåË∑≥ËøáÈÉ®ÁΩ≤„ÄÇ`);
      }

    } catch (error) {
      logger.error(`${Default_Config.logPrefix} [Êõ¥Êñ∞ÂêéËÆæÁΩÆ] ÊâßË°åËøáÁ®ã‰∏≠ÂèëÁîüÈîôËØØ:`, error);
      if (!isScheduled && e) await MiaoPluginMBT.ReportError(e, 'Êõ¥Êñ∞ÂêéËÆæÁΩÆ', error, '', logger);
      else if (isScheduled) {
        const Report = MiaoPluginMBT.FormatError('Êõ¥Êñ∞ÂêéËÆæÁΩÆ(ÂÆöÊó∂)', error);
        logger.error(
          `${Default_Config.logPrefix}--- ÂÆöÊó∂Êõ¥Êñ∞ÂêéËÆæÁΩÆÂ§±Ë¥• ----\n${Report.summary}\n${Report.suggestions}\n---`
        );
      }
    }
  }

  /**
   * @description ÂêåÊ≠•‰ªìÂ∫ì‰∏≠ÁöÑÊñá‰ª∂Âà∞ÂÖ¨ÂÖ±ËµÑÊ∫êÁõÆÂΩï„ÄÇ
   */
  static async SyncFilesToCommonRes(logger = global.logger || console) {
    await fsPromises.mkdir(MiaoPluginMBT.paths.commonResPath, {
      recursive: true,
    });
    let s = 0,
      f = 0;
    for (const {
      sourceSubPath,
      destFileName,
      copyIfExists = true,
      isDir = false,
    } of MiaoPluginMBT.paths.filesToSyncToCommonRes) {
      const source = path.join(
        MiaoPluginMBT.paths.LocalTuKuPath,
        sourceSubPath
      );
      const dest = path.join(MiaoPluginMBT.paths.commonResPath, destFileName);
      try {
        await fsPromises.access(source);
        if (!copyIfExists) {
          try {
            await fsPromises.access(dest);
            continue;
          } catch (destAccessError) {
            if (destAccessError.code !== ERROR_CODES.NotFound)
              throw destAccessError;
          }
        }
        await fsPromises.mkdir(path.dirname(dest), { recursive: true });
        if (isDir) {
          await copyFolderRecursive(source, dest, {}, logger);
        } else {
          await fsPromises.copyFile(source, dest);
        }
        s++;
      } catch (error) {
        if (error.code === ERROR_CODES.NotFound);
        else {
          logger.error(
            `${Default_Config.logPrefix} [ÂêåÊ≠•ÂÖ¨ÂÖ±] ${sourceSubPath} Â§±Ë¥•:`,
            error
          );
          f++;
        }
      }
    }
    logger.info(
      `${Default_Config.logPrefix} [ÂêåÊ≠•ÂÖ¨ÂÖ±] ÂÆåÊàê: ${s}ÊàêÂäü, ${f}Â§±Ë¥•/Ë∑≥Ëøá„ÄÇ`
    );
  }

  /**
   * @description ÂêåÊ≠•‰ªìÂ∫ì‰∏≠ÁöÑÁâπÂÆöÊñá‰ª∂Âà∞ÊåáÂÆöÁõÆÊ†áÁõÆÂΩï„ÄÇ
   */
  static async SyncSpecificFiles(logger = global.logger || console) {
    let s = 0,
      f = 0;
    for (const { sourceSubPath, destDir, destFileName } of MiaoPluginMBT.paths
      .filesToSyncSpecific) {
      const source = path.join(
        MiaoPluginMBT.paths.LocalTuKuPath,
        sourceSubPath
      );
      const dest = path.join(destDir, destFileName);
      try {
        await fsPromises.access(source);
        await fsPromises.mkdir(destDir, { recursive: true });
        await fsPromises.copyFile(source, dest);
        s++;
      } catch (error) {
        if (error.code === ERROR_CODES.NotFound);
        else {
          logger.error(
            `${Default_Config.logPrefix} [ÂêåÊ≠•ÁâπÂÆö] ${sourceSubPath} -> ${dest} Â§±Ë¥•:`,
            error
          );
          f++;
        }
      }
    }
    logger.info(
      `${Default_Config.logPrefix} [ÂêåÊ≠•ÁâπÂÆö] ÂÆåÊàê: ${s}ÊàêÂäü, ${f}Â§±Ë¥•/Ë∑≥Ëøá„ÄÇ`
    );
  }

  /**
   * @description ÂêåÊ≠•ËßíËâ≤ÂõæÁâáÊñá‰ª∂Â§πÂà∞ÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï„ÄÇ
   */
  static async SyncCharacterFolders(logger = global.logger || console) {
    const targetPluginDirs = [
      MiaoPluginMBT.paths.target.miaoChar,
      MiaoPluginMBT.paths.target.zzzChar,
      MiaoPluginMBT.paths.target.wavesChar,
    ].filter(Boolean);

    await Promise.all(
      targetPluginDirs.map((dir) =>
        MiaoPluginMBT.CleanTargetCharacterDirs(dir, logger)
      )
    );
    const imageDataToSync = MiaoPluginMBT._imgDataCache;
    if (!imageDataToSync || imageDataToSync.length === 0) {
      logger.warn(
        `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] ÂÖÉÊï∞ÊçÆ‰∏∫Á©∫ÔºåÊó†Ê≥ïÂêåÊ≠•„ÄÇ`
      );
      return;
    }
    if (!(MiaoPluginMBT._activeBanSet instanceof Set)) {
      logger.warn(
        `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] ÁîüÊïàÂ∞ÅÁ¶ÅÂàóË°®Êú™ÂàùÂßãÂåñÊàñÁ±ªÂûãÈîôËØØ„ÄÇ`
      );
    }

    logger.info(
      `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] ÂºÄÂßãÂ§çÂà∂ (${imageDataToSync.length} Êù°ÂÖÉÊï∞ÊçÆ)...`
    );
    let copied = 0,
      banned = 0,
      missingSource = 0,
      noTarget = 0,
      errorCount = 0;
    const promises = [];

    for (const imgData of imageDataToSync) {
      const relativePath = imgData.path?.replace(/\\/g, "/");
      const storageBox = imgData.storagebox;

      if (!relativePath || !storageBox) {
        logger.warn(
          `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] Ë∑≥ËøáÊó†ÊïàÂÖÉÊï∞ÊçÆÈ°π: path=${relativePath}, storagebox=${storageBox}`
        );
        noTarget++;
        continue;
      }

      if (MiaoPluginMBT._activeBanSet.has(relativePath)) {
        banned++;
        continue;
      }
      let sourceBasePath;
      if (storageBox === "Miao-Plugin-MBT") {
        sourceBasePath = MiaoPluginMBT.paths.LocalTuKuPath;
      } else if (storageBox === "Miao-Plugin-MBT-2") {
        sourceBasePath = MiaoPluginMBT.paths.LocalTuKuPath2;
      } else if (storageBox === "Miao-Plugin-MBT-3") {
        sourceBasePath = MiaoPluginMBT.paths.LocalTuKuPath3;
      } else {
        logger.warn(
          `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] Êú™Áü•ÁöÑ storagebox: ${storageBox} for path: ${relativePath}`
        );
        noTarget++;
        continue;
      }
      if (!sourceBasePath) {
        logger.warn(
          `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] ‰ªìÂ∫ìË∑ØÂæÑÊú™ÂÆö‰πâ: ${storageBox}`
        );
        missingSource++;
        continue;
      }
      const sourcePath = path.join(sourceBasePath, relativePath);
      const targetPath = await MiaoPluginMBT.DetermineTargetPath(relativePath);
      if (targetPath) {
        promises.push(
          (async () => {
            try {
              await fsPromises.access(sourcePath, fs.constants.R_OK);
              try {
                await fsPromises.mkdir(path.dirname(targetPath), {
                  recursive: true,
                });
                await fsPromises.copyFile(sourcePath, targetPath);
                copied++;
              } catch (copyErr) {
                errorCount++;
                if (copyErr.code !== ERROR_CODES.NotFound)
                  logger.warn(
                    `${
                      Default_Config.logPrefix
                    } [ÂêåÊ≠•ËßíËâ≤] Â§çÂà∂Â§±Ë¥•: ${path.basename(
                      sourcePath
                    )} -> ${targetPath}`,
                    copyErr.code
                  );
              }
            } catch (sourceAccessErr) {
              if (sourceAccessErr.code === ERROR_CODES.NotFound) {
                missingSource++;
              } else {
                errorCount++;
                logger.warn(
                  `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] ËÆøÈóÆÊ∫êÊñá‰ª∂Â§±Ë¥•: ${sourcePath}`,
                  sourceAccessErr.code
                );
              }
            }
          })()
        );
      } else {
        noTarget++;
      }
    }
    await Promise.all(promises);
    logger.info(
      `${Default_Config.logPrefix} [ÂêåÊ≠•ËßíËâ≤] ÂÆåÊàê: Â§çÂà∂${copied}, Ë∑≥Ëøá(Â∞ÅÁ¶Å${banned}+Ê∫ê‰∏¢Â§±${missingSource}+Êó†ÁõÆÊ†á${noTarget}+ÈîôËØØ${errorCount})„ÄÇ`
    );
  }

  /**
   * @description Ê∏ÖÁêÜÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï‰∏≠Áî±Êú¨Êèí‰ª∂ÂàõÂª∫ÁöÑÂõæÁâáÊñá‰ª∂„ÄÇ
   */
  static async CleanTargetCharacterDirs(
    targetPluginDir,
    logger = global.logger || console
  ) {
    if (!targetPluginDir) return;
    logger.info(`${Default_Config.logPrefix} [Ê∏ÖÁêÜÁõÆÊ†á] ${targetPluginDir}`);
    let cleanedCount = 0;
    try {
      await fsPromises.access(targetPluginDir);
      const entries = await fsPromises.readdir(targetPluginDir, {
        withFileTypes: true,
      });
      for (const entry of entries) {
        const entryPath = path.join(targetPluginDir, entry.name);
        if (entry.isDirectory()) {
          const characterPath = entryPath;
          try {
            const files = await fsPromises.readdir(characterPath);
            const filesToDelete = files.filter(
              (f) =>
                f.toLowerCase().includes("gu") &&
                f.toLowerCase().endsWith(".webp")
            );
            for (const fileToDelete of filesToDelete) {
              const filePath = path.join(characterPath, fileToDelete);
              try {
                await fsPromises.unlink(filePath);
                cleanedCount++;
              } catch (unlinkErr) {
                if (unlinkErr.code !== ERROR_CODES.NotFound)
                  logger.warn(
                    `${Default_Config.logPrefix} [Ê∏ÖÁêÜÁõÆÊ†á] Âà†Èô§Êñá‰ª∂ ${filePath} Â§±Ë¥•:`,
                    unlinkErr.code
                  );
              }
            }
          } catch (readSubErr) {
            if (
              ![ERROR_CODES.NotFound, ERROR_CODES.Access].includes(
                readSubErr.code
              )
            )
              logger.warn(
                `${Default_Config.logPrefix} [Ê∏ÖÁêÜÁõÆÊ†á] ËØªÂèñËßíËâ≤Â≠êÁõÆÂΩï ${characterPath} Â§±Ë¥•:`,
                readSubErr.code
              );
          }
        } else if (
          entry.isFile() &&
          entry.name.toLowerCase().includes("gu") &&
          entry.name.toLowerCase().endsWith(".webp")
        ) {
          const rootFilePath = entryPath;
          try {
            await fsPromises.unlink(rootFilePath);
            cleanedCount++;
          } catch (delErr) {
            if (delErr.code !== ERROR_CODES.NotFound)
              logger.warn(
                `${Default_Config.logPrefix} [Ê∏ÖÁêÜÁõÆÊ†á] Âà†Èô§Ê†πÁõÆÂΩïÊñá‰ª∂ ${rootFilePath} Â§±Ë¥•:`,
                delErr.code
              );
          }
        }
      }
      logger.info(
        `${Default_Config.logPrefix} [Ê∏ÖÁêÜÁõÆÊ†á] Ê∏ÖÁêÜÂÆåÊàê: ${targetPluginDir}, ÂÖ±Ê∏ÖÁêÜ ${cleanedCount} ‰∏™ÂåÖÂê´ 'Gu' ÁöÑ .webp Êñá‰ª∂„ÄÇ`
      );
    } catch (readBaseErr) {
      if (
        readBaseErr.code !== ERROR_CODES.NotFound &&
        readBaseErr.code !== ERROR_CODES.Access
      )
        logger.error(
          `${Default_Config.logPrefix} [Ê∏ÖÁêÜÁõÆÊ†á] ËØªÂèñÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï ${targetPluginDir} Â§±Ë¥•:`,
          readBaseErr
        );
    }
  }

  /**
   * @description ÂêéÂè∞ÊâßË°å PM18 ÂõæÁâáÁöÑËß£ÂØÜÂíåÈÉ®ÁΩ≤„ÄÇ
   */
  static async deployPM18Files(logger = global.logger || console) {
    const logPrefix = Default_Config.logPrefix;
    const sourceRepoPath = MiaoPluginMBT.paths.LocalTuKuPath3;
    const tempCachePath = path.join(MiaoPluginMBT.paths.commonResPath, 'Temp');
    const targetPluginDirs = [
        MiaoPluginMBT.paths.target.miaoChar,
        MiaoPluginMBT.paths.target.zzzChar,
        MiaoPluginMBT.paths.target.wavesChar,
    ].filter(Boolean);

    logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ÂºÄÂßãÊâßË°å...`);
    let copiedCount = 0, decryptedCount = 0, placedCount = 0, errorCount = 0;
    let deployError = null; 

    try {
      if (!await MiaoPluginMBT.IsTuKuDownloaded(3)) {
        logger.error(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Â§±Ë¥•ÔºöÊú™ÊâæÂà∞‰∏âÂè∑‰ªìÂ∫ì„ÄÇ`);
        return;
      }

      //logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Ê∏ÖÁêÜÂπ∂ÂàõÂª∫‰∏¥Êó∂ÁõÆÂΩï: ${tempCachePath}`);
      await safeDelete(tempCachePath);
      await fsPromises.mkdir(tempCachePath, { recursive: true });

      //logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ÂºÄÂßã‰ªé ${sourceRepoPath} Â§çÂà∂ .MBT Êñá‰ª∂...`);
      const findAndCopyMbt = async (currentSourceDir, currentTempDir) => {
           try {
                const entries = await fsPromises.readdir(currentSourceDir, { withFileTypes: true });
                for (const entry of entries) {
                    const sourcePath = path.join(currentSourceDir, entry.name);
                    const tempPath = path.join(currentTempDir, entry.name);
                    if (entry.isDirectory()) {
                        await fsPromises.mkdir(tempPath, { recursive: true });
                        await findAndCopyMbt(sourcePath, tempPath);
                    } else if (entry.isFile() && entry.name.toLowerCase().endsWith('.mbt')) {
                        try {
                            await fsPromises.copyFile(sourcePath, tempPath);
                            copiedCount++;
                        } catch (copyErr) {
                            logger.warn(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Â§çÂà∂Êñá‰ª∂Â§±Ë¥•: ${sourcePath} -> ${tempPath}`, copyErr.code);
                            errorCount++;
                        }
                    }
                }
            } catch (readErr) {
                 //logger.warn(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ËØªÂèñÊ∫êÁõÆÂΩïÂ§±Ë¥•: ${currentSourceDir}`, readErr.code);
                 errorCount++;
            }
      };
      await findAndCopyMbt(sourceRepoPath, tempCachePath);
      logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ÂÖ±Â§çÂà∂ ${copiedCount} ‰∏™ .MBT Êñá‰ª∂„ÄÇ`);

      if (copiedCount === 0) {
           //logger.warn(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Êú™ÊâæÂà∞ÈúÄË¶ÅÂ§ÑÁêÜÁöÑÂä†ÂØÜÊñá‰ª∂„ÄÇ`);
           await safeDelete(tempCachePath);
           return;
      }

      const password = Buffer.from("1004031540");
      const salt = Buffer.from('guguniumbtpm18salt');
      const keyLength = 32;
      const iterations = 100000;
      const digest = 'sha256';
      const key = crypto.pbkdf2Sync(password, salt, iterations, keyLength, digest);
      //logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Ëß£ÂØÜÂØÜÈí•ÂÆåÊàê„ÄÇ`);

      const unpad = (buffer) => {
          const padding = buffer[buffer.length - 1];
          if (padding < 1 || padding > 16) return buffer;
          for (let i = buffer.length - padding; i < buffer.length; i++) {
              if (buffer[i] !== padding) return buffer;
          }
          return buffer.slice(0, buffer.length - padding);
      };

      logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ÂºÄÂßãËß£ÂØÜÂπ∂ÈáäÊîæÊñá‰ª∂...`);
      const decryptAndPlace = async (currentTempDir) => {
           try {
                const entries = await fsPromises.readdir(currentTempDir, { withFileTypes: true });
                for (const entry of entries) {
                    const tempPath = path.join(currentTempDir, entry.name);
                    if (entry.isDirectory()) {
                        await decryptAndPlace(tempPath);
                    } else if (entry.isFile() && entry.name.toLowerCase().endsWith('.mbt')) {
                        const relativePath = path.relative(tempCachePath, tempPath);
                        const targetFileName = entry.name.replace(/\.mbt$/i, '.webp');
                        const targetRelativePath = path.join(path.dirname(relativePath), targetFileName);

                        try {
                            const encryptedDataWithIv = await fsPromises.readFile(tempPath);
                            if (encryptedDataWithIv.length <= 16) throw new Error('Âä†ÂØÜÊñá‰ª∂ËøáÁü≠');
                            const iv = encryptedDataWithIv.slice(0, 16);
                            const ciphertext = encryptedDataWithIv.slice(16);
                            const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);
                            let decryptedData = Buffer.concat([decipher.update(ciphertext), decipher.final()]);
                            decryptedData = unpad(decryptedData);

                            const finalTargetPath = await MiaoPluginMBT.DetermineTargetPath(targetRelativePath);
                            if (!finalTargetPath) {
                                logger.warn(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Êó†Ê≥ïÁ°ÆÂÆöÁõÆÊ†áË∑ØÂæÑ: ${targetRelativePath}`);
                                errorCount++;
                                continue;
                            }

                            await fsPromises.mkdir(path.dirname(finalTargetPath), { recursive: true });
                            await fsPromises.writeFile(finalTargetPath, decryptedData);
                            decryptedCount++;
                            placedCount++;
                        } catch (decryptError) {
                            logger.error(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Ëß£ÂØÜÊàñÂÜôÂÖ•Êñá‰ª∂Â§±Ë¥•: ${tempPath}`, decryptError);
                            errorCount++;
                        }
                    }
                }
            } catch (readErr) {
                 logger.warn(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ËØªÂèñ‰∏¥Êó∂ÁõÆÂΩïÂ§±Ë¥•: ${currentTempDir}`, readErr.code);
                 errorCount++;
            }
      };
      await decryptAndPlace(tempCachePath);
      logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Ëß£ÂØÜÂÆåÊàêÔºåÊàêÂäüËß£ÂØÜ ${decryptedCount} ‰∏™ÔºåÊàêÂäüÈáäÊîæ ${placedCount} ‰∏™„ÄÇ`);

    } catch (error) {
      deployError = error; 
      //logger.error(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ÊâßË°åËøáÁ®ã‰∏≠ÂèëÁîü‰∏•ÈáçÈîôËØØ:`, error);
    } finally {
      //logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]Ê∏ÖÁêÜ‰∏¥Êó∂ÁõÆÂΩï...`);
      await safeDelete(tempCachePath);
      //logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]‰∏¥Êó∂ÁõÆÂΩïÂ∑≤Ê∏ÖÁêÜ„ÄÇ`);
      logger.info(`${logPrefix} [PM18ÈÉ®ÁΩ≤]ÊâßË°åÁªìÊùü„ÄÇÈîôËØØÊï∞: ${errorCount}`);
    }
  }

  /**
   * @description ÊâßË°å PM18 ÂõæÁâáÁöÑÊ∏ÖÁêÜ„ÄÇ
   */
  static async cleanPM18Files(logger = global.logger || console) {
    const logPrefix = Default_Config.logPrefix;
    const targetPluginDirs = [
        MiaoPluginMBT.paths.target.miaoChar,
        MiaoPluginMBT.paths.target.zzzChar,
        MiaoPluginMBT.paths.target.wavesChar,
    ].filter(Boolean);

    logger.info(`${logPrefix} [PM18Ê∏ÖÁêÜ] ÂºÄÂßãÊâßË°å...`);
    let cleanedCount = 0;
    let cleanErrorCount = 0;

    try {
        const cleanPromises = targetPluginDirs.map(async (targetDir) => {
            logger.info(`${logPrefix} [PM18Ê∏ÖÁêÜ] Ê≠£Âú®Êâ´ÊèèÁõÆÂΩï: ${targetDir}`);
            try {
                await fsPromises.access(targetDir);
                const findAndDeleteGuX = async (currentDir) => {
                     try {
                          const entries = await fsPromises.readdir(currentDir, { withFileTypes: true });
                          for (const entry of entries) {
                              const entryPath = path.join(currentDir, entry.name);
                              if (entry.isDirectory()) {
                                  await findAndDeleteGuX(entryPath);
                              } else if (entry.isFile() && entry.name.toLowerCase().includes('gux') && entry.name.toLowerCase().endsWith('.webp')) {
                                  try {
                                      await fsPromises.unlink(entryPath);
                                      cleanedCount++;
                                  } catch (unlinkErr) {
                                      if (unlinkErr.code !== ERROR_CODES.NotFound) {
                                          //logger.warn(`${logPrefix} [PM18Ê∏ÖÁêÜ] Âà†Èô§Êñá‰ª∂ ${entryPath} Â§±Ë¥•:`, unlinkErr.code);
                                          cleanErrorCount++;
                                      }
                                  }
                              }
                          }
                      } catch (readErr) {
                          if (readErr.code !== ERROR_CODES.NotFound && readErr.code !== ERROR_CODES.Access) {
                              //logger.warn(`${logPrefix} [PM18Ê∏ÖÁêÜ] ËØªÂèñÁõÆÂΩï ${currentDir} Â§±Ë¥•:`, readErr.code);
                              cleanErrorCount++;
                          }
                      }
                };
                await findAndDeleteGuX(targetDir);
            } catch (accessErr) {
                if (accessErr.code !== ERROR_CODES.NotFound) {
                    //logger.warn(`${logPrefix} [PM18Ê∏ÖÁêÜ] ËÆøÈóÆÁõÆÊ†áÁõÆÂΩïÂ§±Ë¥•: ${targetDir}`, accessErr.code);
                    cleanErrorCount++;
                } else {
                    //logger.info(`${logPrefix} [PM18Ê∏ÖÁêÜ] ÁõÆÊ†áÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåË∑≥Ëøá: ${targetDir}`);
                }
            }
        });

        await Promise.all(cleanPromises);
        logger.info(`${logPrefix} [PM18Ê∏ÖÁêÜ] Ê∏ÖÁêÜÂÆåÊàêÔºåÂÖ±Âà†Èô§ ${cleanedCount} ‰∏™ GuX ÂõæÁâáÊñá‰ª∂„ÄÇ`);

    } catch (error) {
        //logger.error(`${logPrefix} [PM18Ê∏ÖÁêÜ] ÊâßË°åËøáÁ®ã‰∏≠ÂèëÁîü‰∏•ÈáçÈîôËØØ:`, error);
    } finally {
        logger.info(`${logPrefix} [PM18Ê∏ÖÁêÜ] ÊâßË°åÁªìÊùü„ÄÇÈîôËØØÊï∞: ${cleanErrorCount}`);
    }
  }

  /**
   * @description ‰ªéÊú¨Âú∞‰ªìÂ∫ìÊ∫êÊÅ¢Â§çÂçï‰∏™Ë¢´Ëß£Á¶ÅÁöÑÊñá‰ª∂Âà∞ÁõÆÊ†áÊèí‰ª∂ÁõÆÂΩï„ÄÇ
   */
  static async RestoreFileFromSource(
    relativePath,
    logger = global.logger || console
  ) {
    const sourcePath = await MiaoPluginMBT.FindImageAbsolutePath(relativePath);
    if (!sourcePath) {
      return false;
    }
    const targetPath = await MiaoPluginMBT.DetermineTargetPath(relativePath);
    if (!targetPath) {
      return false;
    }
    try {
      await fsPromises.mkdir(path.dirname(targetPath), { recursive: true });
      await fsPromises.copyFile(sourcePath, targetPath);
      logger.info(`${Default_Config.logPrefix} [ÊÅ¢Â§çÊñá‰ª∂] ${targetPath}`);
      return true;
    } catch (copyError) {
      logger.error(
        `${Default_Config.logPrefix} [ÊÅ¢Â§çÊñá‰ª∂] ${relativePath} Â§±Ë¥•:`,
        copyError
      );
      return false;
    }
  }

  /**
   * @description Ëé∑ÂèñÊ∏≤ÊüìÁº©ÊîæÊ†∑ÂºèÂÄº
   */
  static getScaleStyleValue(baseScale = 1) {
    const scalePercent =
      MiaoPluginMBT.MBTConfig?.renderScale ?? Default_Config.renderScale;
    const scaleFactor = Math.min(
      2,
      Math.max(0.5, (Number(scalePercent) || 100) / 100)
    );
    const finalScale = baseScale * scaleFactor;
    return `transform:scale(${finalScale}); transform-origin: top left;`;
  }

  /**
   * @description Ëé∑ÂèñÂΩìÂâçÊèí‰ª∂ÁöÑÁâàÊú¨Âè∑
   */
  static GetVersionStatic() {
    try {
      const pkgPath = path.resolve(__dirname, "..", "package.json");
      const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));
      return pkg.version || "4.9.0";
    } catch {
      return "4.9.0";
    }
  }

  /**
   * @description ÊµãËØïÊâÄÊúâÈÖçÁΩÆÁöÑ‰ª£ÁêÜËäÇÁÇπÁöÑËøûÈÄöÊÄßÂíåÈÄüÂ∫¶„ÄÇ
   */
  static async TestProxies(
    baseRawUrl = RAW_URL_Repo1,
    logger = global.logger || console
  ) {
    const testFile = Default_Config.proxyTestFile;
    const timeoutDuration = Default_Config.proxyTestTimeout;
    const testPromises = Default_Config.proxies.map(async (proxy) => {
      let testUrl = "";
      let speed = Infinity;
      if (!proxy || typeof proxy !== "object") {
        logger.error(
          `${Default_Config.logPrefix} [ÁΩëÁªúÊµãÈÄü] ÈÅáÂà∞Êó†ÊïàÁöÑ‰ª£ÁêÜÈÖçÁΩÆÈ°π: ${proxy}`
        );
        return {
          name: "Êó†ÊïàÈÖçÁΩÆ",
          speed: Infinity,
          priority: 9999,
          cloneUrlPrefix: null,
          testUrlPrefix: null,
        };
      }
      const proxyName = proxy.name || "Êú™ÂëΩÂêç";
      if (proxy.testUrlPrefix === null) {
        return {
          name: proxyName,
          speed: Infinity,
          priority: proxy.priority ?? 999,
          cloneUrlPrefix: proxy.cloneUrlPrefix,
          testUrlPrefix: null,
        };
      }
      try {
        if (proxy.name === "GitHub") {
          testUrl = baseRawUrl + testFile;
        } else if (proxy.testUrlPrefix) {
          testUrl = proxy.testUrlPrefix.replace(/\/$/, "") + testFile;
          try {
            new URL(testUrl);
          } catch (urlError) {
            logger.warn(
              `${Default_Config.logPrefix} [ÁΩëÁªúÊµãÈÄü] ÊûÑÈÄ†ÁöÑ‰ª£ÁêÜURL (${testUrl}) Ê†ºÂºèÂèØËÉΩ‰∏çËßÑËåÉ:`,
              urlError.message
            );
          }
        } else {
          return {
            name: proxyName,
            speed: Infinity,
            priority: proxy.priority ?? 999,
            cloneUrlPrefix: proxy.cloneUrlPrefix,
            testUrlPrefix: proxy.testUrlPrefix,
          };
        }
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          controller.abort();
        }, timeoutDuration);
        const startTime = Date.now();
        try {
          const response = await fetch(testUrl, {
            method: "GET",
            signal: controller.signal,
          });
          clearTimeout(timeoutId);
          speed = Date.now() - startTime;
          if (!response.ok) {
            logger.warn(
              `${Default_Config.logPrefix} [ÁΩëÁªúÊµãÈÄü] ${proxyName} (${testUrl}) Áä∂ÊÄÅÁ†ÅÈùû OK: ${response.status}`
            );
            speed = Infinity;
          }
        } catch (fetchError) {
          clearTimeout(timeoutId);
          if (fetchError.name === "AbortError") {
            speed = Infinity;
            logger.warn(
              `${Default_Config.logPrefix} [ÁΩëÁªúÊµãÈÄü] ${proxyName} (${testUrl}) Ë∂ÖÊó∂ (>${timeoutDuration}ms)`
            );
          } else {
            logger.error(
              `${Default_Config.logPrefix} [ÁΩëÁªúÊµãÈÄü] ${proxyName} (${testUrl}) fetch Âá∫Èîô: ${fetchError.message}`
            );
            speed = Infinity;
          }
        }
      } catch (error) {
        logger.error(
          `${Default_Config.logPrefix} [ÁΩëÁªúÊµãÈÄü] Â§ÑÁêÜËäÇÁÇπ ${proxyName} Êó∂ÂèëÁîüÊÑèÂ§ñÈîôËØØ:`,
          error
        );
        speed = Infinity;
      }
      return {
        name: proxyName,
        speed: speed,
        priority: proxy.priority ?? 999,
        cloneUrlPrefix: proxy.cloneUrlPrefix,
        testUrlPrefix: proxy.testUrlPrefix,
      };
    });
    const results = await Promise.all(testPromises);
    return results;
  }

  /**
   * @description Ê†πÊçÆÊµãÈÄüÁªìÊûúÂíå‰ºòÂÖàÁ∫ßÔºåÈÄâÊã©ÊúÄ‰Ω≥ÁöÑÂèØÁî®‰∏ãËΩΩÊ∫ê„ÄÇ
   */
  static GetSortedAvailableSources(
    speeds,
    includeUntestable = false,
    logger = global.logger || console
  ) {
    if (!speeds || speeds.length === 0) return [];
    const available = speeds.filter((s) => {
      const testedOK =
        s.speed !== Infinity && (s.name === "GitHub" || s.cloneUrlPrefix);
      const untestableButValid =
        includeUntestable && s.testUrlPrefix === null && s.cloneUrlPrefix;
      return testedOK || untestableButValid;
    });
    if (available.length === 0) {
      logger.warn(
        `${Default_Config.logPrefix} [ÈÄâÊã©Ê∫ê] Ê≤°ÊúâÊâæÂà∞‰ªª‰ΩïÂèØÁî®ÁöÑ‰∏ãËΩΩÊ∫êÔºÅ`
      );
      return [];
    }
    available.sort((a, b) => {
      const prioA = a.priority ?? 999;
      const prioB = b.priority ?? 999;
      if (prioA !== prioB) return prioA - prioB;
      const speedA =
        a.speed === Infinity || a.testUrlPrefix === null ? Infinity : a.speed;
      const speedB =
        b.speed === Infinity || b.testUrlPrefix === null ? Infinity : b.speed;
      return speedA - speedB;
    });
    const sourceNames = available.map(
      (s) =>
        `${s.name}(P:${s.priority ?? "N"}${
          s.speed !== Infinity
            ? `, ${s.speed}ms`
            : s.testUrlPrefix === null
            ? ", N/A"
            : ", Timeout"
        })`
    );
    logger.info(
      `${Default_Config.logPrefix} [ÈÄâÊã©Ê∫ê] ÂèØÁî®‰∏ãËΩΩÊ∫êÊéíÂ∫è: ${sourceNames.join(
        " > "
      )}`
    );
    return available;
  }
}

const GUGUNIU_RULES = [
  { reg: /^#‰∏ãËΩΩÂíïÂíïÁâõ$/i, fnc: "DownloadTuKu", permission: "master" },
  { reg: /^#Êõ¥Êñ∞ÂíïÂíïÁâõ$/i, fnc: "UpdateTuKu", permission: "master" },
  { reg: /^#ÈáçÁΩÆÂíïÂíïÁâõ$/i, fnc: "ManageTuKu", permission: "master" },
  { reg: /^#Ê£ÄÊü•ÂíïÂíïÁâõ$/i, fnc: "CheckStatus" },
  { reg: /^#(ÂêØÁî®|Á¶ÅÁî®)ÂíïÂíïÁâõ$/i,fnc: "ManageTuKuOption",permission: "master",},
  { reg: /^#ÂíïÂíïÁâõÂ∞ÅÁ¶Å\s*.+$/i, fnc: "ManageUserBans", permission: "master" },
  { reg: /^#ÂíïÂíïÁâõËß£Á¶Å\s*.+$/i, fnc: "ManageUserBans", permission: "master" },
  { reg: /^#(?:ban|ÂíïÂíïÁâõÂ∞ÅÁ¶Å)ÂàóË°®$/i, fnc: "ManageUserBans" },
  { reg: /^#ÂíïÂíïÁâõÂØºÂá∫\s*.+$/i, fnc: "ExportSingleImage" },
  { reg: /^#Êü•Áúã\s*.+$/i, fnc: "FindRoleSplashes" },
  { reg: /^#ÂèØËßÜÂåñ\s*.+$/i, fnc: "VisualizeRoleSplashes" },
  { reg: /^#ÂíïÂíïÁâõÂ∏ÆÂä©$/i, fnc: "Help" },
  { reg: /^#ÂíïÂíïÁâõ$/i, fnc: "PluginInfo" },
  {
    reg: /^#ÂíïÂíïÁâõËß¶ÂèëÈîôËØØ(?:\s*(git|fs|config|data|ref|type|Repo1|Repo2|notify|other))?$/i,
    fnc: "TriggerError",
    permission: "master",
  },
  { reg: /^#ÂíïÂíïÁâõÊµãÈÄü$/i, fnc: "ManualTestProxies" },
  { reg: /^#ÊâßË°åÂíïÂíïÁâõÊõ¥Êñ∞$/i,fnc: "ManualRunUpdateTask",permission: "master",},
  { reg: /^#(ÂíïÂíïÁâõËÆæÁΩÆ|ÂíïÂíïÁâõÈù¢Êùø)$/i, fnc: "ShowSettingsPanel" },
  { reg: /^#ÂíïÂíïÁâõËÆæÁΩÆ(ai|ÂΩ©Ëõã|Ê®™Â±è|ÂáÄÂåñÁ≠âÁ∫ß|PM18)([012]|ÂºÄÂêØ|ÂÖ≥Èó≠)$/i, fnc: 'HandleSettingsCommand', permission: 'master' },
];

